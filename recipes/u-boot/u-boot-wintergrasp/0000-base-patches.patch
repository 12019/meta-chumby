diff -Nur u-boot-2009.08.orig/board/freescale/mx28_evk/mx28_evk.c u-boot-2009.08/board/freescale/mx28_evk/mx28_evk.c
--- u-boot-2009.08.orig/board/freescale/mx28_evk/mx28_evk.c	2011-03-17 12:40:51.183779061 +0800
+++ u-boot-2009.08/board/freescale/mx28_evk/mx28_evk.c	2011-04-26 16:32:10.583706051 +0800
@@ -29,6 +29,10 @@
 #include <mmc.h>
 #include <imx_ssp_mmc.h>
 
+#ifdef CONFIG_NAND_GPMI
+void setup_gpmi_nand();
+#endif
+
 /* This should be removed after it's added into mach-types.h */
 #ifndef MACH_TYPE_MX28EVK
 #define MACH_TYPE_MX28EVK	2531
@@ -49,7 +53,7 @@
 	{ PINID_SSP0_DATA6, PIN_FUN1, PAD_8MA, PAD_3V3, 1 },
 	{ PINID_SSP0_DATA7, PIN_FUN1, PAD_8MA, PAD_3V3, 1 },
 	{ PINID_SSP0_CMD, PIN_FUN1, PAD_8MA, PAD_3V3, 1 },
-	{ PINID_SSP0_DETECT, PIN_FUN1, PAD_8MA, PAD_3V3, 1 },
+	{ PINID_SSP0_DETECT, PIN_FUN1, PAD_8MA, PAD_3V3, 0 },
 	{ PINID_SSP0_SCK, PIN_FUN1, PAD_8MA, PAD_3V3, 1 },
 };
 
@@ -165,9 +169,15 @@
 
 u32 ssp_mmc_is_wp(struct mmc *mmc)
 {
+
+#if 1
+	return 0;
+#else
 	return (mmc->block_dev.dev == 0) ?
 		pin_gpio_get(PINID_SSP0_GPIO_WP) :
 		pin_gpio_get(PINID_SSP1_GPIO_WP);
+#endif
+
 }
 
 int ssp_mmc_gpio_init(bd_t *bis)
diff -Nur u-boot-2009.08.orig/cpu/arm926ejs/mx28/generic.c u-boot-2009.08/cpu/arm926ejs/mx28/generic.c
--- u-boot-2009.08.orig/cpu/arm926ejs/mx28/generic.c	2011-03-17 12:40:54.814592249 +0800
+++ u-boot-2009.08/cpu/arm926ejs/mx28/generic.c	2011-05-18 16:28:20.566467069 +0800
@@ -108,6 +108,8 @@
 static inline void __enable_gpmi_clk(void)
 {
 	/* Clear bypass bit*/
+
+#if 0
 	REG_SET(REGS_CLKCTRL_BASE, HW_CLKCTRL_CLKSEQ,
 	       BM_CLKCTRL_CLKSEQ_BYPASS_GPMI);
 	/* Set gpmi clock to ref_gpmi/12 */
@@ -116,6 +118,42 @@
 	      (~(BM_CLKCTRL_GPMI_DIV)) &
 	      (~(BM_CLKCTRL_GPMI_CLKGATE)) |
 	      1);
+#else
+  static int init = 0;
+  int m;
+
+  if (!init)
+  {
+    m = REG_RD(REGS_CLKCTRL_BASE, HW_CLKCTRL_FRAC1);
+    m &= ~BM_CLKCTRL_FRAC1_GPMIFRAC;
+    m &= ~BM_CLKCTRL_FRAC1_CLKGATEGPMI;
+    m |= 18 << BP_CLKCTRL_FRAC1_GPMIFRAC;
+    REG_WR(REGS_CLKCTRL_BASE, HW_CLKCTRL_FRAC1, m);
+
+    REG_CLR(REGS_CLKCTRL_BASE, HW_CLKCTRL_CLKSEQ,
+           BM_CLKCTRL_CLKSEQ_BYPASS_GPMI);
+
+    m = REG_RD(REGS_CLKCTRL_BASE, HW_CLKCTRL_GPMI);
+    m &= ~BM_CLKCTRL_GPMI_DIV;
+    m &= ~BM_CLKCTRL_GPMI_DIV_FRAC_EN;
+    m &= ~BM_CLKCTRL_GPMI_CLKGATE;
+
+    /* Set gpmi clock to ref_gpmi/6 */
+    m |= 6;
+
+    REG_WR(REGS_CLKCTRL_BASE, HW_CLKCTRL_GPMI, m);
+
+    while (1)
+    {
+      if (!(REG_RD(REGS_CLKCTRL_BASE, HW_CLKCTRL_GPMI) &
+            BM_CLKCTRL_GPMI_BUSY))
+        break;
+    }
+
+    init = 1;
+  }
+#endif
+
 }
 static u32 mx28_get_gpmiclk(void)
 {
diff -Nur u-boot-2009.08.orig/drivers/mtd/mtdpart.c u-boot-2009.08/drivers/mtd/mtdpart.c
--- u-boot-2009.08.orig/drivers/mtd/mtdpart.c	2011-03-17 12:40:55.013346953 +0800
+++ u-boot-2009.08/drivers/mtd/mtdpart.c	2011-04-28 11:48:52.280041589 +0800
@@ -371,8 +371,12 @@
 	if (slave->mtd.size == MTDPART_SIZ_FULL)
 		slave->mtd.size = master->size - slave->offset;
 
-	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
-		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);
+	printk(KERN_NOTICE "0x%08x%08x-0x%08x%08x : \"%s\"\n",
+         (int) (slave->offset >> 32),
+         (int) (slave->offset & 0xffffffff),
+         (int) ((slave->offset + slave->mtd.size) >> 32),
+         (int) ((slave->offset + slave->mtd.size) & 0xffffffff),
+         slave->mtd.name);
 
 	/* let's do some sanity checks */
 	if (slave->offset >= master->size) {
diff -Nur u-boot-2009.08.orig/drivers/mtd/nand/gpmi_nfc_hal.c u-boot-2009.08/drivers/mtd/nand/gpmi_nfc_hal.c
--- u-boot-2009.08.orig/drivers/mtd/nand/gpmi_nfc_hal.c	2011-03-17 12:40:55.011122024 +0800
+++ u-boot-2009.08/drivers/mtd/nand/gpmi_nfc_hal.c	2011-05-20 12:39:35.227055312 +0800
@@ -40,9 +40,17 @@
 static struct mxs_dma_desc *dma_desc[NFC_DMA_DESCRIPTOR_COUNT];
 
 static struct gpmi_nfc_timing  safe_timing = {
+
+#if 0
 	.m_u8DataSetup		= 80,
 	.m_u8DataHold		= 60,
 	.m_u8AddressSetup		= 25,
+#else
+	.m_u8DataSetup		= 30,
+	.m_u8DataHold		= 25,
+	.m_u8AddressSetup		= 10,
+#endif
+
 	.m_u8HalfPeriods		= 0,
 	.m_u8SampleDelay		= 6,
 	.m_u8NandTimingState	= 0,
@@ -766,6 +774,15 @@
  */
 static void begin(struct mtd_info *mtd)
 {
+
+#if 1
+  static int init = 0;
+
+  if (!init)
+  {
+    init = 1;
+#endif
+
 	struct nand_chip *chip = mtd->priv;
 	struct gpmi_nfc_info *gpmi_info = chip->priv;
 	struct nfc_hal         *nfc =  gpmi_info->nfc;
@@ -843,6 +860,11 @@
 
 	/* Coming soon - the clock handling code isn't ready yet. */
 	MTDDEBUG(MTD_DEBUG_LEVEL3, "<= %s\n", __func__);
+
+#if 1
+  }
+#endif
+
 }
 
 /**
diff -Nur u-boot-2009.08.orig/drivers/mtd/nand/gpmi_nfc_mil.c u-boot-2009.08/drivers/mtd/nand/gpmi_nfc_mil.c
--- u-boot-2009.08.orig/drivers/mtd/nand/gpmi_nfc_mil.c	2011-03-17 12:40:55.013346953 +0800
+++ u-boot-2009.08/drivers/mtd/nand/gpmi_nfc_mil.c	2011-05-20 12:42:47.859973399 +0800
@@ -1023,6 +1023,7 @@
 	mtd->block_markbad              = gpmi_nfc_hook_block_markbad;
 
 	/* We use the reference implementation for bad block management. */
+  //BLL it goes here
 	error = nand_default_bbt(mtd);
 	if (error)
 		return error;
diff -Nur u-boot-2009.08.orig/drivers/mtd/nand/nand_bbt.c u-boot-2009.08/drivers/mtd/nand/nand_bbt.c
--- u-boot-2009.08.orig/drivers/mtd/nand/nand_bbt.c	2011-03-17 12:40:55.013346953 +0800
+++ u-boot-2009.08/drivers/mtd/nand/nand_bbt.c	2011-05-20 12:45:03.240951512 +0800
@@ -987,6 +987,7 @@
 	 * to build a memory based bad block table
 	 */
 	if (!td) {
+    //BLL it goes here
 		if ((res = nand_memory_bbt(mtd, bd))) {
 			printk(KERN_ERR "nand_bbt: Can't scan flash and build the RAM-based BBT\n");
 			kfree(this->bbt);
diff -Nur u-boot-2009.08.orig/drivers/net/mxc_fec.c u-boot-2009.08/drivers/net/mxc_fec.c
--- u-boot-2009.08.orig/drivers/net/mxc_fec.c	2011-03-17 12:40:55.027783904 +0800
+++ u-boot-2009.08/drivers/net/mxc_fec.c	2011-04-01 16:28:46.779016738 +0800
@@ -939,6 +939,7 @@
 			printf("got MAC address from IIM: %pM\n", ethaddr);
 			memcpy(dev->enetaddr, ethaddr, 6);
 			fec_set_hwaddr(dev);
+			eth_setenv_enetaddr("ethaddr", ethaddr);
 		}
 	}
 
diff -Nur u-boot-2009.08.orig/fs/ext2/ext2fs.c u-boot-2009.08/fs/ext2/ext2fs.c
--- u-boot-2009.08.orig/fs/ext2/ext2fs.c	2011-03-17 12:40:51.134601956 +0800
+++ u-boot-2009.08/fs/ext2/ext2fs.c	2011-04-01 12:16:59.938015773 +0800
@@ -178,6 +178,7 @@
 uint32_t *indir2_block = NULL;
 int indir2_size = 0;
 int indir2_blkno = -1;
+static unsigned int inode_size;
 
 
 static int ext2fs_blockgroup
@@ -212,7 +213,7 @@
 	unsigned int blkoff;
 
 #ifdef DEBUG
-	printf ("ext2fs read inode %d\n", ino);
+	printf ("ext2fs read inode %d, inode_size %d\n", ino, inode_size);
 #endif
 	/* It is easier to calculate if the first inode is 0.  */
 	ino--;
@@ -222,16 +223,12 @@
 		return (0);
 	}
 
-	inodes_per_block = EXT2_BLOCK_SIZE(data) / __le16_to_cpu(sblock->inode_size);
-
-#ifdef DEBUG
-	printf ("ext2fs read inode blkno %d blkoff %d\n", blkno, blkoff);
-#endif
+	inodes_per_block = EXT2_BLOCK_SIZE(data) / inode_size;
 
 	blkno = __le32_to_cpu (blkgrp.inode_table_id) +
 		(ino % __le32_to_cpu (sblock->inodes_per_group))
 		/ inodes_per_block;
-	blkoff = (ino % inodes_per_block) * __le16_to_cpu (sblock->inode_size);
+	blkoff = (ino % inodes_per_block) * inode_size;
 #ifdef DEBUG
 	printf ("ext2fs read inode blkno %d blkoff %d\n", blkno, blkoff);
 #endif
@@ -367,7 +364,7 @@
 			indir2_size = blksz;
 		}
 		if ((__le32_to_cpu (indir1_block[rblock / perblock]) <<
-		     log2_blksz) != indir1_blkno) {
+		     log2_blksz) != indir2_blkno) {
 			status = ext2fs_devread (__le32_to_cpu(indir1_block[rblock / perblock]) << log2_blksz,
 						 0, blksz,
 						 (char *) indir2_block);
@@ -417,6 +414,36 @@
 		if (blknr < 0) {
 			return (-1);
 		}
+
+                if ((i != (pos / blocksize)) &&
+                    (i != (blockcnt - 1)) &&
+                    blknr)
+                {
+                  #define MAX_CONT_BLK 1000
+
+                  int m, n, p, q;
+
+                  m = i;
+
+                  n = (blockcnt - 1) - m;
+
+                  if (n > MAX_CONT_BLK) n = MAX_CONT_BLK;
+
+                  for (p = 1; p < n; p++)
+                  {
+                    q = ext2fs_read_block(node, m + p);
+
+                    if (q < 0)
+                      return -1;
+
+                    if (q != (blknr + p))
+                      break;
+
+                    blockend += blocksize;
+                    i++;
+                  }
+                }
+
 		blknr = blknr << log2blocksize;
 
 		/* Last block.  */
@@ -447,7 +474,7 @@
 		} else {
 			memset (buf, 0, blocksize - skipfirst);
 		}
-		buf += blocksize - skipfirst;
+		buf += blockend;
 	}
 	return (len);
 }
@@ -752,7 +779,7 @@
 }
 
 
-int ext2fs_ls (char *dirname) {
+int ext2fs_ls (const char *dirname) {
 	ext2fs_node_t dirnode;
 	int status;
 
@@ -772,7 +799,7 @@
 }
 
 
-int ext2fs_open (char *filename) {
+int ext2fs_open (const char *filename) {
 	ext2fs_node_t fdiro = NULL;
 	int status;
 	int len;
@@ -863,6 +890,15 @@
 	if (__le16_to_cpu (data->sblock.magic) != EXT2_MAGIC) {
 		goto fail;
 	}
+	if (__le32_to_cpu(data->sblock.revision_level == 0)) {
+		inode_size = 128;
+	} else {
+		inode_size = __le16_to_cpu(data->sblock.inode_size);
+	}
+#ifdef DEBUG
+	printf("EXT2 rev %d, inode_size %d\n",
+			__le32_to_cpu(data->sblock.revision_level), inode_size);
+#endif
 	data->diropen.data = data;
 	data->diropen.ino = 2;
 	data->diropen.inode_read = 1;
diff -Nur u-boot-2009.08.orig/fs/ext2/Makefile u-boot-2009.08/fs/ext2/Makefile
--- u-boot-2009.08.orig/fs/ext2/Makefile	2011-03-17 12:40:51.134601956 +0800
+++ u-boot-2009.08/fs/ext2/Makefile	2011-03-25 11:06:32.775550439 +0800
@@ -35,7 +35,7 @@
 SRCS	:= $(AOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(AOBJS) $(COBJS-y))
 
-#CPPFLAGS +=
+CFLAGS += -O -fno-forward-propagate
 
 all:	$(LIB) $(AOBJS)
 
diff -Nur u-boot-2009.08.orig/include/configs/mx28_evk.h u-boot-2009.08/include/configs/mx28_evk.h
--- u-boot-2009.08.orig/include/configs/mx28_evk.h	2011-03-17 12:40:52.601265242 +0800
+++ u-boot-2009.08/include/configs/mx28_evk.h	2011-05-24 13:17:24.263306726 +0800
@@ -66,9 +66,9 @@
 #define CONFIG_CMDLINE_TAG
 #define CONFIG_SETUP_MEMORY_TAGS
 #define CONFIG_BOOTDELAY	3
-#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_BOOTFILE		uImage
 #define CONFIG_BOOTARGS		"console=ttyAM0,115200n8 "
-#define CONFIG_BOOTCOMMAND	"run bootcmd_net"
+#define CONFIG_BOOTCOMMAND	"run bootcmd_mmc"
 #define CONFIG_LOADADDR		0x42000000
 #define CONFIG_SYS_LOAD_ADDR	CONFIG_LOADADDR
 
@@ -76,15 +76,29 @@
  * Extra Environments
  */
 #define	CONFIG_EXTRA_ENV_SETTINGS \
-	"nfsroot=/home/notroot/nfs/rootfs\0" \
-	"bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs " \
-		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp " \
-		"fec_mac=${ethaddr}\0" \
-	"bootcmd_net=run bootargs_nfs; dhcp; bootm\0" \
-	"bootargs_mmc=setenv bootargs ${bootargs} root=/dev/mmcblk0p3 " \
-		"rw rootwait ip=dhcp fec_mac=${ethaddr}\0" \
-	"bootcmd_mmc=run bootargs_mmc; " \
-		"mmc read 0 ${loadaddr} 100 3000; bootm\0" \
+        "autoload=n\0" \
+        "bootargs_mmc=setenv bootargs " \
+                "${bootargs} " \
+                "root=/dev/mmcblk0p2 rw rootwait " \
+                "ip=dhcp fec_mac=${ethaddr} " \
+                "gpmi " \
+                "loglevel=10 printk.time=1\0" \
+        "bootcmd_mmc=run bootargs_mmc; " \
+                "ext2load mmc 0:2 ${loadaddr} /boot/${bootfile}; " \
+                "bootm\0" \
+        "mtdids=nand0=gpmi-nfc\0" \
+        "mtdparts=mtdparts=gpmi-nfc:0x1400000@0x0(gpmi-nfc-0-boot)ro,0xec00000@0x1400000(gpmi-nfc-general-use)ro\0" \
+        "bootargs_mtd=setenv bootargs " \
+                "${bootargs} " \
+                "ubi.mtd=1 root=ubi0:rootfs rw rootfstype=ubifs rootwait " \
+                "ip=dhcp fec_mac=${ethaddr} " \
+                "gpmi " \
+                "loglevel=10 printk.time=1\0" \
+        "bootcmd_mtd=run bootargs_mtd; " \
+                "ubi part gpmi-nfc-general-use; " \
+                "ubifsmount rootfs; " \
+                "ubifsload ${loadaddr} /boot/${bootfile}; " \
+                "bootm\0" \
 
 /*
  * U-Boot Commands
@@ -114,9 +128,6 @@
 #define CONFIG_CMD_MII
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_PING
-#define CONFIG_IPADDR			192.168.1.103
-#define CONFIG_SERVERIP			192.168.1.101
-#define CONFIG_NETMASK			255.255.255.0
 /* Add for working with "strict" DHCP server */
 #define CONFIG_BOOTP_SUBNETMASK
 #define CONFIG_BOOTP_GATEWAY
@@ -126,6 +137,7 @@
  * MMC Driver
  */
 #define CONFIG_CMD_MMC
+//#define ENABLE_NAND
 
 #ifdef CONFIG_CMD_MMC
 	#define CONFIG_MMC
@@ -134,13 +146,21 @@
 	#define CONFIG_DYNAMIC_MMC_DEVNO
 	#define CONFIG_DOS_PARTITION
 	#define CONFIG_CMD_FAT
+
+#ifdef ENABLE_NAND
+	#define CONFIG_SYS_SSP_MMC_NUM 1
+#else
 	#define CONFIG_SYS_SSP_MMC_NUM 2
 #endif
 
+	#define CONFIG_CMD_EXT2
+#endif
+
 /*
  * GPMI Nand Configs
  */
-#ifndef CONFIG_CMD_MMC	/* NAND conflict with MMC */
+#if !defined(CONFIG_CMD_MMC) || \
+    (defined(CONFIG_CMD_MMC) && (CONFIG_SYS_SSP_MMC_NUM == 1))
 
 #define CONFIG_CMD_NAND
 
@@ -155,6 +175,15 @@
 	#define NAND_MAX_CHIPS		8
 	#define CONFIG_SYS_NAND_BASE		0x40000000
 	#define CONFIG_SYS_MAX_NAND_DEVICE	1
+
+  #define CONFIG_MTD_DEVICE
+  #define CONFIG_MTD_PARTITIONS
+  #define CONFIG_CMD_MTDPARTS
+
+  #define CONFIG_LZO
+  #define CONFIG_RBTREE
+  #define CONFIG_CMD_UBI
+  #define CONFIG_CMD_UBIFS
 #endif
 
 /*
@@ -185,7 +214,7 @@
 #elif defined(CONFIG_FSL_ENV_IN_MMC)
 	#define CONFIG_ENV_IS_IN_MMC	1
 	/* Assoiated with the MMC layout defined in mmcops.c */
-	#define CONFIG_ENV_OFFSET               (0x400) /* 1 KB */
+	#define CONFIG_ENV_OFFSET               (0x800 + 512) /* 2 KB  + 512 (MBR + SBMAGIC) */
 	#define CONFIG_ENV_SIZE                 (0x20000 - 0x400) /* 127 KB */
 #else
 	#define CONFIG_ENV_IS_NOWHERE	1
diff -Nur u-boot-2009.08.orig/include/ext2fs.h u-boot-2009.08/include/ext2fs.h
--- u-boot-2009.08.orig/include/ext2fs.h	2011-03-17 12:40:54.327924976 +0800
+++ u-boot-2009.08/include/ext2fs.h	2011-03-25 11:09:00.618228062 +0800
@@ -74,8 +74,8 @@
 
 
 extern int ext2fs_set_blk_dev(block_dev_desc_t *rbdd, int part);
-extern int ext2fs_ls (char *dirname);
-extern int ext2fs_open (char *filename);
+extern int ext2fs_ls (const char *dirname);
+extern int ext2fs_open (const char *filename);
 extern int ext2fs_read (char *buf, unsigned len);
 extern int ext2fs_mount (unsigned part_length);
 extern int ext2fs_close(void);
diff -Nur u-boot-2009.08.orig/lib_arm/eabi_compat.c u-boot-2009.08/lib_arm/eabi_compat.c
--- u-boot-2009.08.orig/lib_arm/eabi_compat.c	2011-03-17 12:40:52.321259618 +0800
+++ u-boot-2009.08/lib_arm/eabi_compat.c	2011-03-23 13:11:19.357106914 +0800
@@ -16,3 +16,8 @@
 	printf("raise: Signal # %d caught\n", signum);
 	return 0;
 }
+
+void __aeabi_unwind_cpp_pr0(void)
+{
+};
+
