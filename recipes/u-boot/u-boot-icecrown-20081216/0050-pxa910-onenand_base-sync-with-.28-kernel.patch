From 6dd9f673be0eb74dd1a4cec58d5e84616d07ca6e Mon Sep 17 00:00:00 2001
From: Lei Wen <leiwen@marvell.com>
Date: Tue, 28 Apr 2009 14:20:48 +0800
Subject: [PATCH] pxa910: onenand_base sync with .28 kernel

Signed-off-by: Lei Wen <leiwen@marvell.com>
---
 board/pxa/common/bbt.c               |   10 +-
 board/pxa/common/nand.c              |    1 +
 drivers/mtd/onenand/onenand_base.c   | 2013 +++++++++++++++++++++++-----------
 include/asm-arm/arch-pxa168/common.h |    6 +-
 include/linux/mtd/mtd.h              |   17 +-
 include/linux/mtd/nand.h             |   14 +
 include/linux/mtd/onenand.h          |  199 ++--
 include/linux/mtd/onenand_regs.h     |   16 +-
 include/onenand_uboot.h              |    2 +-
 9 files changed, 1552 insertions(+), 726 deletions(-)

diff --git a/board/pxa/common/bbt.c b/board/pxa/common/bbt.c
index d54473b..3b231d9 100644
--- a/board/pxa/common/bbt.c
+++ b/board/pxa/common/bbt.c
@@ -1,16 +1,12 @@
 #include <command.h>
-#include <linux/mtd/onenand.h>
-#include <nand.h>
 #include <asm/arch-pxa168/common.h>
 #include <asm/arch-pxa168/pxa3xx_bbm.h>
-#undef	 __KERNEL__
-#include <asm/arch-pxa168/pxa3xx_nand.h>
+#include <linux/mtd/mtd.h>
 #include <malloc.h>
 
-#ifdef CONFIG_CMD_ONENAND
+extern int nand_curr_device;
+extern struct mtd_info *nand_info;
 extern struct mtd_info onenand_mtd;
-extern struct onenand_chip onenand_chip;
-#endif
 
 int do_bbt (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
diff --git a/board/pxa/common/nand.c b/board/pxa/common/nand.c
index 9dda7ec..2e11a83 100644
--- a/board/pxa/common/nand.c
+++ b/board/pxa/common/nand.c
@@ -2,6 +2,7 @@
 #include <linux/types.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
 #include <asm/arch/common.h>
 #include <asm/arch/regs-pxa168.h>
 #include <asm/errno.h>
diff --git a/drivers/mtd/onenand/onenand_base.c b/drivers/mtd/onenand/onenand_base.c
index acf9a53..678b05a 100644
--- a/drivers/mtd/onenand/onenand_base.c
+++ b/drivers/mtd/onenand/onenand_base.c
@@ -5,70 +5,57 @@
  *  Kyungmin Park <kyungmin.park@samsung.com>
  *
  *  Credits:
- *      Adrian Hunter <ext-adrian.hunter@nokia.com>:
- *      auto-placement support, read-while load support, various fixes
- *      Copyright (C) Nokia Corporation, 2007
+ *	Adrian Hunter <ext-adrian.hunter@nokia.com>:
+ *	auto-placement support, read-while load support, various fixes
+ *	Copyright (C) Nokia Corporation, 2007
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-
-#include <common.h>
-#include <linux/mtd/compat.h>
+#if 0
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#endif
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/onenand.h>
+#include <linux/mtd/partitions.h>
 
 #include <asm/io.h>
-#include <asm/errno.h>
-#include <malloc.h>
-#include <linux/mtd/pxa3xx_bbm.h>
-
-#if defined(CONFIG_PXA3xx_DVFM)
-#include <asm/arch/dvfm.h>
-#include <asm/arch/pxa3xx_dvfm.h>
-#endif
-
-static struct pxa3xx_bbm *pxa3xx_bbm;
-struct ecc_layout {
-	int     offset;
-	int     length;
-};
 
-/* It should access 16-bit instead of 8-bit */
-static inline void *memcpy_16(void *dst, const void *src, unsigned int len)
-{
-	void *ret = dst;
-	short *d = dst;
-	const short *s = src;
-
-	len >>= 1;
-	while (len-- > 0)
-		*d++ = *s++;
-	return ret;
-}
-
-static inline void *memcpy_16aligned(void *dest, const void *src, int n)
-{
-	const u8 * pS = (const u8*)src;
-	u8 s_low;
-	short s_high = 0xffff;
-	short *d = dest;
-
-	while(n > 0) {
-		s_low = *pS;
-		if (n >= 2)
-			s_high = *(pS + 1);
-		else
-			s_high = 0xffff;
-
-		*d++ = ((s_high << 8) | s_low);
-		n -= 2;
-		pS += 2;
+/**
+ * onenand_oob_64 - oob info for large (2KB) page
+ */
+static struct nand_ecclayout onenand_oob_64 = {
+	.eccbytes	= 20,
+	.eccpos		= {
+		8, 9, 10, 11, 12,
+		24, 25, 26, 27, 28,
+		40, 41, 42, 43, 44,
+		56, 57, 58, 59, 60,
+		},
+	.oobfree	= {
+		{2, 3}, {14, 2}, {18, 3}, {30, 2},
+		{34, 3}, {46, 2}, {50, 3}, {62, 2}
 	}
+};
 
-	return dest;
-}
+/**
+ * onenand_oob_32 - oob info for middle (1KB) page
+ */
+static struct nand_ecclayout onenand_oob_32 = {
+	.eccbytes	= 10,
+	.eccpos		= {
+		8, 9, 10, 11, 12,
+		24, 25, 26, 27, 28,
+		},
+	.oobfree	= { {2, 3}, {14, 2}, {18, 3}, {30, 2} }
+};
 
 static const unsigned char ffchars[] = {
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
@@ -81,108 +68,13 @@ static const unsigned char ffchars[] = {
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	/* 64 */
 };
 
-/* check whether a page and spare area is empty
- * size should be sum of page size and spare area length
- */
-static inline int is_buf_blank(const unsigned char * buf, int size)
-{
-	int i = 0;
-	while (i < size) {
-		if (*((unsigned long *)(buf + i)) != 0xFFFFFFFF)
-			return 0;
-		i += 4;
-	}
-	if (i > size) {
-		i -= 4;
-		while (i < size) {
-			if (*(buf + i) != 0xFF)
-				return 0;
-			i++;
-		}
-	}
-	return 1;
-}
-
-static struct ecc_layout onenand_ecc_layout[] = {
-	{2, 3},
-	{14, 2},
-	{18, 3},
-	{30, 2},
-	{34, 3},
-	{46, 2},
-	{50, 3},
-	{62, 2},
-};
-
-/* Convert generic oob buf to Onenand oob buf layout.
- * This function should be called before Onenand write operation.
- */
-static int convert_oob_before_write(unsigned char *oobbuf, const unsigned char *buf, int len)
-{
-	int i, count = 0;
-	unsigned char *tmp = (unsigned char *)buf;
-
-	for (i = 0; i < ARRAY_SIZE(onenand_ecc_layout); i++) {
-		if (count > len)
-			break;
-
-		memcpy_16aligned(oobbuf + onenand_ecc_layout[i].offset,
-				tmp, onenand_ecc_layout[i].length);
-		tmp += onenand_ecc_layout[i].length;
-		count += onenand_ecc_layout[i].length;
-	}
-
-	return count;
-}
-
-#if defined(CONFIG_PXA3xx_DVFM)
-static struct dvfm_lock dvfm_lock = {
-	.lock           = SPIN_LOCK_UNLOCKED,
-	.dev_idx        = -1,
-	.count          = 0,
-};
-
-static void set_dvfm_constraint(void)
-{
-	spin_lock_irqsave(&dvfm_lock.lock, dvfm_lock.flags);
-	if (dvfm_lock.count++ == 0) {
-		/* Disable Low power mode */
-		dvfm_disable_op_name("D1", dvfm_lock.dev_idx);
-		dvfm_disable_op_name("D2", dvfm_lock.dev_idx);
-		if (cpu_is_pxa935())
-			dvfm_disable_op_name("CG", dvfm_lock.dev_idx);
-	}
-	spin_unlock_irqrestore(&dvfm_lock.lock, dvfm_lock.flags);
-}
-
-static void unset_dvfm_constraint(void)
-{
-	spin_lock_irqsave(&dvfm_lock.lock, dvfm_lock.flags);
-	if (dvfm_lock.count == 0) {
-		spin_unlock_irqrestore(&dvfm_lock.lock, dvfm_lock.flags);
-		return;
-	}
-	if (--dvfm_lock.count == 0) {
-		/* Enable Low power mode */
-		dvfm_enable_op_name("D1", dvfm_lock.dev_idx);
-		dvfm_enable_op_name("D2", dvfm_lock.dev_idx);
-		if (cpu_is_pxa935())
-			dvfm_enable_op_name("CG", dvfm_lock.dev_idx);
-	}
-	spin_unlock_irqrestore(&dvfm_lock.lock, dvfm_lock.flags);
-}
-#else
-static void set_dvfm_constraint() {}
-static void unset_dvfm_constraint() {}
-#endif
-
 /**
  * onenand_readw - [OneNAND Interface] Read OneNAND register
  * @param addr		address to read
  *
  * Read OneNAND register
  */
-static unsigned short onenand_readw(void __iomem * addr)
+static unsigned short onenand_readw(void __iomem *addr)
 {
 	return readw(addr);
 }
@@ -194,61 +86,43 @@ static unsigned short onenand_readw(void __iomem * addr)
  *
  * Write OneNAND register with value
  */
-static void onenand_writew(unsigned short value, void __iomem * addr)
+static void onenand_writew(unsigned short value, void __iomem *addr)
 {
 	writew(value, addr);
 }
 
 /**
  * onenand_block_address - [DEFAULT] Get block address
- * @param device	the device id
+ * @param this		onenand chip data structure
  * @param block		the block
  * @return		translated block address if DDP, otherwise same
  *
  * Setup Start Address 1 Register (F100h)
  */
-static int onenand_block_address(int device, int block)
+static int onenand_block_address(struct onenand_chip *this, int block)
 {
-	if (device & ONENAND_DEVICE_IS_DDP) {
-		/* Device Flash Core select, NAND Flash Block Address */
-		int dfs = 0, density, mask;
-
-		density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
-		mask = (1 << (density + 6));
-
-		if (block & mask)
-			dfs = 1;
-
-		return (dfs << ONENAND_DDP_SHIFT) | (block & (mask - 1));
-	}
+	/* Device Flash Core select, NAND Flash Block Address */
+	if (block & this->density_mask)
+		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
 
 	return block;
 }
 
 /**
  * onenand_bufferram_address - [DEFAULT] Get bufferram address
- * @param device	the device id
+ * @param this		onenand chip data structure
  * @param block		the block
  * @return		set DBS value if DDP, otherwise 0
  *
  * Setup Start Address 2 Register (F101h) for DDP
  */
-static int onenand_bufferram_address(int device, int block)
+static int onenand_bufferram_address(struct onenand_chip *this, int block)
 {
-	if (device & ONENAND_DEVICE_IS_DDP) {
-		/* Device BufferRAM Select */
-		int dbs = 0, density, mask;
-
-		density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
-		mask = (1 << (density + 6));
-
-		if (block & mask)
-			dbs = 1;
-
-		return (dbs << ONENAND_DDP_SHIFT);
-	}
+	/* Device BufferRAM Select */
+	if (block & this->density_mask)
+		return ONENAND_DDP_CHIP1;
 
-	return 0;
+	return ONENAND_DDP_CHIP0;
 }
 
 /**
@@ -298,6 +172,18 @@ static int onenand_buffer_address(int dataram1, int sectors, int count)
 }
 
 /**
+ * onenand_get_density - [DEFAULT] Get OneNAND density
+ * @param dev_id	OneNAND device ID
+ *
+ * Get OneNAND density from device ID
+ */
+static inline int onenand_get_density(int dev_id)
+{
+	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
+	return (density & ONENAND_DEVICE_DENSITY_MASK);
+}
+
+/**
  * onenand_command - [DEFAULT] Send command to OneNAND device
  * @param mtd		MTD device structure
  * @param cmd		the command to be sent
@@ -307,40 +193,40 @@ static int onenand_buffer_address(int dataram1, int sectors, int count)
  * Send command to OneNAND device. This function is used for middle/large page
  * devices (1KB/2KB Bytes per page)
  */
-static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
-			   size_t len)
+static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr, size_t len)
 {
 	struct onenand_chip *this = mtd->priv;
-	int value, readcmd = 0;
-	int block, page, reloc_block;
-	/* Now we use page size operation */
-	int sectors = 4, count = 4;
-
-	if (pxa3xx_bbm && pxa3xx_bbm->table_init && pxa3xx_bbm->search) {
-		block = (int)(addr >> pxa3xx_bbm->erase_shift);
-		reloc_block = pxa3xx_bbm->search(mtd, pxa3xx_bbm, block);
-		addr = ((reloc_block << this->erase_shift) |
-				(addr & ((1 << this->erase_shift) - 1)));
-	}
+	int value, block, page;
 
 	/* Address translation */
 	switch (cmd) {
 	case ONENAND_CMD_UNLOCK:
 	case ONENAND_CMD_LOCK:
 	case ONENAND_CMD_LOCK_TIGHT:
+	case ONENAND_CMD_UNLOCK_ALL:
 		block = -1;
 		page = -1;
 		break;
 
 	case ONENAND_CMD_ERASE:
 	case ONENAND_CMD_BUFFERRAM:
-		block = (int)(addr >> this->erase_shift);
+	case ONENAND_CMD_OTP_ACCESS:
+		block = (int) (addr >> this->erase_shift);
 		page = -1;
 		break;
 
 	default:
-		block = (int)(addr >> this->erase_shift);
-		page = (int)(addr >> this->page_shift);
+		block = (int) (addr >> this->erase_shift);
+		page = (int) (addr >> this->page_shift);
+
+		if (ONENAND_IS_2PLANE(this)) {
+			/* Make the even block number */
+			block &= ~1;
+			/* Is it the odd plane? */
+			if (addr & this->writesize)
+				block++;
+			page >>= 1;
+		}
 		page &= this->page_mask;
 		break;
 	}
@@ -348,59 +234,59 @@ static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
 	/* NOTE: The setting order of the registers is very important! */
 	if (cmd == ONENAND_CMD_BUFFERRAM) {
 		/* Select DataRAM for DDP */
-		value = onenand_bufferram_address(this->device_id, block);
-		this->write_word(value,
-				 this->base + ONENAND_REG_START_ADDRESS2);
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
 
-		/* Switch to the next data buffer */
-		ONENAND_SET_NEXT_BUFFERRAM(this);
+		if (ONENAND_IS_2PLANE(this))
+			/* It is always BufferRAM0 */
+			ONENAND_SET_BUFFERRAM0(this);
+		else
+			/* Switch to the next data buffer */
+			ONENAND_SET_NEXT_BUFFERRAM(this);
 
 		return 0;
 	}
 
 	if (block != -1) {
 		/* Write 'DFS, FBA' of Flash */
-		value = onenand_block_address(this->device_id, block);
-		this->write_word(value,
-				 this->base + ONENAND_REG_START_ADDRESS1);
+		value = onenand_block_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
+
+		/* Select DataRAM for DDP */
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
 	}
 
 	if (page != -1) {
+		/* Now we use page size operation */
+		int sectors = 4, count = 4;
 		int dataram;
 
 		switch (cmd) {
 		case ONENAND_CMD_READ:
 		case ONENAND_CMD_READOOB:
 			dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
-			readcmd = 1;
 			break;
 
 		default:
+			if (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)
+				cmd = ONENAND_CMD_2X_PROG;
 			dataram = ONENAND_CURRENT_BUFFERRAM(this);
 			break;
 		}
 
 		/* Write 'FPA, FSA' of Flash */
 		value = onenand_page_address(page, sectors);
-		this->write_word(value,
-				 this->base + ONENAND_REG_START_ADDRESS8);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS8);
 
 		/* Write 'BSA, BSC' of DataRAM */
 		value = onenand_buffer_address(dataram, sectors, count);
 		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
-
-		if (readcmd) {
-			/* Select DataRAM for DDP */
-			value =
-			    onenand_bufferram_address(this->device_id, block);
-			this->write_word(value,
-					 this->base +
-					 ONENAND_REG_START_ADDRESS2);
-		}
 	}
 
 	/* Interrupt clear */
 	this->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);
+
 	/* Write command */
 	this->write_word(cmd, this->base + ONENAND_REG_COMMAND);
 
@@ -418,41 +304,159 @@ static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
  */
 static int onenand_wait(struct mtd_info *mtd, int state)
 {
-	struct onenand_chip *this = mtd->priv;
+	struct onenand_chip * this = mtd->priv;
+	unsigned long timeout;
 	unsigned int flags = ONENAND_INT_MASTER;
 	unsigned int interrupt = 0;
-	unsigned int ctrl, ecc;
+	unsigned int ctrl;
 
-	while (1) {
+	/* The 20 msec is enough */
+	timeout = jiffies + msecs_to_jiffies(20);
+	while (time_before(jiffies, timeout)) {
 		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
+
 		if (interrupt & flags)
 			break;
+
+		if (state != FL_READING)
+			cond_resched();
 	}
+	/* To get correct interrupt status in timeout case */
+	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
 
 	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
 
-	if (ctrl & ONENAND_CTRL_ERROR) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			  "onenand_wait: controller error = 0x%04x\n", ctrl);
-		return -EAGAIN;
+	/*
+	 * In the Spec. it checks the controller status first
+	 * However if you get the correct information in case of
+	 * power off recovery (POR) test, it should read ECC status first
+	 */
+	if (interrupt & ONENAND_INT_READ) {
+		int ecc = this->read_word(this->base + ONENAND_REG_ECC_STATUS);
+		if (ecc) {
+			if (ecc & ONENAND_ECC_2BIT_ALL) {
+				printk(KERN_ERR "onenand_wait: ECC error = 0x%04x\n", ecc);
+				mtd->ecc_stats.failed++;
+				return -EBADMSG;
+			} else if (ecc & ONENAND_ECC_1BIT_ALL) {
+				printk(KERN_INFO "onenand_wait: correctable ECC error = 0x%04x\n", ecc);
+				mtd->ecc_stats.corrected++;
+			}
+		}
+	} else if (state == FL_READING) {
+		printk(KERN_ERR "onenand_wait: read timeout! ctrl=0x%04x intr=0x%04x\n", ctrl, interrupt);
+		return -EIO;
 	}
 
-	if (ctrl & ONENAND_CTRL_LOCK) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			  "onenand_wait: it's locked error = 0x%04x\n", ctrl);
+	/* If there's controller error, it's a real error */
+	if (ctrl & ONENAND_CTRL_ERROR) {
+		printk(KERN_ERR "onenand_wait: controller error = 0x%04x\n",
+			ctrl);
+		if (ctrl & ONENAND_CTRL_LOCK)
+			printk(KERN_ERR "onenand_wait: it's locked error.\n");
 		return -EIO;
 	}
 
-	if (interrupt & ONENAND_INT_READ) {
-		ecc = this->read_word(this->base + ONENAND_REG_ECC_STATUS);
-		if (ecc & ONENAND_ECC_2BIT_ALL) {
-			MTDDEBUG (MTD_DEBUG_LEVEL0,
-				  "onenand_wait: ECC error = 0x%04x\n", ecc);
-			return -EBADMSG;
-		}
+	return 0;
+}
+
+/*
+ * onenand_interrupt - [DEFAULT] onenand interrupt handler
+ * @param irq		onenand interrupt number
+ * @param dev_id	interrupt data
+ *
+ * complete the work
+ */
+static irqreturn_t onenand_interrupt(int irq, void *data)
+{
+	struct onenand_chip *this = data;
+
+	/* To handle shared interrupt */
+	if (!this->complete.done)
+		complete(&this->complete);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * onenand_interrupt_wait - [DEFAULT] wait until the command is done
+ * @param mtd		MTD device structure
+ * @param state		state to select the max. timeout value
+ *
+ * Wait for command done.
+ */
+static int onenand_interrupt_wait(struct mtd_info *mtd, int state)
+{
+	struct onenand_chip *this = mtd->priv;
+
+	wait_for_completion(&this->complete);
+
+	return onenand_wait(mtd, state);
+}
+
+/*
+ * onenand_try_interrupt_wait - [DEFAULT] try interrupt wait
+ * @param mtd		MTD device structure
+ * @param state		state to select the max. timeout value
+ *
+ * Try interrupt based wait (It is used one-time)
+ */
+static int onenand_try_interrupt_wait(struct mtd_info *mtd, int state)
+{
+	struct onenand_chip *this = mtd->priv;
+	unsigned long remain, timeout;
+
+	/* We use interrupt wait first */
+	this->wait = onenand_interrupt_wait;
+
+	timeout = msecs_to_jiffies(100);
+	remain = wait_for_completion_timeout(&this->complete, timeout);
+	if (!remain) {
+		printk(KERN_INFO "OneNAND: There's no interrupt. "
+				"We use the normal wait\n");
+
+		/* Release the irq */
+		free_irq(this->irq, this);
+
+		this->wait = onenand_wait;
 	}
 
-	return 0;
+	return onenand_wait(mtd, state);
+}
+
+/*
+ * onenand_setup_wait - [OneNAND Interface] setup onenand wait method
+ * @param mtd		MTD device structure
+ *
+ * There's two method to wait onenand work
+ * 1. polling - read interrupt status register
+ * 2. interrupt - use the kernel interrupt method
+ */
+static void onenand_setup_wait(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	int syscfg;
+
+	init_completion(&this->complete);
+
+	if (this->irq <= 0) {
+		this->wait = onenand_wait;
+		return;
+	}
+
+	if (request_irq(this->irq, &onenand_interrupt,
+				IRQF_SHARED, "onenand", this)) {
+		/* If we can't get irq, use the normal wait */
+		this->wait = onenand_wait;
+		return;
+	}
+
+	/* Enable interrupt */
+	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
+	syscfg |= ONENAND_SYS_CFG1_IOBE;
+	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
+
+	this->wait = onenand_try_interrupt_wait;
 }
 
 /**
@@ -468,8 +472,9 @@ static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
 	struct onenand_chip *this = mtd->priv;
 
 	if (ONENAND_CURRENT_BUFFERRAM(this)) {
+		/* Note: the 'this->writesize' is a real page size */
 		if (area == ONENAND_DATARAM)
-			return mtd->writesize;
+			return this->writesize;
 		if (area == ONENAND_SPARERAM)
 			return mtd->oobsize;
 	}
@@ -488,16 +493,27 @@ static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
  * Read the BufferRAM area
  */
 static int onenand_read_bufferram(struct mtd_info *mtd, int area,
-				  unsigned char *buffer, int offset,
-				  size_t count)
+		unsigned char *buffer, int offset, size_t count)
 {
 	struct onenand_chip *this = mtd->priv;
 	void __iomem *bufferram;
 
 	bufferram = this->base + area;
+
 	bufferram += onenand_bufferram_offset(mtd, area);
 
-	memcpy_16(buffer, bufferram + offset, count);
+	if (ONENAND_CHECK_BYTE_ACCESS(count)) {
+		unsigned short word;
+
+		/* Align with word(16-bit) size */
+		count--;
+
+		/* Read word and save byte */
+		word = this->read_word(bufferram + offset + count);
+		buffer[count] = (word & 0xff);
+	}
+
+	memcpy(buffer, bufferram + offset, count);
 
 	return 0;
 }
@@ -513,18 +529,29 @@ static int onenand_read_bufferram(struct mtd_info *mtd, int area,
  * Read the BufferRAM area with Sync. Burst Mode
  */
 static int onenand_sync_read_bufferram(struct mtd_info *mtd, int area,
-				       unsigned char *buffer, int offset,
-				       size_t count)
+		unsigned char *buffer, int offset, size_t count)
 {
 	struct onenand_chip *this = mtd->priv;
 	void __iomem *bufferram;
 
 	bufferram = this->base + area;
+
 	bufferram += onenand_bufferram_offset(mtd, area);
 
 	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
 
-	memcpy_16(buffer, bufferram + offset, count);
+	if (ONENAND_CHECK_BYTE_ACCESS(count)) {
+		unsigned short word;
+
+		/* Align with word(16-bit) size */
+		count--;
+
+		/* Read word and save byte */
+		word = this->read_word(bufferram + offset + count);
+		buffer[count] = (word & 0xff);
+	}
+
+	memcpy(buffer, bufferram + offset, count);
 
 	this->mmcontrol(mtd, 0);
 
@@ -542,24 +569,61 @@ static int onenand_sync_read_bufferram(struct mtd_info *mtd, int area,
  * Write the BufferRAM area
  */
 static int onenand_write_bufferram(struct mtd_info *mtd, int area,
-				   const unsigned char *buffer, int offset,
-				   size_t count)
+		const unsigned char *buffer, int offset, size_t count)
 {
 	struct onenand_chip *this = mtd->priv;
 	void __iomem *bufferram;
 
 	bufferram = this->base + area;
+
 	bufferram += onenand_bufferram_offset(mtd, area);
 
-	if (area == ONENAND_SPARERAM && !is_buf_blank(buffer, 64))
-		convert_oob_before_write(bufferram, buffer, count);
-	else
-		memcpy_16(bufferram + offset, buffer, count);
+	if (ONENAND_CHECK_BYTE_ACCESS(count)) {
+		unsigned short word;
+		int byte_offset;
+
+		/* Align with word(16-bit) size */
+		count--;
+
+		/* Calculate byte access offset */
+		byte_offset = offset + count;
+
+		/* Read word and save byte */
+		word = this->read_word(bufferram + byte_offset);
+		word = (word & ~0xff) | buffer[count];
+		this->write_word(word, bufferram + byte_offset);
+	}
+
+	memcpy(bufferram + offset, buffer, count);
 
 	return 0;
 }
 
 /**
+ * onenand_get_2x_blockpage - [GENERIC] Get blockpage at 2x program mode
+ * @param mtd		MTD data structure
+ * @param addr		address to check
+ * @return		blockpage address
+ *
+ * Get blockpage address at 2x program mode
+ */
+static int onenand_get_2x_blockpage(struct mtd_info *mtd, loff_t addr)
+{
+	struct onenand_chip *this = mtd->priv;
+	int blockpage, block, page;
+
+	/* Calculate the even block number */
+	block = (int) (addr >> this->erase_shift) & ~1;
+	/* Is it the odd plane? */
+	if (addr & this->writesize)
+		block++;
+	page = (int) (addr >> (this->page_shift + 1)) & this->page_mask;
+	blockpage = (block << 7) | page;
+
+	return blockpage;
+}
+
+/**
  * onenand_check_bufferram - [GENERIC] Check BufferRAM information
  * @param mtd		MTD data structure
  * @param addr		address to check
@@ -570,21 +634,35 @@ static int onenand_write_bufferram(struct mtd_info *mtd, int area,
 static int onenand_check_bufferram(struct mtd_info *mtd, loff_t addr)
 {
 	struct onenand_chip *this = mtd->priv;
-	int block, page;
-	int i;
+	int blockpage, found = 0;
+	unsigned int i;
 
-	block = (int)(addr >> this->erase_shift);
-	page = (int)(addr >> this->page_shift);
-	page &= this->page_mask;
+	if (ONENAND_IS_2PLANE(this))
+		blockpage = onenand_get_2x_blockpage(mtd, addr);
+	else
+		blockpage = (int) (addr >> this->page_shift);
 
+	/* Is there valid data? */
 	i = ONENAND_CURRENT_BUFFERRAM(this);
+	if (this->bufferram[i].blockpage == blockpage)
+		found = 1;
+	else {
+		/* Check another BufferRAM */
+		i = ONENAND_NEXT_BUFFERRAM(this);
+		if (this->bufferram[i].blockpage == blockpage) {
+			ONENAND_SET_NEXT_BUFFERRAM(this);
+			found = 1;
+		}
+	}
 
-	/* Is there valid data? */
-	if (this->bufferram[i].block == block &&
-	    this->bufferram[i].page == page && this->bufferram[i].valid)
-		return 1;
+	if (found && ONENAND_IS_DDP(this)) {
+		/* Select DataRAM for DDP */
+		int block = (int) (addr >> this->erase_shift);
+		int value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
+	}
 
-	return 0;
+	return found;
 }
 
 /**
@@ -595,43 +673,41 @@ static int onenand_check_bufferram(struct mtd_info *mtd, loff_t addr)
  *
  * Update BufferRAM information
  */
-static int onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,
-				    int valid)
+static void onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,
+		int valid)
 {
 	struct onenand_chip *this = mtd->priv;
-	int block, page;
-	int i;
+	int blockpage;
+	unsigned int i;
 
-	block = (int)(addr >> this->erase_shift);
-	page = (int)(addr >> this->page_shift);
-	page &= this->page_mask;
+	if (ONENAND_IS_2PLANE(this))
+		blockpage = onenand_get_2x_blockpage(mtd, addr);
+	else
+		blockpage = (int) (addr >> this->page_shift);
 
-	/* Invalidate BufferRAM */
-	for (i = 0; i < MAX_BUFFERRAM; i++) {
-		if (this->bufferram[i].block == block &&
-		    this->bufferram[i].page == page)
-			this->bufferram[i].valid = 0;
-	}
+	/* Invalidate another BufferRAM */
+	i = ONENAND_NEXT_BUFFERRAM(this);
+	if (this->bufferram[i].blockpage == blockpage)
+		this->bufferram[i].blockpage = -1;
 
 	/* Update BufferRAM */
 	i = ONENAND_CURRENT_BUFFERRAM(this);
-	this->bufferram[i].block = block;
-	this->bufferram[i].page = page;
-	this->bufferram[i].valid = valid;
-
-	return 0;
+	if (valid)
+		this->bufferram[i].blockpage = blockpage;
+	else
+		this->bufferram[i].blockpage = -1;
 }
 
 /**
  * onenand_invalidate_bufferram - [GENERIC] Invalidate BufferRAM information
- * @param mtd           MTD data structure
- * @param addr          start address to invalidate
- * @param len           length to invalidate
+ * @param mtd		MTD data structure
+ * @param addr		start address to invalidate
+ * @param len		length to invalidate
  *
  * Invalidate BufferRAM information
  */
 static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
-					 unsigned int len)
+		unsigned int len)
 {
 	struct onenand_chip *this = mtd->priv;
 	int i;
@@ -639,10 +715,9 @@ static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
 
 	/* Invalidate BufferRAM */
 	for (i = 0; i < MAX_BUFFERRAM; i++) {
-		loff_t buf_addr = this->bufferram[i].block << this->erase_shift;
-
+		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
 		if (buf_addr >= addr && buf_addr < end_addr)
-			this->bufferram[i].valid = 0;
+			this->bufferram[i].blockpage = -1;
 	}
 }
 
@@ -653,9 +728,33 @@ static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
  *
  * Get the device and lock it for exclusive access
  */
-static void onenand_get_device(struct mtd_info *mtd, int new_state)
+static int onenand_get_device(struct mtd_info *mtd, int new_state)
 {
-	/* Do nothing */
+	struct onenand_chip *this = mtd->priv;
+	DECLARE_WAITQUEUE(wait, current);
+
+	/*
+	 * Grab the lock and see if the device is available
+	 */
+	while (1) {
+		spin_lock(&this->chip_lock);
+		if (this->state == FL_READY) {
+			this->state = new_state;
+			spin_unlock(&this->chip_lock);
+			break;
+		}
+		if (new_state == FL_PM_SUSPENDED) {
+			spin_unlock(&this->chip_lock);
+			return (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&this->wq, &wait);
+		spin_unlock(&this->chip_lock);
+		schedule();
+		remove_wait_queue(&this->wq, &wait);
+	}
+
+	return 0;
 }
 
 /**
@@ -666,7 +765,13 @@ static void onenand_get_device(struct mtd_info *mtd, int new_state)
  */
 static void onenand_release_device(struct mtd_info *mtd)
 {
-	/* Do nothing */
+	struct onenand_chip *this = mtd->priv;
+
+	/* Release the chip */
+	spin_lock(&this->chip_lock);
+	this->state = FL_READY;
+	wake_up(&this->wq);
+	spin_unlock(&this->chip_lock);
 }
 
 /**
@@ -676,8 +781,8 @@ static void onenand_release_device(struct mtd_info *mtd)
  * @param column	oob offset to read from
  * @param thislen	oob length to read
  */
-static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
-					int column, int thislen)
+static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf, int column,
+				int thislen)
 {
 	struct onenand_chip *this = mtd->priv;
 	struct nand_oobfree *free;
@@ -715,12 +820,12 @@ static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
  * onenand_read_ops_nolock - [OneNAND Interface] OneNAND read main and/or out-of-band
  * @param mtd		MTD device structure
  * @param from		offset to read from
- * @param ops		oob operation description structure
+ * @param ops:		oob operation description structure
  *
  * OneNAND read main and/or out-of-band data
  */
 static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
-		struct mtd_oob_ops *ops)
+				struct mtd_oob_ops *ops)
 {
 	struct onenand_chip *this = mtd->priv;
 	struct mtd_ecc_stats stats;
@@ -733,9 +838,7 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 	int ret = 0, boundary = 0;
 	int writesize = this->writesize;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_read_ops_nolock: from = 0x%08x, len = %i\n",
-		(unsigned int) from, (int) len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	if (ops->mode == MTD_OOB_AUTO)
 		oobsize = this->ecclayout->oobavail;
@@ -754,45 +857,44 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 
 	stats = mtd->ecc_stats;
 
-	/* Read-while-load method */
+ 	/* Read-while-load method */
 
-	/* Do first load to bufferRAM */
-	if (read < len) {
-		if (!onenand_check_bufferram(mtd, from)) {
+ 	/* Do first load to bufferRAM */
+ 	if (read < len) {
+ 		if (!onenand_check_bufferram(mtd, from)) {
 			this->command(mtd, ONENAND_CMD_READ, from, writesize);
-			ret = this->wait(mtd, FL_READING);
-			onenand_update_bufferram(mtd, from, !ret);
+ 			ret = this->wait(mtd, FL_READING);
+ 			onenand_update_bufferram(mtd, from, !ret);
 			if (ret == -EBADMSG)
 				ret = 0;
-		}
-	}
+ 		}
+ 	}
 
 	thislen = min_t(int, writesize, len - read);
 	column = from & (writesize - 1);
 	if (column + thislen > writesize)
 		thislen = writesize - column;
 
-	while (!ret) {
-		/* If there is more to load then start next load */
-		from += thislen;
-		if (read + thislen < len) {
+ 	while (!ret) {
+ 		/* If there is more to load then start next load */
+ 		from += thislen;
+ 		if (read + thislen < len) {
 			this->command(mtd, ONENAND_CMD_READ, from, writesize);
-			/*
-			 * Chip boundary handling in DDP
-			 * Now we issued chip 1 read and pointed chip 1
-			 * bufferam so we have to point chip 0 bufferam.
-			 */
-			if (ONENAND_IS_DDP(this) &&
-					unlikely(from == (this->chipsize >> 1))) {
-				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
-				boundary = 1;
-			} else
-				boundary = 0;
-			ONENAND_SET_PREV_BUFFERRAM(this);
-		}
-
-		/* While load is going, read from last bufferRAM */
-		this->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);
+ 			/*
+ 			 * Chip boundary handling in DDP
+ 			 * Now we issued chip 1 read and pointed chip 1
+ 			 * bufferam so we have to point chip 0 bufferam.
+ 			 */
+ 			if (ONENAND_IS_DDP(this) &&
+ 			    unlikely(from == (this->chipsize >> 1))) {
+ 				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
+ 				boundary = 1;
+ 			} else
+ 				boundary = 0;
+ 			ONENAND_SET_PREV_BUFFERRAM(this);
+ 		}
+ 		/* While load is going, read from last bufferRAM */
+ 		this->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);
 
 		/* Read oob area if needed */
 		if (oobbuf) {
@@ -808,24 +910,24 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 			oobcolumn = 0;
 		}
 
-		/* See if we are done */
-		read += thislen;
-		if (read == len)
-			break;
-		/* Set up for next read from bufferRAM */
-		if (unlikely(boundary))
-			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
-		ONENAND_SET_NEXT_BUFFERRAM(this);
-		buf += thislen;
+ 		/* See if we are done */
+ 		read += thislen;
+ 		if (read == len)
+ 			break;
+ 		/* Set up for next read from bufferRAM */
+ 		if (unlikely(boundary))
+ 			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
+ 		ONENAND_SET_NEXT_BUFFERRAM(this);
+ 		buf += thislen;
 		thislen = min_t(int, writesize, len - read);
-		column = 0;
-
-		/* Now wait for load */
-		ret = this->wait(mtd, FL_READING);
-		onenand_update_bufferram(mtd, from, !ret);
+ 		column = 0;
+ 		cond_resched();
+ 		/* Now wait for load */
+ 		ret = this->wait(mtd, FL_READING);
+ 		onenand_update_bufferram(mtd, from, !ret);
 		if (ret == -EBADMSG)
 			ret = 0;
-	}
+ 	}
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -848,12 +950,12 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
  * onenand_read_oob_nolock - [MTD Interface] OneNAND read out-of-band
  * @param mtd		MTD device structure
  * @param from		offset to read from
- * @param ops		oob operation description structure
+ * @param ops:		oob operation description structure
  *
  * OneNAND read out-of-band data from the spare area
  */
 static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
-		struct mtd_oob_ops *ops)
+			struct mtd_oob_ops *ops)
 {
 	struct onenand_chip *this = mtd->priv;
 	struct mtd_ecc_stats stats;
@@ -865,9 +967,7 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 
 	from += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_read_oob_nolock: from = 0x%08x, len = %i\n",
-		(unsigned int) from, (int) len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	/* Initialize return length value */
 	ops->oobretlen = 0;
@@ -886,8 +986,8 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 
 	/* Do not allow reads past end of device */
 	if (unlikely(from >= mtd->size ||
-		column + len > ((mtd->size >> this->page_shift) -
-				(from >> this->page_shift)) * oobsize)) {
+		     column + len > ((mtd->size >> this->page_shift) -
+				     (from >> this->page_shift)) * oobsize)) {
 		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
 		return -EINVAL;
 	}
@@ -895,6 +995,8 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 	stats = mtd->ecc_stats;
 
 	while (read < len) {
+		cond_resched();
+
 		thislen = oobsize - column;
 		thislen = min_t(int, thislen, len);
 
@@ -940,23 +1042,23 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 }
 
 /**
- * onenand_read - [MTD Interface] MTD compability function for onenand_read_ecc
+ * onenand_read - [MTD Interface] Read data from flash
  * @param mtd		MTD device structure
  * @param from		offset to read from
  * @param len		number of bytes to read
  * @param retlen	pointer to variable to store the number of read bytes
  * @param buf		the databuffer to put data
  *
- * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
+ * Read with ecc
 */
 int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
-		 size_t * retlen, u_char * buf)
+	size_t *retlen, u_char *buf)
 {
 	struct mtd_oob_ops ops = {
-		.len    = len,
-		.ooblen = 0,
-		.datbuf = buf,
-		.oobbuf = NULL,
+		.len	= len,
+		.ooblen	= 0,
+		.datbuf	= buf,
+		.oobbuf	= NULL,
 	};
 	int ret;
 
@@ -969,15 +1071,15 @@ int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
 }
 
 /**
- * onenand_read_oob - [MTD Interface] OneNAND read out-of-band
- * @param mtd		MTD device structure
- * @param from		offset to read from
- * @param ops		oob operations description structure
- *
- * OneNAND main and/or out-of-band
+ * onenand_read_oob - [MTD Interface] Read main and/or out-of-band
+ * @param mtd:		MTD device structure
+ * @param from:		offset to read from
+ * @param ops:		oob operation description structure
+
+ * Read main and/or out-of-band
  */
 int onenand_read_oob(struct mtd_info *mtd, loff_t from,
-			struct mtd_oob_ops *ops)
+			    struct mtd_oob_ops *ops)
 {
 	int ret;
 
@@ -1011,36 +1113,41 @@ int onenand_read_oob(struct mtd_info *mtd, loff_t from,
 static int onenand_bbt_wait(struct mtd_info *mtd, int state)
 {
 	struct onenand_chip *this = mtd->priv;
-	unsigned int flags = ONENAND_INT_MASTER;
+	unsigned long timeout;
 	unsigned int interrupt;
 	unsigned int ctrl;
 
-	while (1) {
+	/* The 20 msec is enough */
+	timeout = jiffies + msecs_to_jiffies(20);
+	while (time_before(jiffies, timeout)) {
 		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
-		if (interrupt & flags)
+		if (interrupt & ONENAND_INT_MASTER)
 			break;
 	}
-
 	/* To get correct interrupt status in timeout case */
 	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
 	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
 
-	/* Initial bad block case: 0x2400 or 0x0400 */
-	if (ctrl & ONENAND_CTRL_ERROR) {
-		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
-		return ONENAND_BBT_READ_ERROR;
-	}
-
 	if (interrupt & ONENAND_INT_READ) {
 		int ecc = this->read_word(this->base + ONENAND_REG_ECC_STATUS);
-		if (ecc & ONENAND_ECC_2BIT_ALL)
+		if (ecc & ONENAND_ECC_2BIT_ALL) {
+			printk(KERN_INFO "onenand_bbt_wait: ecc error = 0x%04x"
+				", controller error 0x%04x\n", ecc, ctrl);
 			return ONENAND_BBT_READ_ERROR;
+		}
 	} else {
 		printk(KERN_ERR "onenand_bbt_wait: read timeout!"
-				"ctrl=0x%04x intr=0x%04x\n", ctrl, interrupt);
+			"ctrl=0x%04x intr=0x%04x\n", ctrl, interrupt);
 		return ONENAND_BBT_READ_FATAL_ERROR;
 	}
 
+	/* Initial bad block case: 0x2400 or 0x0400 */
+	if (ctrl & ONENAND_CTRL_ERROR) {
+		printk(KERN_DEBUG "onenand_bbt_wait: "
+			"controller error = 0x%04x\n", ctrl);
+		return ONENAND_BBT_READ_ERROR;
+	}
+
 	return 0;
 }
 
@@ -1052,8 +1159,8 @@ static int onenand_bbt_wait(struct mtd_info *mtd, int state)
  *
  * OneNAND read out-of-band data from the spare area for bbt scan
  */
-int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
-		struct mtd_oob_ops *ops)
+int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from, 
+			    struct mtd_oob_ops *ops)
 {
 	struct onenand_chip *this = mtd->priv;
 	int read = 0, thislen, column;
@@ -1061,9 +1168,7 @@ int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
 	size_t len = ops->ooblen;
 	u_char *buf = ops->oobbuf;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_bbt_read_oob: from = 0x%08x, len = %zi\n",
-		(unsigned int) from, len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);
 
 	/* Initialize return value */
 	ops->oobretlen = 0;
@@ -1080,6 +1185,7 @@ int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
 	column = from & (mtd->oobsize - 1);
 
 	while (read < len) {
+		cond_resched();
 
 		thislen = mtd->oobsize - column;
 		thislen = min_t(int, thislen, len);
@@ -1114,13 +1220,12 @@ int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
 	return ret;
 }
 
-
 #ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE
 /**
  * onenand_verify_oob - [GENERIC] verify the oob contents after a write
- * @param mtd           MTD device structure
- * @param buf           the databuffer to verify
- * @param to            offset to read from
+ * @param mtd		MTD device structure
+ * @param buf		the databuffer to verify
+ * @param to		offset to read from
  */
 static int onenand_verify_oob(struct mtd_info *mtd, const u_char *buf, loff_t to)
 {
@@ -1186,22 +1291,128 @@ static int onenand_verify(struct mtd_info *mtd, const u_char *buf, loff_t addr,
 	return 0;
 }
 #else
-#define onenand_verify(...)             (0)
-#define onenand_verify_oob(...)         (0)
+#define onenand_verify(...)		(0)
+#define onenand_verify_oob(...)		(0)
 #endif
 
-#define NOTALIGNED(x)	((x & (mtd->writesize - 1)) != 0)
+#define NOTALIGNED(x)	((x & (this->subpagesize - 1)) != 0)
+
+static void onenand_panic_wait(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	unsigned int interrupt;
+	int i;
+	
+	for (i = 0; i < 2000; i++) {
+		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
+		if (interrupt & ONENAND_INT_MASTER)
+			break;
+		udelay(10);
+	}
+}
+
+/**
+ * onenand_panic_write - [MTD Interface] write buffer to FLASH in a panic context
+ * @param mtd		MTD device structure
+ * @param to		offset to write to
+ * @param len		number of bytes to write
+ * @param retlen	pointer to variable to store the number of written bytes
+ * @param buf		the data to write
+ *
+ * Write with ECC
+ */
+static int onenand_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+			 size_t *retlen, const u_char *buf)
+{
+	struct onenand_chip *this = mtd->priv;
+	int column, subpage;
+	int written = 0;
+	int ret = 0;
+
+	if (this->state == FL_PM_SUSPENDED)
+		return -EBUSY;
+
+	/* Wait for any existing operation to clear */
+	onenand_panic_wait(mtd);
+
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_panic_write: to = 0x%08x, len = %i\n",
+	      (unsigned int) to, (int) len);
+
+	/* Initialize retlen, in case of early exit */
+	*retlen = 0;
+
+	/* Do not allow writes past end of device */
+	if (unlikely((to + len) > mtd->size)) {
+		printk(KERN_ERR "onenand_panic_write: Attempt write to past end of device\n");
+		return -EINVAL;
+	}
+
+	/* Reject writes, which are not page aligned */
+        if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
+                printk(KERN_ERR "onenand_panic_write: Attempt to write not page aligned data\n");
+                return -EINVAL;
+        }
+
+	column = to & (mtd->writesize - 1);
+
+	/* Loop until all data write */
+	while (written < len) {
+		int thislen = min_t(int, mtd->writesize - column, len - written);
+		u_char *wbuf = (u_char *) buf;
+
+		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
+
+		/* Partial page write */
+		subpage = thislen < mtd->writesize;
+		if (subpage) {
+			memset(this->page_buf, 0xff, mtd->writesize);
+			memcpy(this->page_buf + column, buf, thislen);
+			wbuf = this->page_buf;
+		}
+
+		this->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
+		this->write_bufferram(mtd, ONENAND_SPARERAM, ffchars, 0, mtd->oobsize);
+
+		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
+
+		onenand_panic_wait(mtd);
+
+		/* In partial page write we don't update bufferram */
+		onenand_update_bufferram(mtd, to, !ret && !subpage);
+		if (ONENAND_IS_2PLANE(this)) {
+			ONENAND_SET_BUFFERRAM1(this);
+			onenand_update_bufferram(mtd, to + this->writesize, !ret && !subpage);
+		}
+
+		if (ret) {
+			printk(KERN_ERR "onenand_panic_write: write failed %d\n", ret);
+			break;
+		}
+
+		written += thislen;
+
+		if (written == len)
+			break;
+
+		column = 0;
+		to += thislen;
+		buf += thislen;
+	}
+
+	*retlen = written;
+	return ret;
+}
 
 /**
  * onenand_fill_auto_oob - [Internal] oob auto-placement transfer
- * @param mtd           MTD device structure
- * @param oob_buf       oob buffer
- * @param buf           source address
- * @param column        oob offset to write to
- * @param thislen       oob length to write
+ * @param mtd		MTD device structure
+ * @param oob_buf	oob buffer
+ * @param buf		source address
+ * @param column	oob offset to write to
+ * @param thislen	oob length to write
  */
 static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
-		const u_char *buf, int column, int thislen)
+				  const u_char *buf, int column, int thislen)
 {
 	struct onenand_chip *this = mtd->priv;
 	struct nand_oobfree *free;
@@ -1233,20 +1444,16 @@ static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
 	return 0;
 }
 
-static inline int notsizealigned(int x, int pagesize) {
-	return x % pagesize;
-}
-
 /**
  * onenand_write_ops_nolock - [OneNAND Interface] write main and/or out-of-band
- * @param mtd           MTD device structure
- * @param to            offset to write to
- * @param ops           oob operation description structure
+ * @param mtd		MTD device structure
+ * @param to		offset to write to
+ * @param ops		oob operation description structure
  *
  * Write main and/or oob with ECC
  */
 static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
-		struct mtd_oob_ops *ops)
+				struct mtd_oob_ops *ops)
 {
 	struct onenand_chip *this = mtd->priv;
 	int written = 0, column, thislen, subpage;
@@ -1257,15 +1464,8 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 	const u_char *oob = ops->oobbuf;
 	u_char *oobbuf;
 	int ret = 0;
-	int pagesize;
-	int is_yaffs;
 
-	is_yaffs = (oob != NULL && oob == buf) ? 1 : 0;
-	pagesize = (is_yaffs) ? (mtd->writesize + mtd->oobsize) : (mtd->writesize);
-
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_write_ops_nolock: to = 0x%08x, len = %i\n",
-		(unsigned int) to, (int) len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->retlen = 0;
@@ -1278,10 +1478,10 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 	}
 
 	/* Reject writes, which are not page aligned */
-	if (unlikely(NOTALIGNED(to) || notsizealigned(len, pagesize))) {
-		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
-		return -EINVAL;
-	}
+        if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
+                printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
+                return -EINVAL;
+        }
 
 	if (ops->mode == MTD_OOB_AUTO)
 		oobsize = this->ecclayout->oobavail;
@@ -1299,6 +1499,8 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 		thislen = min_t(int, mtd->writesize - column, len - written);
 		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
 
+		cond_resched();
+
 		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
 
 		/* Partial page write */
@@ -1311,18 +1513,11 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 
 		this->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
 
-		/* YAFFS support */
-		if (is_yaffs) {
-			oob = wbuf + mtd->writesize;
-			buf += mtd->oobsize;
-			written += mtd->oobsize;
-		}
-
 		if (oob) {
 			oobbuf = this->oob_buf;
 
 			/* We send data to spare ram with oobsize
-			 *                          * to prevent byte access */
+			 * to prevent byte access */
 			memset(oobbuf, 0xff, mtd->oobsize);
 			if (ops->mode == MTD_OOB_AUTO)
 				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
@@ -1368,40 +1563,27 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 		column = 0;
 		to += thislen;
 		buf += thislen;
-
-		if (!strcmp(mtd->owner, "UBOOT"))
-		{
-			int n = written;
-
-			n = n / (len / 100);
-			printf("\rWriting data at 0x%x "
-					"-- %3d%% complete.",
-					(unsigned int)to, n);
-		}
 	}
 
-	if (!strcmp(mtd->owner, "UBOOT"))
-		printf("\rWriting data at 0x%x "
-				"-- %3d%% complete.",
-				(unsigned int)to, 100);
 	ops->retlen = written;
 
 	return ret;
 }
 
+
 /**
  * onenand_write_oob_nolock - [Internal] OneNAND write out-of-band
- * @param mtd           MTD device structure
- * @param to            offset to write to
- * @param len           number of bytes to write
- * @param retlen        pointer to variable to store the number of written bytes
- * @param buf           the data to write
- * @param mode          operation mode
+ * @param mtd		MTD device structure
+ * @param to		offset to write to
+ * @param len		number of bytes to write
+ * @param retlen	pointer to variable to store the number of written bytes
+ * @param buf		the data to write
+ * @param mode		operation mode
  *
  * OneNAND write out-of-band
  */
 static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
-		struct mtd_oob_ops *ops)
+				    struct mtd_oob_ops *ops)
 {
 	struct onenand_chip *this = mtd->priv;
 	int column, ret = 0, oobsize;
@@ -1413,9 +1595,7 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
 
 	to += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3,
-		"onenand_write_oob_nolock: to = 0x%08x, len = %i\n",
-		(unsigned int) to, (int) len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->oobretlen = 0;
@@ -1435,14 +1615,14 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
 	/* For compatibility with NAND: Do not allow write past end of page */
 	if (unlikely(column + len > oobsize)) {
 		printk(KERN_ERR "onenand_write_oob_nolock: "
-				"Attempt to write past end of page\n");
+		      "Attempt to write past end of page\n");
 		return -EINVAL;
 	}
 
 	/* Do not allow reads past end of device */
 	if (unlikely(to >= mtd->size ||
-				column + len > ((mtd->size >> this->page_shift) -
-					(to >> this->page_shift)) * oobsize)) {
+		     column + len > ((mtd->size >> this->page_shift) -
+				     (to >> this->page_shift)) * oobsize)) {
 		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
 		return -EINVAL;
 	}
@@ -1453,6 +1633,8 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
 	while (written < len) {
 		int thislen = min_t(int, oobsize, len - written);
 
+		cond_resched();
+
 		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
 
 		/* We send data to spare ram with oobsize
@@ -1499,7 +1681,7 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
 }
 
 /**
- * onenand_write - [MTD Interface] compability function for onenand_write_ecc
+ * onenand_write - [MTD Interface] write buffer to FLASH
  * @param mtd		MTD device structure
  * @param to		offset to write to
  * @param len		number of bytes to write
@@ -1509,13 +1691,13 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
  * Write with ECC
  */
 int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
-		  size_t * retlen, const u_char * buf)
+	size_t *retlen, const u_char *buf)
 {
 	struct mtd_oob_ops ops = {
-		.len    = len,
-		.ooblen = 0,
-		.datbuf = (u_char *) buf,
-		.oobbuf = NULL,
+		.len	= len,
+		.ooblen	= 0,
+		.datbuf	= (u_char *) buf,
+		.oobbuf	= NULL,
 	};
 	int ret;
 
@@ -1528,15 +1710,13 @@ int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
 }
 
 /**
- * onenand_write_oob - [MTD Interface] OneNAND write out-of-band
- * @param mtd		MTD device structure
- * @param to		offset to write to
- * @param ops		oob operation description structure
- *
- * OneNAND write main and/or out-of-band
+ * onenand_write_oob - [MTD Interface] NAND write data and/or out-of-band
+ * @param mtd:		MTD device structure
+ * @param to:		offset to write
+ * @param ops:		oob operation description structure
  */
 int onenand_write_oob(struct mtd_info *mtd, loff_t to,
-			struct mtd_oob_ops *ops)
+			     struct mtd_oob_ops *ops)
 {
 	int ret;
 
@@ -1558,7 +1738,6 @@ int onenand_write_oob(struct mtd_info *mtd, loff_t to,
 	onenand_release_device(mtd);
 
 	return ret;
-
 }
 
 /**
@@ -1567,7 +1746,7 @@ int onenand_write_oob(struct mtd_info *mtd, loff_t to,
  * @param ofs		offset from device start
  * @param allowbbt	1, if its allowed to access the bbt area
  *
- * Check, if the block is bad, Either by reading the bad block table or
+ * Check, if the block is bad. Either by reading the bad block table or
  * calling of the scan function.
  */
 static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
@@ -1579,7 +1758,6 @@ static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allo
 	return bbm->isbad_bbt(mtd, ofs, allowbbt);
 }
 
-
 /**
  * onenand_erase - [MTD Interface] erase block(s)
  * @param mtd		MTD device structure
@@ -1595,34 +1773,29 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 	int len;
 	int ret = 0;
 
-	MTDDEBUG (MTD_DEBUG_LEVEL3,
-		 "onenand_erase: start = 0x%08x, len = %i\n",
-		 (unsigned int)instr->addr, (unsigned int)instr->len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);
 
 	block_size = (1 << this->erase_shift);
 
 	/* Start address must align on block boundary */
 	if (unlikely(instr->addr & (block_size - 1))) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			 "onenand_erase: Unaligned address\n");
+		printk(KERN_ERR "onenand_erase: Unaligned address\n");
 		return -EINVAL;
 	}
 
 	/* Length must align on block boundary */
 	if (unlikely(instr->len & (block_size - 1))) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			 "onenand_erase: Length not block aligned\n");
+		printk(KERN_ERR "onenand_erase: Length not block aligned\n");
 		return -EINVAL;
 	}
 
 	/* Do not allow erase past end of device */
 	if (unlikely((instr->len + instr->addr) > mtd->size)) {
-		MTDDEBUG (MTD_DEBUG_LEVEL0,
-			 "onenand_erase: Erase past end of device\n");
+		printk(KERN_ERR "onenand_erase: Erase past end of device\n");
 		return -EINVAL;
 	}
 
-	instr->fail_addr = 0xffffffff;
+	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
 
 	/* Grab the lock and see if the device is available */
 	onenand_get_device(mtd, FL_ERASING);
@@ -1634,8 +1807,14 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 	instr->state = MTD_ERASING;
 
 	while (len) {
+		cond_resched();
 
-		/* TODO Check badblock */
+		/* Check if we have a bad block, we do not erase bad blocks */
+		if (onenand_block_isbad_nolock(mtd, addr, 0)) {
+			printk (KERN_WARNING "onenand_erase: attempt to erase a bad block at addr 0x%08x\n", (unsigned int) addr);
+			instr->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
 
 		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);
 
@@ -1644,13 +1823,7 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 		ret = this->wait(mtd, FL_ERASING);
 		/* Check, if it is write protected */
 		if (ret) {
-			if (ret == -EPERM)
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
-					  "Device is write protected!!!\n");
-			else
-				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
-					  "Failed erase, block %d\n",
-					  (unsigned)(addr >> this->erase_shift));
+			printk(KERN_ERR "onenand_erase: Failed erase, block %d\n", (unsigned) (addr >> this->erase_shift));
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = addr;
 			goto erase_exit;
@@ -1662,16 +1835,17 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 
 	instr->state = MTD_ERASE_DONE;
 
-      erase_exit:
+erase_exit:
 
 	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
-	/* Do call back function */
-	if (!ret)
-		mtd_erase_callback(instr);
 
 	/* Deselect and wake up anyone waiting on the device */
 	onenand_release_device(mtd);
 
+	/* Do call back function */
+	if (!ret)
+		mtd_erase_callback(instr);
+
 	return ret;
 }
 
@@ -1681,9 +1855,9 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
  *
  * Sync is actually a wait for chip ready function
  */
-void onenand_sync(struct mtd_info *mtd)
+static void onenand_sync(struct mtd_info *mtd)
 {
-	MTDDEBUG (MTD_DEBUG_LEVEL3, "onenand_sync: called\n");
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_sync: called\n");
 
 	/* Grab the lock and see if the device is available */
 	onenand_get_device(mtd, FL_SYNCING);
@@ -1699,7 +1873,7 @@ void onenand_sync(struct mtd_info *mtd)
  *
  * Check whether the block is bad
  */
-int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+static int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
 {
 	int ret;
 
@@ -1708,22 +1882,52 @@ int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
 		return -EINVAL;
 
 	onenand_get_device(mtd, FL_READING);
-	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
+	ret = onenand_block_isbad_nolock(mtd, ofs, 0);
 	onenand_release_device(mtd);
 	return ret;
 }
 
 /**
+ * onenand_default_block_markbad - [DEFAULT] mark a block bad
+ * @param mtd		MTD device structure
+ * @param ofs		offset from device start
+ *
+ * This is the default implementation, which can be overridden by
+ * a hardware specific driver.
+ */
+static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct bbm_info *bbm = this->bbm;
+	u_char buf[2] = {0, 0};
+	struct mtd_oob_ops ops = {
+		.mode = MTD_OOB_PLACE,
+		.ooblen = 2,
+		.oobbuf = buf,
+		.ooboffs = 0,
+	};
+	int block;
+
+	/* Get block number */
+	block = ((int) ofs) >> bbm->bbt_erase_shift;
+        if (bbm->bbt)
+                bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+
+        /* We write two bytes, so we dont have to mess with 16 bit access */
+        ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
+        return onenand_write_oob_nolock(mtd, ofs, &ops);
+}
+
+/**
  * onenand_block_markbad - [MTD Interface] Mark the block at the given offset as bad
  * @param mtd		MTD device structure
  * @param ofs		offset relative to mtd start
  *
  * Mark the block as bad
  */
-int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+static int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
 	struct onenand_chip *this = mtd->priv;
-        struct bbm_info *bbm = this->bbm;
 	int ret;
 
 	ret = onenand_block_isbad(mtd, ofs);
@@ -1734,15 +1938,6 @@ int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 		return ret;
 	}
 
-	int block;
-	/* Get block number */
-	block = ((int) ofs) >> bbm->bbt_erase_shift;
-	if (pxa3xx_bbm && pxa3xx_bbm->table_init && pxa3xx_bbm->markbad) {
-		ret = pxa3xx_bbm->markbad(mtd, pxa3xx_bbm, block);
-		if (!ret)
-			return 0;
-	}
-
 	onenand_get_device(mtd, FL_WRITING);
 	ret = this->block_markbad(mtd, ofs);
 	onenand_release_device(mtd);
@@ -1750,105 +1945,591 @@ int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 }
 
 /**
- * onenand_unlock - [MTD Interface] Unlock block(s)
+ * onenand_do_lock_cmd - [OneNAND Interface] Lock or unlock block(s)
  * @param mtd		MTD device structure
  * @param ofs		offset relative to mtd start
- * @param len		number of bytes to unlock
+ * @param len		number of bytes to lock or unlock
+ * @param cmd		lock or unlock command
  *
- * Unlock one or more blocks
+ * Lock or unlock one or more blocks
  */
-int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
 {
 	struct onenand_chip *this = mtd->priv;
 	int start, end, block, value, status;
+	int wp_status_mask;
 
 	start = ofs >> this->erase_shift;
 	end = len >> this->erase_shift;
 
+	if (cmd == ONENAND_CMD_LOCK)
+		wp_status_mask = ONENAND_WP_LS;
+	else
+		wp_status_mask = ONENAND_WP_US;
+
 	/* Continuous lock scheme */
-	if (this->options & ONENAND_CONT_LOCK) {
+	if (this->options & ONENAND_HAS_CONT_LOCK) {
 		/* Set start block address */
-		this->write_word(start,
-				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
+		this->write_word(start, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
 		/* Set end block address */
-		this->write_word(end - 1,
-				 this->base + ONENAND_REG_END_BLOCK_ADDRESS);
-		/* Write unlock command */
-		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
+		this->write_word(start + end - 1, this->base + ONENAND_REG_END_BLOCK_ADDRESS);
+		/* Write lock command */
+		this->command(mtd, cmd, 0, 0);
 
 		/* There's no return value */
-		this->wait(mtd, FL_UNLOCKING);
+		this->wait(mtd, FL_LOCKING);
 
 		/* Sanity check */
 		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
-		       & ONENAND_CTRL_ONGO)
+		    & ONENAND_CTRL_ONGO)
 			continue;
 
 		/* Check lock status */
 		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
-		if (!(status & ONENAND_WP_US))
+		if (!(status & wp_status_mask))
 			printk(KERN_ERR "wp status = 0x%x\n", status);
 
 		return 0;
 	}
 
 	/* Block lock scheme */
-	for (block = start; block < end; block++) {
+	for (block = start; block < start + end; block++) {
+		/* Set block address */
+		value = onenand_block_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
+		/* Select DataRAM for DDP */
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
 		/* Set start block address */
-		this->write_word(block,
-				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
-		/* Write unlock command */
-		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
+		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
+		/* Write lock command */
+		this->command(mtd, cmd, 0, 0);
 
 		/* There's no return value */
-		this->wait(mtd, FL_UNLOCKING);
+		this->wait(mtd, FL_LOCKING);
 
 		/* Sanity check */
 		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
-		       & ONENAND_CTRL_ONGO)
+		    & ONENAND_CTRL_ONGO)
 			continue;
 
-		/* Set block address for read block status */
-		value = onenand_block_address(this->device_id, block);
-		this->write_word(value,
-				 this->base + ONENAND_REG_START_ADDRESS1);
-
 		/* Check lock status */
 		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
-		if (!(status & ONENAND_WP_US))
-			printk(KERN_ERR "block = %d, wp status = 0x%x\n",
-			       block, status);
+		if (!(status & wp_status_mask))
+			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
 	}
 
 	return 0;
 }
 
 /**
- * onenand_print_device_info - Print device ID
- * @param device        device ID
+ * onenand_lock - [MTD Interface] Lock block(s)
+ * @param mtd		MTD device structure
+ * @param ofs		offset relative to mtd start
+ * @param len		number of bytes to unlock
+ *
+ * Lock one or more blocks
+ */
+static int onenand_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	int ret;
+
+	onenand_get_device(mtd, FL_LOCKING);
+	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_LOCK);
+	onenand_release_device(mtd);
+	return ret;
+}
+
+/**
+ * onenand_unlock - [MTD Interface] Unlock block(s)
+ * @param mtd		MTD device structure
+ * @param ofs		offset relative to mtd start
+ * @param len		number of bytes to unlock
+ *
+ * Unlock one or more blocks
+ */
+int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
+{
+	int ret;
+
+	onenand_get_device(mtd, FL_LOCKING);
+	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
+	onenand_release_device(mtd);
+	return ret;
+}
+
+/**
+ * onenand_check_lock_status - [OneNAND Interface] Check lock status
+ * @param this		onenand chip data structure
+ *
+ * Check lock status
+ */
+static int onenand_check_lock_status(struct onenand_chip *this)
+{
+	unsigned int value, block, status;
+	unsigned int end;
+
+	end = this->chipsize >> this->erase_shift;
+	for (block = 0; block < end; block++) {
+		/* Set block address */
+		value = onenand_block_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
+		/* Select DataRAM for DDP */
+		value = onenand_bufferram_address(this, block);
+		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
+		/* Set start block address */
+		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
+
+		/* Check lock status */
+		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
+		if (!(status & ONENAND_WP_US)) {
+			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+/**
+ * onenand_unlock_all - [OneNAND Interface] unlock all blocks
+ * @param mtd		MTD device structure
+ *
+ * Unlock all blocks
+ */
+static void onenand_unlock_all(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	loff_t ofs = 0;
+	size_t len = this->chipsize;
+
+	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
+		/* Set start block address */
+		this->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
+		/* Write unlock command */
+		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
+
+		/* There's no return value */
+		this->wait(mtd, FL_LOCKING);
+
+		/* Sanity check */
+		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
+		    & ONENAND_CTRL_ONGO)
+			continue;
+
+		/* Check lock status */
+		if (onenand_check_lock_status(this))
+			return;
+
+		/* Workaround for all block unlock in DDP */
+		if (ONENAND_IS_DDP(this)) {
+			/* All blocks on another chip */
+			ofs = this->chipsize >> 1;
+			len = this->chipsize >> 1;
+		}
+	}
+
+	onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
+}
+
+#ifdef CONFIG_MTD_ONENAND_OTP
+
+/* Interal OTP operation */
+typedef int (*otp_op_t)(struct mtd_info *mtd, loff_t form, size_t len,
+		size_t *retlen, u_char *buf);
+
+/**
+ * do_otp_read - [DEFAULT] Read OTP block area
+ * @param mtd		MTD device structure
+ * @param from		The offset to read
+ * @param len		number of bytes to read
+ * @param retlen	pointer to variable to store the number of readbytes
+ * @param buf		the databuffer to put/get data
+ *
+ * Read OTP block area.
+ */
+static int do_otp_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct mtd_oob_ops ops = {
+		.len	= len,
+		.ooblen	= 0,
+		.datbuf	= buf,
+		.oobbuf	= NULL,
+	};
+	int ret;
+
+	/* Enter OTP access mode */
+	this->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);
+	this->wait(mtd, FL_OTPING);
+
+	ret = onenand_read_ops_nolock(mtd, from, &ops);
+
+	/* Exit OTP access mode */
+	this->command(mtd, ONENAND_CMD_RESET, 0, 0);
+	this->wait(mtd, FL_RESETING);
+
+	return ret;
+}
+
+/**
+ * do_otp_write - [DEFAULT] Write OTP block area
+ * @param mtd		MTD device structure
+ * @param to		The offset to write
+ * @param len		number of bytes to write
+ * @param retlen	pointer to variable to store the number of write bytes
+ * @param buf		the databuffer to put/get data
+ *
+ * Write OTP block area.
+ */
+static int do_otp_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct onenand_chip *this = mtd->priv;
+	unsigned char *pbuf = buf;
+	int ret;
+	struct mtd_oob_ops ops;
+
+	/* Force buffer page aligned */
+	if (len < mtd->writesize) {
+		memcpy(this->page_buf, buf, len);
+		memset(this->page_buf + len, 0xff, mtd->writesize - len);
+		pbuf = this->page_buf;
+		len = mtd->writesize;
+	}
+
+	/* Enter OTP access mode */
+	this->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);
+	this->wait(mtd, FL_OTPING);
+
+	ops.len = len;
+	ops.ooblen = 0;
+	ops.datbuf = pbuf;
+	ops.oobbuf = NULL;
+	ret = onenand_write_ops_nolock(mtd, to, &ops);
+	*retlen = ops.retlen;
+
+	/* Exit OTP access mode */
+	this->command(mtd, ONENAND_CMD_RESET, 0, 0);
+	this->wait(mtd, FL_RESETING);
+
+	return ret;
+}
+
+/**
+ * do_otp_lock - [DEFAULT] Lock OTP block area
+ * @param mtd		MTD device structure
+ * @param from		The offset to lock
+ * @param len		number of bytes to lock
+ * @param retlen	pointer to variable to store the number of lock bytes
+ * @param buf		the databuffer to put/get data
+ *
+ * Lock OTP block area.
+ */
+static int do_otp_lock(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct onenand_chip *this = mtd->priv;
+	struct mtd_oob_ops ops = {
+		.mode = MTD_OOB_PLACE,
+		.ooblen = len,
+		.oobbuf = buf,
+		.ooboffs = 0,
+	};
+	int ret;
+
+	/* Enter OTP access mode */
+	this->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);
+	this->wait(mtd, FL_OTPING);
+
+	ret = onenand_write_oob_nolock(mtd, from, &ops);
+
+	*retlen = ops.oobretlen;
+
+	/* Exit OTP access mode */
+	this->command(mtd, ONENAND_CMD_RESET, 0, 0);
+	this->wait(mtd, FL_RESETING);
+
+	return ret;
+}
+
+/**
+ * onenand_otp_walk - [DEFAULT] Handle OTP operation
+ * @param mtd		MTD device structure
+ * @param from		The offset to read/write
+ * @param len		number of bytes to read/write
+ * @param retlen	pointer to variable to store the number of read bytes
+ * @param buf		the databuffer to put/get data
+ * @param action	do given action
+ * @param mode		specify user and factory
+ *
+ * Handle OTP operation.
+ */
+static int onenand_otp_walk(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf,
+			otp_op_t action, int mode)
+{
+	struct onenand_chip *this = mtd->priv;
+	int otp_pages;
+	int density;
+	int ret = 0;
+
+	*retlen = 0;
+
+	density = onenand_get_density(this->device_id);
+	if (density < ONENAND_DEVICE_DENSITY_512Mb)
+		otp_pages = 20;
+	else
+		otp_pages = 10;
+
+	if (mode == MTD_OTP_FACTORY) {
+		from += mtd->writesize * otp_pages;
+		otp_pages = 64 - otp_pages;
+	}
+
+	/* Check User/Factory boundary */
+	if (((mtd->writesize * otp_pages) - (from + len)) < 0)
+		return 0;
+
+	onenand_get_device(mtd, FL_OTPING);
+	while (len > 0 && otp_pages > 0) {
+		if (!action) {	/* OTP Info functions */
+			struct otp_info *otpinfo;
+
+			len -= sizeof(struct otp_info);
+			if (len <= 0) {
+				ret = -ENOSPC;
+				break;
+			}
+
+			otpinfo = (struct otp_info *) buf;
+			otpinfo->start = from;
+			otpinfo->length = mtd->writesize;
+			otpinfo->locked = 0;
+
+			from += mtd->writesize;
+			buf += sizeof(struct otp_info);
+			*retlen += sizeof(struct otp_info);
+		} else {
+			size_t tmp_retlen;
+			int size = len;
+
+			ret = action(mtd, from, len, &tmp_retlen, buf);
+
+			buf += size;
+			len -= size;
+			*retlen += size;
+
+			if (ret)
+				break;
+		}
+		otp_pages--;
+	}
+	onenand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * onenand_get_fact_prot_info - [MTD Interface] Read factory OTP info
+ * @param mtd		MTD device structure
+ * @param buf		the databuffer to put/get data
+ * @param len		number of bytes to read
+ *
+ * Read factory OTP info.
+ */
+static int onenand_get_fact_prot_info(struct mtd_info *mtd,
+			struct otp_info *buf, size_t len)
+{
+	size_t retlen;
+	int ret;
+
+	ret = onenand_otp_walk(mtd, 0, len, &retlen, (u_char *) buf, NULL, MTD_OTP_FACTORY);
+
+	return ret ? : retlen;
+}
+
+/**
+ * onenand_read_fact_prot_reg - [MTD Interface] Read factory OTP area
+ * @param mtd		MTD device structure
+ * @param from		The offset to read
+ * @param len		number of bytes to read
+ * @param retlen	pointer to variable to store the number of read bytes
+ * @param buf		the databuffer to put/get data
+ *
+ * Read factory OTP area.
+ */
+static int onenand_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
+			size_t len, size_t *retlen, u_char *buf)
+{
+	return onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_FACTORY);
+}
+
+/**
+ * onenand_get_user_prot_info - [MTD Interface] Read user OTP info
+ * @param mtd		MTD device structure
+ * @param buf		the databuffer to put/get data
+ * @param len		number of bytes to read
+ *
+ * Read user OTP info.
+ */
+static int onenand_get_user_prot_info(struct mtd_info *mtd,
+			struct otp_info *buf, size_t len)
+{
+	size_t retlen;
+	int ret;
+
+	ret = onenand_otp_walk(mtd, 0, len, &retlen, (u_char *) buf, NULL, MTD_OTP_USER);
+
+	return ret ? : retlen;
+}
+
+/**
+ * onenand_read_user_prot_reg - [MTD Interface] Read user OTP area
+ * @param mtd		MTD device structure
+ * @param from		The offset to read
+ * @param len		number of bytes to read
+ * @param retlen	pointer to variable to store the number of read bytes
+ * @param buf		the databuffer to put/get data
  *
- * Print device ID
+ * Read user OTP area.
  */
-char * onenand_print_device_info(int device)
+static int onenand_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
+			size_t len, size_t *retlen, u_char *buf)
 {
-	int vcc, demuxed, ddp, density;
-	char *dev_info = malloc(80);
+	return onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_USER);
+}
+
+/**
+ * onenand_write_user_prot_reg - [MTD Interface] Write user OTP area
+ * @param mtd		MTD device structure
+ * @param from		The offset to write
+ * @param len		number of bytes to write
+ * @param retlen	pointer to variable to store the number of write bytes
+ * @param buf		the databuffer to put/get data
+ *
+ * Write user OTP area.
+ */
+static int onenand_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
+			size_t len, size_t *retlen, u_char *buf)
+{
+	return onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_write, MTD_OTP_USER);
+}
+
+/**
+ * onenand_lock_user_prot_reg - [MTD Interface] Lock user OTP area
+ * @param mtd		MTD device structure
+ * @param from		The offset to lock
+ * @param len		number of bytes to unlock
+ *
+ * Write lock mark on spare area in page 0 in OTP block
+ */
+static int onenand_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,
+			size_t len)
+{
+	struct onenand_chip *this = mtd->priv;
+	u_char *oob_buf = this->oob_buf;
+	size_t retlen;
+	int ret;
+
+	memset(oob_buf, 0xff, mtd->oobsize);
+	/*
+	 * Note: OTP lock operation
+	 *       OTP block : 0xXXFC
+	 *       1st block : 0xXXF3 (If chip support)
+	 *       Both      : 0xXXF0 (If chip support)
+	 */
+	oob_buf[ONENAND_OTP_LOCK_OFFSET] = 0xFC;
+
+	/*
+	 * Write lock mark to 8th word of sector0 of page0 of the spare0.
+	 * We write 16 bytes spare area instead of 2 bytes.
+	 */
+	from = 0;
+	len = 16;
 
-	vcc = device & ONENAND_DEVICE_VCC_MASK;
-	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
-	ddp = device & ONENAND_DEVICE_IS_DDP;
-	density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
-	sprintf(dev_info, "%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
-	       demuxed ? "" : "Muxed ",
-	       ddp ? "(DDP)" : "",
-	       (16 << density), vcc ? "2.65/3.3" : "1.8", device);
+	ret = onenand_otp_walk(mtd, from, len, &retlen, oob_buf, do_otp_lock, MTD_OTP_USER);
 
-	return dev_info;
+	return ret ? : retlen;
+}
+#endif	/* CONFIG_MTD_ONENAND_OTP */
+
+/**
+ * onenand_check_features - Check and set OneNAND features
+ * @param mtd		MTD data structure
+ *
+ * Check and set OneNAND features
+ * - lock scheme
+ * - two plane
+ */
+static void onenand_check_features(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	unsigned int density, process;
+
+	/* Lock scheme depends on density and process */
+	density = onenand_get_density(this->device_id);
+	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
+
+	/* Lock scheme */
+	switch (density) {
+	case ONENAND_DEVICE_DENSITY_4Gb:
+		this->options |= ONENAND_HAS_2PLANE;
+
+	case ONENAND_DEVICE_DENSITY_2Gb:
+		/* 2Gb DDP don't have 2 plane */
+		if (!ONENAND_IS_DDP(this))
+			this->options |= ONENAND_HAS_2PLANE;
+		this->options |= ONENAND_HAS_UNLOCK_ALL;
+
+	case ONENAND_DEVICE_DENSITY_1Gb:
+		/* A-Die has all block unlock */
+		if (process)
+			this->options |= ONENAND_HAS_UNLOCK_ALL;
+		break;
+
+	default:
+		/* Some OneNAND has continuous lock scheme */
+		if (!process)
+			this->options |= ONENAND_HAS_CONT_LOCK;
+		break;
+	}
+
+	if (this->options & ONENAND_HAS_CONT_LOCK)
+		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
+	if (this->options & ONENAND_HAS_UNLOCK_ALL)
+		printk(KERN_DEBUG "Chip support all block unlock\n");
+	if (this->options & ONENAND_HAS_2PLANE)
+		printk(KERN_DEBUG "Chip has 2 plane\n");
+}
+
+/**
+ * onenand_print_device_info - Print device & version ID
+ * @param device        device ID
+ * @param version	version ID
+ *
+ * Print device & version ID
+ */
+void onenand_print_device_info(int device, int version)
+{
+        int vcc, demuxed, ddp, density;
+
+        vcc = device & ONENAND_DEVICE_VCC_MASK;
+        demuxed = device & ONENAND_DEVICE_IS_DEMUX;
+        ddp = device & ONENAND_DEVICE_IS_DDP;
+        density = onenand_get_density(device);
+        printk(KERN_INFO "%sOneNAND%s %dMB %sV 16-bit (0x%02x)\n",
+                demuxed ? "" : "Muxed ",
+                ddp ? "(DDP)" : "",
+                (16 << density),
+                vcc ? "2.65/3.3" : "1.8",
+                device);
+	printk(KERN_INFO "OneNAND version = 0x%04x\n", version);
 }
 
 static const struct onenand_manufacturers onenand_manuf_ids[] = {
-	{ONENAND_MFR_SAMSUNG, "Samsung"},
-	{ONENAND_MFR_UNKNOWN, "Unknown"}
+        {ONENAND_MFR_SAMSUNG, "Samsung"},
 };
 
 /**
@@ -1859,19 +2540,22 @@ static const struct onenand_manufacturers onenand_manuf_ids[] = {
  */
 static int onenand_check_maf(int manuf)
 {
-	int i;
+	int size = ARRAY_SIZE(onenand_manuf_ids);
+	char *name;
+        int i;
 
-	for (i = 0; onenand_manuf_ids[i].id; i++) {
-		if (manuf == onenand_manuf_ids[i].id)
-			break;
-	}
+	for (i = 0; i < size; i++)
+                if (manuf == onenand_manuf_ids[i].id)
+                        break;
 
-#ifdef ONENAND_DEBUG
-	printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n",
-	       onenand_manuf_ids[i].name, manuf);
-#endif
+	if (i < size)
+		name = onenand_manuf_ids[i].name;
+	else
+		name = "Unknown";
+
+	printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n", name, manuf);
 
-	return (i != ONENAND_MFR_UNKNOWN);
+	return (i == size);
 }
 
 /**
@@ -1879,14 +2563,19 @@ static int onenand_check_maf(int manuf)
  * @param mtd		MTD device structure
  *
  * OneNAND detection method:
- *   Compare the the values from command with ones from register
+ *   Compare the values from command with ones from register
  */
 static int onenand_probe(struct mtd_info *mtd)
 {
 	struct onenand_chip *this = mtd->priv;
-	int bram_maf_id, bram_dev_id, maf_id, dev_id;
-	int version_id;
+	int bram_maf_id, bram_dev_id, maf_id, dev_id, ver_id;
 	int density;
+	int syscfg;
+
+	/* Save system configuration 1 */
+	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
+	/* Clear Sync. Burst Read mode to read BootRAM */
+	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ), this->base + ONENAND_REG_SYS_CFG1);
 
 	/* Send the command for reading device ID from BootRAM */
 	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
@@ -1895,49 +2584,50 @@ static int onenand_probe(struct mtd_info *mtd)
 	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
 	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
 
-	/* Check manufacturer ID */
-	if (onenand_check_maf(bram_maf_id))
-		return -ENXIO;
-
 	/* Reset OneNAND to read default register values */
 	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
-
 	/* Wait reset */
 	this->wait(mtd, FL_RESETING);
 
+	/* Restore system configuration 1 */
+	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
+
+	/* Check manufacturer ID */
+	if (onenand_check_maf(bram_maf_id))
+		return -ENXIO;
+
 	/* Read manufacturer and device IDs from Register */
 	maf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);
 	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
+	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
 
 	/* Check OneNAND device */
 	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
 		return -ENXIO;
 
-	/* FIXME : Current OneNAND MTD doesn't support Flex-OneNAND */
-	if (dev_id & (1 << 9)) {
-		printk("Not yet support Flex-OneNAND\n");
-		return -ENXIO;
-	}
-
 	/* Flash device information */
-	mtd->name = onenand_print_device_info(dev_id);
+	onenand_print_device_info(dev_id, ver_id);
 	this->device_id = dev_id;
+	this->version_id = ver_id;
 
-	density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
+	density = onenand_get_density(dev_id);
 	this->chipsize = (16 << density) << 20;
+	/* Set density mask. it is used for DDP */
+	if (ONENAND_IS_DDP(this))
+		this->density_mask = (1 << (density + 6));
+	else
+		this->density_mask = 0;
 
 	/* OneNAND page size & block size */
 	/* The data buffer size is equal to page size */
-	mtd->writesize =
-	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
+	mtd->writesize = this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
 	mtd->oobsize = mtd->writesize >> 5;
-	/* Pagers per block is always 64 in OneNAND */
+	/* Pages per a block are always 64 in OneNAND */
 	mtd->erasesize = mtd->writesize << 6;
 
 	this->erase_shift = ffs(mtd->erasesize) - 1;
 	this->page_shift = ffs(mtd->writesize) - 1;
-	this->ppb_shift = (this->erase_shift - this->page_shift);
-	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
+	this->page_mask = (1 << (this->erase_shift - this->page_shift)) - 1;
 	/* It's real page size */
 	this->writesize = mtd->writesize;
 
@@ -1945,36 +2635,48 @@ static int onenand_probe(struct mtd_info *mtd)
 
 	mtd->size = this->chipsize;
 
-	/* Version ID */
-	version_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
-#ifdef ONENAND_DEBUG
-	printk(KERN_DEBUG "OneNAND version = 0x%04x\n", version_id);
-#endif
+	/* Check OneNAND features */
+	onenand_check_features(mtd);
 
-	/* Lock scheme */
-	if (density <= ONENAND_DEVICE_DENSITY_512Mb &&
-	    !(version_id >> ONENAND_VERSION_PROCESS_SHIFT)) {
-		printk(KERN_INFO "Lock scheme is Continues Lock\n");
-		this->options |= ONENAND_CONT_LOCK;
+	/*
+	 * We emulate the 4KiB page and 256KiB erase block size
+	 * But oobsize is still 64 bytes.
+	 * It is only valid if you turn on 2X program support,
+	 * Otherwise it will be ignored by compiler.
+	 */
+	if (ONENAND_IS_2PLANE(this)) {
+		mtd->writesize <<= 1;
+		mtd->erasesize <<= 1;
 	}
 
-	mtd->flags = MTD_CAP_NANDFLASH;
-	mtd->erase = onenand_erase;
-	mtd->read = onenand_read;
-	mtd->write = onenand_write;
-	mtd->read_oob = onenand_read_oob;
-	mtd->write_oob = onenand_write_oob;
-	mtd->sync = onenand_sync;
-	mtd->block_isbad = onenand_block_isbad;
-	mtd->block_markbad = onenand_block_markbad;
-
-#if defined(CONFIG_PXA3xx_DVFM)
-        dvfm_register("OneNAND", &dvfm_lock.dev_idx);
-#endif
 	return 0;
 }
 
 /**
+ * onenand_suspend - [MTD Interface] Suspend the OneNAND flash
+ * @param mtd		MTD device structure
+ */
+static int onenand_suspend(struct mtd_info *mtd)
+{
+	return onenand_get_device(mtd, FL_PM_SUSPENDED);
+}
+
+/**
+ * onenand_resume - [MTD Interface] Resume the OneNAND flash
+ * @param mtd		MTD device structure
+ */
+static void onenand_resume(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+
+	if (this->state == FL_PM_SUSPENDED)
+		onenand_release_device(mtd);
+	else
+		printk(KERN_ERR "resume() called for the chip which is not"
+				"in suspended state\n");
+}
+
+/**
  * onenand_scan - [OneNAND Interface] Scan for the OneNAND device
  * @param mtd		MTD device structure
  * @param maxchips	Number of chips to scan for
@@ -1986,6 +2688,7 @@ static int onenand_probe(struct mtd_info *mtd)
  */
 int onenand_scan(struct mtd_info *mtd, int maxchips)
 {
+	int i;
 	struct onenand_chip *this = mtd->priv;
 
 	if (!this->read_word)
@@ -1996,13 +2699,18 @@ int onenand_scan(struct mtd_info *mtd, int maxchips)
 	if (!this->command)
 		this->command = onenand_command;
 	if (!this->wait)
-		this->wait = onenand_wait;
+		onenand_setup_wait(mtd);
 
 	if (!this->read_bufferram)
 		this->read_bufferram = onenand_read_bufferram;
 	if (!this->write_bufferram)
 		this->write_bufferram = onenand_write_bufferram;
 
+	if (!this->block_markbad)
+		this->block_markbad = onenand_default_block_markbad;
+	if (!this->scan_bbt)
+		this->scan_bbt = onenand_default_bbt;
+
 	if (onenand_probe(mtd))
 		return -ENXIO;
 
@@ -2024,7 +2732,7 @@ int onenand_scan(struct mtd_info *mtd, int maxchips)
 	if (!this->oob_buf) {
 		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
 		if (!this->oob_buf) {
-			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
+			printk(KERN_ERR "onenand_scan(): Can't allocate oob_buf\n");
 			if (this->options & ONENAND_PAGEBUF_ALLOC) {
 				this->options &= ~ONENAND_PAGEBUF_ALLOC;
 				kfree(this->page_buf);
@@ -2034,32 +2742,80 @@ int onenand_scan(struct mtd_info *mtd, int maxchips)
 		this->options |= ONENAND_OOBBUF_ALLOC;
 	}
 
-	onenand_unlock(mtd, 0, mtd->size);
+	this->state = FL_READY;
+	init_waitqueue_head(&this->wq);
+	spin_lock_init(&this->chip_lock);
 
-	/* NOTES: alloc pxa3xx bbm after unlock operation because
-	 *          * the mtd->size will shrink in pxa3xx_bbm->init to
-	 *                   * reserver relocation blocks.
-	 *                            */
-	pxa3xx_bbm = alloc_pxa3xx_bbm();
-	if (!pxa3xx_bbm) {
-		goto out;
-	}
+	/*
+	 * Allow subpage writes up to oobsize.
+	 */
+	switch (mtd->oobsize) {
+	case 64:
+		this->ecclayout = &onenand_oob_64;
+		mtd->subpage_sft = 2;
+		break;
 
-	if (pxa3xx_bbm->init) {
-		pxa3xx_bbm->flash_type = FLASH_ONENAND;
-		pxa3xx_bbm->page_shift = this->page_shift;
-		pxa3xx_bbm->erase_shift = this->erase_shift;
+	case 32:
+		this->ecclayout = &onenand_oob_32;
+		mtd->subpage_sft = 1;
+		break;
 
-		if (pxa3xx_bbm->init(mtd, pxa3xx_bbm))
-			goto free_bbm;
+	default:
+		printk(KERN_WARNING "No OOB scheme defined for oobsize %d\n",
+			mtd->oobsize);
+		mtd->subpage_sft = 0;
+		/* To prevent kernel oops */
+		this->ecclayout = &onenand_oob_32;
+		break;
 	}
 
-	return onenand_default_bbt(mtd);
+	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
+
+	/*
+	 * The number of bytes available for a client to place data into
+	 * the out of band area
+	 */
+	this->ecclayout->oobavail = 0;
+	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
+	    this->ecclayout->oobfree[i].length; i++)
+		this->ecclayout->oobavail +=
+			this->ecclayout->oobfree[i].length;
+	mtd->oobavail = this->ecclayout->oobavail;
+
+	mtd->ecclayout = this->ecclayout;
+
+	/* Fill in remaining MTD driver data */
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->erase = onenand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = onenand_read;
+	mtd->write = onenand_write;
+	mtd->read_oob = onenand_read_oob;
+	mtd->write_oob = onenand_write_oob;
+	mtd->panic_write = onenand_panic_write;
+#ifdef CONFIG_MTD_ONENAND_OTP
+	mtd->get_fact_prot_info = onenand_get_fact_prot_info;
+	mtd->read_fact_prot_reg = onenand_read_fact_prot_reg;
+	mtd->get_user_prot_info = onenand_get_user_prot_info;
+	mtd->read_user_prot_reg = onenand_read_user_prot_reg;
+	mtd->write_user_prot_reg = onenand_write_user_prot_reg;
+	mtd->lock_user_prot_reg = onenand_lock_user_prot_reg;
+#endif
+	mtd->sync = onenand_sync;
+	mtd->lock = onenand_lock;
+	mtd->unlock = onenand_unlock;
+	mtd->suspend = onenand_suspend;
+	mtd->resume = onenand_resume;
+	mtd->block_isbad = onenand_block_isbad;
+	mtd->block_markbad = onenand_block_markbad;
+	mtd->owner = THIS_MODULE;
+
+	/* Unlock whole block */
+	onenand_unlock_all(mtd);
 
-free_bbm:
-	free_pxa3xx_bbm(pxa3xx_bbm);
-out:
-	return -EINVAL;
+	return this->scan_bbt(mtd);
 }
 
 /**
@@ -2068,8 +2824,31 @@ out:
  */
 void onenand_release(struct mtd_info *mtd)
 {
-	if (pxa3xx_bbm && pxa3xx_bbm->uninit) {
-		pxa3xx_bbm->uninit(mtd, pxa3xx_bbm);
-		free_pxa3xx_bbm(pxa3xx_bbm);
+	struct onenand_chip *this = mtd->priv;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/* Deregister partitions */
+	del_mtd_partitions (mtd);
+#endif
+	/* Deregister the device */
+	del_mtd_device (mtd);
+
+	/* Free bad block table memory, if allocated */
+	if (this->bbm) {
+		struct bbm_info *bbm = this->bbm;
+		kfree(bbm->bbt);
+		kfree(this->bbm);
 	}
+	/* Buffers allocated by onenand_scan */
+	if (this->options & ONENAND_PAGEBUF_ALLOC)
+		kfree(this->page_buf);
+	if (this->options & ONENAND_OOBBUF_ALLOC)
+		kfree(this->oob_buf);
 }
+
+EXPORT_SYMBOL_GPL(onenand_scan);
+EXPORT_SYMBOL_GPL(onenand_release);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kyungmin Park <kyungmin.park@samsung.com>");
+MODULE_DESCRIPTION("Generic OneNAND flash driver code");
diff --git a/include/asm-arm/arch-pxa168/common.h b/include/asm-arm/arch-pxa168/common.h
index 73203b5..55293d0 100644
--- a/include/asm-arm/arch-pxa168/common.h
+++ b/include/asm-arm/arch-pxa168/common.h
@@ -5,9 +5,6 @@
 #include <asm/io.h>
 #include <linux/types.h>
 #include <linux/err.h>
-#include <linux/mtd/compat.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
 
 #define __initdata
 #define __exit
@@ -49,7 +46,6 @@
 #define BU_REG_WRITE(x,y) ((*(volatile BU_U32 *)(x)) = y )
 
 typedef int wait_queue_head_t; 
-typedef int onenand_state_t;
 typedef int irqreturn_t;
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 typedef u32 resource_size_t;
@@ -81,7 +77,7 @@ static inline int __decalare_return(void)
 #define init_waitqueue_head(...)
 #define THIS_MODULE		0
 #define wait_for_completion(...)
-#define add_mtd_partitions(...)	0
+#define add_mtd_partitions(...)
 
 #define platform_get_irq(...)	0
 #define request_mem_region(x,y,z)	(container_of(x, struct resource, start))
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index 4896f7d..db2f96f 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -20,22 +20,7 @@
 #define MTD_ERASE_DONE          0x08
 #define MTD_ERASE_FAILED        0x10
 
-/*
- * Enumeration for NAND/OneNAND flash chip state
- */
-enum {
-	FL_READY,
-	FL_READING,
-	FL_WRITING,
-	FL_ERASING,
-	FL_SYNCING,
-	FL_CACHEDPRG,
-	FL_RESETING,
-	FL_UNLOCKING,
-	FL_LOCKING,
-	FL_PM_SUSPENDED,
-};
-
+#define MTD_FAIL_ADDR_UNKNOWN 0xffffffff
 /* If the erase fails, fail_addr might indicate exactly which block failed.  If
    fail_addr = 0xffffffff, the failure was not at the device level or was not
    specific to any particular block. */
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 24ad2bd..905d866 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -215,6 +215,20 @@ typedef enum {
 #define NAND_CI_CHIPNR_MSK	0x03
 #define NAND_CI_CELLTYPE_MSK	0x0C
 
+/*
+ * nand_state_t - chip states
+ * Enumeration for NAND flash chip state
+ */
+typedef enum {
+	FL_READY,
+	FL_READING,
+	FL_WRITING,
+	FL_ERASING,
+	FL_SYNCING,
+	FL_CACHEDPRG,
+	FL_PM_SUSPENDED,
+} nand_state_t;
+
 /* Keep gcc happy */
 struct nand_chip;
 
diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 4467c2b..6ef4824 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -13,98 +13,127 @@
 #define __LINUX_MTD_ONENAND_H
 
 #include <linux/mtd/onenand_regs.h>
-
-/* Note: The header order is impoertant */
-#include <onenand_uboot.h>
-
-#include <linux/mtd/compat.h>
 #include <linux/mtd/bbm.h>
+#include <onenand_uboot.h>
+#include <asm/arch-pxa168/common.h>
 
 #define MAX_BUFFERRAM		2
-#define MAX_ONENAND_PAGESIZE	(2048 + 64)
+#define MAX_ONENAND_PAGESIZE   (2048 + 64)
 
 /* Scan and identify a OneNAND device */
-extern int onenand_scan (struct mtd_info *mtd, int max_chips);
+extern int onenand_scan(struct mtd_info *mtd, int max_chips);
 /* Free resources held by the OneNAND device */
-extern void onenand_release (struct mtd_info *mtd);
+extern void onenand_release(struct mtd_info *mtd);
+
+/*
+ * onenand_state_t - chip states
+ * Enumeration for OneNAND flash chip state
+ */
+typedef enum {
+	FL_READY,
+	FL_READING,
+	FL_WRITING,
+	FL_ERASING,
+	FL_SYNCING,
+	FL_LOCKING,
+	FL_RESETING,
+	FL_OTPING,
+	FL_PM_SUSPENDED,
+} onenand_state_t;
 
 /**
  * struct onenand_bufferram - OneNAND BufferRAM Data
- * @param block		block address in BufferRAM
- * @param page		page address in BufferRAM
- * @param valid		valid flag
+ * @blockpage:		block & page address in BufferRAM
  */
 struct onenand_bufferram {
-	int block;
-	int page;
-	int valid;
+	int	blockpage;
 };
 
 /**
  * struct onenand_chip - OneNAND Private Flash Chip Data
- * @param base		[BOARDSPECIFIC] address to access OneNAND
- * @param chipsize	[INTERN] the size of one chip for multichip arrays
- * @param device_id	[INTERN] device ID
- * @param verstion_id	[INTERN] version ID
- * @param options	[BOARDSPECIFIC] various chip options. They can partly be set to inform onenand_scan about
- * @param erase_shift	[INTERN] number of address bits in a block
- * @param page_shift	[INTERN] number of address bits in a page
- * @param ppb_shift	[INTERN] number of address bits in a pages per block
- * @param page_mask	[INTERN] a page per block mask
- * @param writesize	[INTERN] a real page size
- * @param bufferam_index	[INTERN] BufferRAM index
- * @param bufferam	[INTERN] BufferRAM info
- * @param readw		[REPLACEABLE] hardware specific function for read short
- * @param writew	[REPLACEABLE] hardware specific function for write short
- * @param command	[REPLACEABLE] hardware specific function for writing commands to the chip
- * @param wait		[REPLACEABLE] hardware specific function for wait on ready
- * @param read_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
- * @param write_bufferram	[REPLACEABLE] hardware specific function for BufferRAM Area
- * @param chip_lock	[INTERN] spinlock used to protect access to this structure and the chip
- * @param wq		[INTERN] wait queue to sleep on if a OneNAND operation is in progress
- * @param state		[INTERN] the current state of the OneNAND device
- * @param autooob	[REPLACEABLE] the default (auto)placement scheme
- * @param priv		[OPTIONAL] pointer to private chip date
+ * @base:		[BOARDSPECIFIC] address to access OneNAND
+ * @chipsize:		[INTERN] the size of one chip for multichip arrays
+ * @device_id:		[INTERN] device ID
+ * @density_mask:	chip density, used for DDP devices
+ * @verstion_id:	[INTERN] version ID
+ * @options:		[BOARDSPECIFIC] various chip options. They can
+ *			partly be set to inform onenand_scan about
+ * @erase_shift:	[INTERN] number of address bits in a block
+ * @page_shift:		[INTERN] number of address bits in a page
+ * @page_mask:		[INTERN] a page per block mask
+ * @writesize:		[INTERN] a real page size
+ * @bufferram_index:	[INTERN] BufferRAM index
+ * @bufferram:		[INTERN] BufferRAM info
+ * @readw:		[REPLACEABLE] hardware specific function for read short
+ * @writew:		[REPLACEABLE] hardware specific function for write short
+ * @command:		[REPLACEABLE] hardware specific function for writing
+ *			commands to the chip
+ * @wait:		[REPLACEABLE] hardware specific function for wait on ready
+ * @read_bufferram:	[REPLACEABLE] hardware specific function for BufferRAM Area
+ * @write_bufferram:	[REPLACEABLE] hardware specific function for BufferRAM Area
+ * @read_word:		[REPLACEABLE] hardware specific function for read
+ *			register of OneNAND
+ * @write_word:		[REPLACEABLE] hardware specific function for write
+ *			register of OneNAND
+ * @mmcontrol:		sync burst read function
+ * @block_markbad:	function to mark a block as bad
+ * @scan_bbt:		[REPLACEALBE] hardware specific function for scanning
+ *			Bad block Table
+ * @chip_lock:		[INTERN] spinlock used to protect access to this
+ *			structure and the chip
+ * @wq:			[INTERN] wait queue to sleep on if a OneNAND
+ *			operation is in progress
+ * @state:		[INTERN] the current state of the OneNAND device
+ * @page_buf:		[INTERN] page main data buffer
+ * @oob_buf:		[INTERN] page oob data buffer
+ * @subpagesize:	[INTERN] holds the subpagesize
+ * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
+ * @bbm:		[REPLACEABLE] pointer to Bad Block Management
+ * @priv:		[OPTIONAL] pointer to private chip date
  */
 struct onenand_chip {
-	void __iomem *base;
-	unsigned int chipsize;
-	unsigned int device_id;
-	unsigned int options;
-
-	unsigned int erase_shift;
-	unsigned int page_shift;
-	unsigned int ppb_shift;	/* Pages per block shift */
-	unsigned int page_mask;
-	unsigned int writesize;
-
-	unsigned int bufferram_index;
-	struct onenand_bufferram bufferram[MAX_BUFFERRAM];
-
-	int (*command) (struct mtd_info * mtd, int cmd, loff_t address,
-			size_t len);
-	int (*wait) (struct mtd_info * mtd, int state);
-	int (*read_bufferram) (struct mtd_info * mtd, int area,
-			       unsigned char *buffer, int offset, size_t count);
-	int (*write_bufferram) (struct mtd_info * mtd, int area,
-				const unsigned char *buffer, int offset,
-				size_t count);
-	unsigned short (*read_word) (void __iomem * addr);
-	void (*write_word) (unsigned short value, void __iomem * addr);
-	void (*mmcontrol) (struct mtd_info * mtd, int sync_read);
+	void __iomem		*base;
+	unsigned int		chipsize;
+	unsigned int		device_id;
+	unsigned int		version_id;
+	unsigned int		density_mask;
+	unsigned int		options;
+
+	unsigned int		erase_shift;
+	unsigned int		page_shift;
+	unsigned int		page_mask;
+	unsigned int		writesize;
+
+	unsigned int		bufferram_index;
+	struct onenand_bufferram	bufferram[MAX_BUFFERRAM];
+
+	int (*command)(struct mtd_info *mtd, int cmd, loff_t address, size_t len);
+	int (*wait)(struct mtd_info *mtd, int state);
+	int (*read_bufferram)(struct mtd_info *mtd, int area,
+			unsigned char *buffer, int offset, size_t count);
+	int (*write_bufferram)(struct mtd_info *mtd, int area,
+			const unsigned char *buffer, int offset, size_t count);
+	unsigned short (*read_word)(void __iomem *addr);
+	void (*write_word)(unsigned short value, void __iomem *addr);
+	void (*mmcontrol)(struct mtd_info *mtd, int sync_read);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	int (*scan_bbt)(struct mtd_info *mtd);
 
-	int state;
-	unsigned char *page_buf;
-	unsigned char *oob_buf;
+	struct completion	complete;
+	int			irq;
+
+	spinlock_t		chip_lock;
+	wait_queue_head_t	wq;
+	onenand_state_t		state;
+	unsigned char		*page_buf;
+	unsigned char		*oob_buf;
 
-	struct nand_oobinfo *autooob;
-	struct nand_ecclayout *ecclayout;
+	int			subpagesize;
+	struct nand_ecclayout	*ecclayout;
 
-	void *bbm;
+	void			*bbm;
 
-	void *priv;
+	void			*priv;
 };
 
 /*
@@ -117,15 +146,30 @@ struct onenand_chip {
 #define ONENAND_SET_BUFFERRAM0(this)		(this->bufferram_index = 0)
 #define ONENAND_SET_BUFFERRAM1(this)		(this->bufferram_index = 1)
 
+#define ONENAND_GET_SYS_CFG1(this)					\
+	(this->read_word(this->base + ONENAND_REG_SYS_CFG1))
+#define ONENAND_SET_SYS_CFG1(v, this)					\
+	(this->write_word(v, this->base + ONENAND_REG_SYS_CFG1))
+
 #define ONENAND_IS_DDP(this)						\
 	(this->device_id & ONENAND_DEVICE_IS_DDP)
 
+#ifdef CONFIG_MTD_ONENAND_2X_PROGRAM
+#define ONENAND_IS_2PLANE(this)						\
+	(this->options & ONENAND_HAS_2PLANE)
+#else
 #define ONENAND_IS_2PLANE(this)			(0)
+#endif
+
+/* Check byte access in OneNAND */
+#define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
 
 /*
  * Options bits
  */
-#define ONENAND_CONT_LOCK		(0x0001)
+#define ONENAND_HAS_CONT_LOCK		(0x0001)
+#define ONENAND_HAS_UNLOCK_ALL		(0x0002)
+#define ONENAND_HAS_2PLANE		(0x0004)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
 
@@ -133,19 +177,18 @@ struct onenand_chip {
  * OneNAND Flash Manufacturer ID Codes
  */
 #define ONENAND_MFR_SAMSUNG	0xec
-#define ONENAND_MFR_UNKNOWN	0x00
 
 /**
- * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
- * @param name:		Manufacturer name
- * @param id:		manufacturer ID code of device.
+ * struct onenand_manufacturers - NAND Flash Manufacturer ID Structure
+ * @name:	Manufacturer name
+ * @id:		manufacturer ID code of device.
 */
 struct onenand_manufacturers {
-	int id;
-	char *name;
+        int id;
+        char *name;
 };
 
 int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
-			struct mtd_oob_ops *ops);
+			 struct mtd_oob_ops *ops);
 
-#endif				/* __LINUX_MTD_ONENAND_H */
+#endif	/* __LINUX_MTD_ONENAND_H */
diff --git a/include/linux/mtd/onenand_regs.h b/include/linux/mtd/onenand_regs.h
index a245e14..0c6bbe2 100644
--- a/include/linux/mtd/onenand_regs.h
+++ b/include/linux/mtd/onenand_regs.h
@@ -84,7 +84,7 @@
 #define ONENAND_VERSION_PROCESS_SHIFT	(8)
 
 /*
- * Start Address 1 F100h (R/W)
+ * Start Address 1 F100h (R/W) & Start Address 2 F101h (R/W)
  */
 #define ONENAND_DDP_SHIFT		(15)
 #define ONENAND_DDP_CHIP0		(0)
@@ -119,8 +119,10 @@
 #define ONENAND_CMD_UNLOCK		(0x23)
 #define ONENAND_CMD_LOCK		(0x2A)
 #define ONENAND_CMD_LOCK_TIGHT		(0x2C)
+#define ONENAND_CMD_UNLOCK_ALL		(0x27)
 #define ONENAND_CMD_ERASE		(0x94)
 #define ONENAND_CMD_RESET		(0xF0)
+#define ONENAND_CMD_OTP_ACCESS		(0x65)
 #define ONENAND_CMD_READID		(0x90)
 
 /* NOTE: Those are not *REAL* commands */
@@ -150,6 +152,8 @@
 #define ONENAND_SYS_CFG1_INT		(1 << 6)
 #define ONENAND_SYS_CFG1_IOBE		(1 << 5)
 #define ONENAND_SYS_CFG1_RDY_CONF	(1 << 4)
+#define ONENAND_SYS_CFG1_HF		(1 << 2)
+#define ONENAND_SYS_CFG1_SYNC_WRITE	(1 << 1)
 
 /*
  * Controller Status Register F240h (R)
@@ -161,6 +165,8 @@
 #define ONENAND_CTRL_ERASE		(1 << 11)
 #define ONENAND_CTRL_ERROR		(1 << 10)
 #define ONENAND_CTRL_RSTB		(1 << 7)
+#define ONENAND_CTRL_OTP_L		(1 << 6)
+#define ONENAND_CTRL_OTP_BL		(1 << 5)
 
 /*
  * Interrupt Status Register F241h (R)
@@ -183,7 +189,13 @@
  * ECC Status Reigser FF00h (R)
  */
 #define ONENAND_ECC_1BIT		(1 << 0)
+#define ONENAND_ECC_1BIT_ALL		(0x5555)
 #define ONENAND_ECC_2BIT		(1 << 1)
 #define ONENAND_ECC_2BIT_ALL		(0xAAAA)
 
-#endif				/* __ONENAND_REG_H */
+/*
+ * One-Time Programmable (OTP)
+ */
+#define ONENAND_OTP_LOCK_OFFSET		(14)
+
+#endif	/* __ONENAND_REG_H */
diff --git a/include/onenand_uboot.h b/include/onenand_uboot.h
index 3979280..bc7c6de 100644
--- a/include/onenand_uboot.h
+++ b/include/onenand_uboot.h
@@ -36,6 +36,6 @@ extern int onenand_erase(struct mtd_info *mtd, struct erase_info *instr);
 
 extern int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
 
-extern char *onenand_print_device_info(int device);
+extern void onenand_print_device_info(int device, int version);
 
 #endif /* __UBOOT_ONENAND_H */
-- 
1.6.0.4

