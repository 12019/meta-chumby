From 33079d358c1ec1fd436b62dee3952eb4fece604b Mon Sep 17 00:00:00 2001
From: Wen Lei <leiwen@marvell.com>
Date: Fri, 27 Feb 2009 10:26:24 +0800
Subject: [PATCH] pxa910: add usb over ethernet download support

---
 board/pxa/common/Makefile                |   14 +
 board/pxa/common/usbeth/Makefile         |   61 +
 board/pxa/common/usbeth/ether-mvu2o.c    |  315 +++++
 board/pxa/common/usbeth/mvUsbCh9.h       |  125 ++
 board/pxa/common/usbeth/mvUsbCore.h      |  757 ++++++++++++
 board/pxa/common/usbeth/mvUsbDebug.h     |  112 ++
 board/pxa/common/usbeth/mvUsbDefs.h      |  140 +++
 board/pxa/common/usbeth/mvUsbDesc.h      |  163 +++
 board/pxa/common/usbeth/mvUsbDevApi.h    |  161 +++
 board/pxa/common/usbeth/mvUsbDevCh9.c    |  340 +++++
 board/pxa/common/usbeth/mvUsbDevMain.c   |  770 ++++++++++++
 board/pxa/common/usbeth/mvUsbDevPrv.h    |  270 ++++
 board/pxa/common/usbeth/mvUsbDevRecv.c   |  100 ++
 board/pxa/common/usbeth/mvUsbDevSend.c   |  373 ++++++
 board/pxa/common/usbeth/mvUsbDevUtl.c    |  651 ++++++++++
 board/pxa/common/usbeth/mvUsbHsDevCncl.c |  225 ++++
 board/pxa/common/usbeth/mvUsbHsDevMain.c | 1990 ++++++++++++++++++++++++++++++
 board/pxa/common/usbeth/mvUsbHsDevUtl.c  |  272 ++++
 board/pxa/common/usbeth/mvUsbTypes.h     |  240 ++++
 board/pxa/common/usbeth/mv_u2o_api.c     |  689 +++++++++++
 board/pxa/common/usbeth/mv_u2o_api.h     |   49 +
 board/pxa/common/usbeth/mv_u2o_ctl.c     |  746 +++++++++++
 board/pxa/common/usbeth/mv_u2o_ctl.h     |  404 ++++++
 board/pxa/common/usbeth/mv_u2o_ep0.c     |  418 +++++++
 board/pxa/common/usbeth/mv_u2o_ep1.c     |  206 +++
 board/pxa/common/usbeth/mv_u2o_ep2.c     |  147 +++
 board/pxa/common/usbeth/pxa_usb.h        |  266 ++++
 include/configs/tavorevb.h               |    1 +
 net/eth.c                                |    8 +
 29 files changed, 10013 insertions(+), 0 deletions(-)
 create mode 100644 board/pxa/common/usbeth/Makefile
 create mode 100644 board/pxa/common/usbeth/ether-mvu2o.c
 create mode 100644 board/pxa/common/usbeth/mvUsbCh9.h
 create mode 100644 board/pxa/common/usbeth/mvUsbCore.h
 create mode 100644 board/pxa/common/usbeth/mvUsbDebug.h
 create mode 100644 board/pxa/common/usbeth/mvUsbDefs.h
 create mode 100644 board/pxa/common/usbeth/mvUsbDesc.h
 create mode 100644 board/pxa/common/usbeth/mvUsbDevApi.h
 create mode 100644 board/pxa/common/usbeth/mvUsbDevCh9.c
 create mode 100644 board/pxa/common/usbeth/mvUsbDevMain.c
 create mode 100644 board/pxa/common/usbeth/mvUsbDevPrv.h
 create mode 100644 board/pxa/common/usbeth/mvUsbDevRecv.c
 create mode 100644 board/pxa/common/usbeth/mvUsbDevSend.c
 create mode 100644 board/pxa/common/usbeth/mvUsbDevUtl.c
 create mode 100644 board/pxa/common/usbeth/mvUsbHsDevCncl.c
 create mode 100644 board/pxa/common/usbeth/mvUsbHsDevMain.c
 create mode 100644 board/pxa/common/usbeth/mvUsbHsDevUtl.c
 create mode 100644 board/pxa/common/usbeth/mvUsbTypes.h
 create mode 100644 board/pxa/common/usbeth/mv_u2o_api.c
 create mode 100644 board/pxa/common/usbeth/mv_u2o_api.h
 create mode 100644 board/pxa/common/usbeth/mv_u2o_ctl.c
 create mode 100644 board/pxa/common/usbeth/mv_u2o_ctl.h
 create mode 100644 board/pxa/common/usbeth/mv_u2o_ep0.c
 create mode 100644 board/pxa/common/usbeth/mv_u2o_ep1.c
 create mode 100644 board/pxa/common/usbeth/mv_u2o_ep2.c
 create mode 100644 board/pxa/common/usbeth/pxa_usb.h

diff --git a/board/pxa/common/Makefile b/board/pxa/common/Makefile
index 0d3cc79..4d7a97a 100644
--- a/board/pxa/common/Makefile
+++ b/board/pxa/common/Makefile
@@ -31,6 +31,20 @@ LIB	= $(obj)lib$(VENDOR).a
 
 COBJS-y				+= boot.o
 COBJS-${CONFIG_CMD_NAND}	+= nand.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/ether-mvu2o.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mv_u2o_ctl.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mv_u2o_ep0.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mv_u2o_ep1.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mv_u2o_ep2.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mv_u2o_api.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbDevCh9.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbDevMain.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbDevRecv.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbDevSend.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbDevUtl.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbHsDevCncl.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbHsDevMain.o
+COBJS-${CONFIG_USB_ETH}		+= usbeth/mvUsbHsDevUtl.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS-y))
diff --git a/board/pxa/common/usbeth/Makefile b/board/pxa/common/usbeth/Makefile
new file mode 100644
index 0000000..afefe87
--- /dev/null
+++ b/board/pxa/common/usbeth/Makefile
@@ -0,0 +1,61 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libusbeth.a
+
+ifdef CONFIG_USB_ETH
+COBJS-y += ether-mvu2o.o
+COBJS-y += mv_u2o_ctl.o
+COBJS-y += mv_u2o_ep0.o
+COBJS-y += mv_u2o_ep1.o
+COBJS-y += mv_u2o_ep2.o
+COBJS-y += mv_u2o_api.o
+COBJS-y += mvUsbDevCh9.o
+COBJS-y += mvUsbDevMain.o
+COBJS-y += mvUsbDevRecv.o
+COBJS-y += mvUsbDevSend.o
+COBJS-y += mvUsbDevUtl.o
+COBJS-y += mvUsbHsDevCncl.o
+COBJS-y += mvUsbHsDevMain.o
+COBJS-y += mvUsbHsDevUtl.o
+endif
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/pxa/common/usbeth/ether-mvu2o.c b/board/pxa/common/usbeth/ether-mvu2o.c
new file mode 100644
index 0000000..e394d85
--- /dev/null
+++ b/board/pxa/common/usbeth/ether-mvu2o.c
@@ -0,0 +1,315 @@
+/*
+ *  ether-pxausb.c : "eth-over-usb" driver for BLOB
+ *
+ *  Copyright (c) 2003, Intel Corporation (yu.tang@intel.com)
+ *
+ * (C) Copyright 2006 Marvell International Ltd.  
+ * All Rights Reserved 
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+//#define DEBUG
+#ifdef   CONFIG_TAVOREVB
+#include <configs/tavorevb.h>
+#endif
+#ifdef	 CONFIG_ZYLONIT2
+#include <configs/zylonite2.h>
+#endif
+
+#include <linux/types.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <common.h>
+#include <config.h>
+#include <net.h>
+#include <command.h>
+#include <malloc.h>
+
+#include "pxa_usb.h"
+#include "mv_u2o_ctl.h"
+
+static int usb_rsize=64;
+static int usb_wsize=64;
+
+/* cable connection */
+extern int usb_connected;
+extern int usb_speed;
+
+/* receive buffer management */
+static char rx_buf[2][ETH_BUF_SIZE];
+static int  rx_size = 0;
+static int  rx_done = 0 ;
+static u16 rxIdx;		/* index of the current RX buffer */
+
+/* transmit buffer management */
+static int tx_done = 0 ;
+
+u16 usb_vendor_id = 0x8086;
+u16 usb_product_id = 0x07d3;
+
+extern void u2o_start(void);
+
+static void usb_eth_tx_callback(int flag, int size)
+{
+	tx_done = 1;
+}
+
+static void usb_eth_rx_callback(int flag, int size)
+{
+	int left, i;
+
+#ifdef DEBUG
+	printf("%s flag %d size %d left %d rx_done %d rx_size %d\n", 
+		__func__, flag, size, left, rx_done, rx_size); 
+#endif
+
+	if( flag != 0 ) {
+		//printf("%s, flag = %d\n", __FUNCTION__, flag);
+		return;
+	}
+
+	if (rx_done) { 
+		/* printf("overwrite\n"); */
+		/* drop */
+		rx_done = 0;
+		rx_size = 0;
+	}
+
+	memcpy(rx_buf[0], rx_buf[1], size);
+	rx_size += size;
+
+done:
+	rx_done = 1;
+
+#ifdef DEBUG
+	printf(" ----------------- rx ------------------\n");
+	for (i=0; i<8; i++)
+		printf(" %x", rx_buf[0][i]);
+		
+	printf("\n");
+#endif
+	NetReceive(rx_buf[0], size);
+
+	/* setup to receive */
+	ep2_recv(rx_buf[1], ETH_BUF_SIZE, usb_eth_rx_callback);
+
+	return;
+}
+
+void usb_driver_speed(int speed)
+{
+	desc_t * pdesc = pxa_usb_get_descriptor_ptr();
+	config_desc_t *cfg;
+	intf_desc_t *intf;
+	ep_desc_t *ep;
+
+	cfg = (config_desc_t*) (pdesc->cdb);
+	intf = (config_desc_t *)(cfg + 1);
+	ep = (ep_desc_t *) (intf + 1);
+	
+	if( speed == USB_SPEED_HIGH ){
+		ep[0].wMaxPacketSize      = make_word( 512 );
+		ep[1].wMaxPacketSize      = make_word( 512 );
+	} else {
+		ep[0].wMaxPacketSize      = make_word( 64 );
+		ep[1].wMaxPacketSize      = make_word( 64 );
+	}
+}
+
+void usb_driver_reset(void)
+{
+	desc_t * pdesc = pxa_usb_get_descriptor_ptr();
+	config_desc_t *cfg;
+	intf_desc_t *intf;
+	ep_desc_t *ep;
+
+	/* setup device descriptor */
+	pdesc->dev.idVendor	= usb_vendor_id;
+	pdesc->dev.idProduct    = usb_product_id;
+	pdesc->dev.bNumConfigurations = 1;
+
+	cfg = (config_desc_t*) (pdesc->cdb);
+
+	cfg->bLength             = sizeof( config_desc_t );
+	cfg->bDescriptorType     = USB_DESC_CONFIG;
+	cfg->wTotalLength        = make_word_c( sizeof(config_desc_t) +
+						   sizeof(intf_desc_t) * 1+
+						   sizeof(ep_desc_t) * 2);
+	cfg->bNumInterfaces      = 1;
+	cfg->bConfigurationValue = 1;
+	cfg->iConfiguration      = 0;
+	cfg->bmAttributes        = USB_CONFIG_BUSPOWERED;
+	cfg->MaxPower            = USB_POWER( 500 );
+
+	intf = (intf_desc_t *) ( cfg + 1);
+	intf->bLength            = sizeof( intf_desc_t );
+	intf->bDescriptorType    = USB_DESC_INTERFACE;
+	intf->bInterfaceNumber   = 0; 
+	intf->bAlternateSetting  = 0;
+	intf->bNumEndpoints      = 2;
+	intf->bInterfaceClass    = 0xFF; 
+	intf->bInterfaceSubClass = 0;
+	intf->bInterfaceProtocol = 0;
+	intf->iInterface         = 0;
+
+	ep = (ep_desc_t *) (intf + 1);
+	ep[0].bLength             = sizeof( ep_desc_t );
+	ep[0].bDescriptorType     = USB_DESC_ENDPOINT;
+	ep[0].bEndpointAddress    = USB_EP_ADDRESS( 1, USB_IN );
+	ep[0].bmAttributes        = USB_EP_BULK;
+	if( usb_speed == USB_SPEED_HIGH )
+		ep[0].wMaxPacketSize      = make_word( 512 );
+	else
+		ep[0].wMaxPacketSize      = make_word( 64 );
+	ep[0].bInterval           = 0;
+
+	ep[1].bLength             = sizeof( ep_desc_t );
+	ep[1].bDescriptorType     = USB_DESC_ENDPOINT;
+	ep[1].bEndpointAddress    = USB_EP_ADDRESS( 1, USB_OUT );
+	ep[1].bmAttributes        = USB_EP_BULK;
+	if( usb_speed == USB_SPEED_HIGH )
+		ep[1].wMaxPacketSize      = make_word( 512 );
+	else
+		ep[1].wMaxPacketSize      = make_word( 64 );
+	ep[1].bInterval           = 0;
+
+	/* reset buffer */
+	rx_done = 0;
+	rx_size = 0;
+
+}
+
+void ep2_begin(void)
+{
+	/* setup to receive */
+	if(usb_connected) {
+		ep2_recv(rx_buf[1], ETH_BUF_SIZE, usb_eth_rx_callback);
+	}
+}
+
+static inline int check_usb_connection(void)
+{
+	unsigned int cnt = 0;
+
+	if (usb_connected) return 0;
+	else 
+		u2o_start();
+
+	/* waiting util connected */
+	printf("***** Plug-in USB cable & config usbdnet now ****** \n");
+	
+	while (!usb_connected) {
+		//if ( __raw_readl(ICU_INT_STATUS_1) & (1<<(44-32)) ) {
+			u2o_int_hndlr(0x11, 0);
+		//}
+	}
+
+	while ( cnt < 0x1000) {
+		//if ( __raw_readl(ICU_INT_STATUS_1) & (1<<(44-32)) ) {
+			u2o_int_hndlr(0x11, 0);
+		//	cnt = 0;
+		//}
+		cnt ++;
+	}
+
+	printf("exit check_usb_connection:%d\n", usb_connected);
+	return 0;
+}
+
+static int usb_eth_init(struct eth_device *dev, bd_t *bd)
+{
+	printf("%s\n\n", __func__);
+}
+
+static int usb_eth_halt(struct eth_device *dev, bd_t *bd)
+{
+	printf("%s\n\n", __func__);
+}
+static int loop=0;
+
+extern int req_pending;
+void dump_buffer(char *buf, unsigned length);
+
+static int usb_eth_rx(struct eth_device *dev)
+{
+	int i=1000000;
+
+	if(!usb_connected)check_usb_connection();
+
+	do{
+		//if ( __raw_readl(ICU_INT_STATUS_1) & (1<<(44-32)) ) {
+			u2o_int_hndlr(0x11, 0);
+		//	i=0;
+		//}
+
+		DELAY(1);
+		if(rx_done) break;
+		i--;
+	}while (!rx_done && (i>0));
+
+//	memcpy(inbuf, rx_buf, rx_size);
+
+	rx_done = 0;
+	rx_size = 0;
+
+	return rx_size;
+}
+
+static int usb_eth_tx(struct eth_device *dev, volatile void *packet,
+			  int length)
+{
+	int i,tx_size = length;
+	int retry = 3, ret;
+
+	check_usb_connection();
+
+	tx_done = 0;
+	do {
+		ret = ep1_send(packet, length, usb_eth_tx_callback);
+	
+		i = 10000;
+		do {
+			u2o_int_hndlr();
+			DELAY(1);
+			i--;
+		} while (!tx_done && (i>0));
+
+		if (!ret) break;
+		printf("%s ret %d retry %d\n", __func__, ret, retry);
+
+	} while (retry--);
+
+	return tx_size;
+}
+
+int u2o_eth_initialize(u32 base)
+{
+	struct eth_device *dev;
+	dev = (struct eth_device *)malloc(sizeof(*dev));
+
+	if (dev == NULL)
+		hang();
+
+
+	memset(dev, 0, sizeof(*dev));
+	sprintf(dev->name, "u2o-eth");
+
+	dev->iobase = 0;
+	dev->priv = 0;
+	dev->init = usb_eth_init;
+	dev->halt = usb_eth_halt;
+	dev->send = usb_eth_tx;
+	dev->recv = usb_eth_rx;
+
+	eth_register(dev);
+
+	usb_connected = 0;
+
+	pxa_usb_open("u2o-eth");
+	pxa_usb_start();
+	return 1;
+}
+
diff --git a/board/pxa/common/usbeth/mvUsbCh9.h b/board/pxa/common/usbeth/mvUsbCh9.h
new file mode 100644
index 0000000..c513877
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbCh9.h
@@ -0,0 +1,125 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbCh9_h__
+#define __mvUsbCh9_h__
+
+#include "mvUsbTypes.h"
+/*----------------------------------------------------------------**
+** Chapter 9.4 Standard Device Requests -- all devices            **
+** See Table 9-3 p. 250 of USB 2.0 spec for combinations          **
+**   of request type bitfields with requests, WVALUE, WINDEX etc. **
+**----------------------------------------------------------------*/
+#define REQ_RECIP_MASK          0x1f
+#define REQ_RECIP_DEVICE        0x00
+#define REQ_RECIP_INTERFACE     0x01
+#define REQ_RECIP_ENDPOINT      0x02
+#define REQ_RECIP_OTHER         0x03
+
+/* Also for class requests set the following bit */
+#define REQ_TYPE_OFFSET         5
+#define REQ_TYPE_MASK			(0x03 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_STANDARD		(0x00 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_CLASS			(0x01 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_VENDOR			(0x02 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_RESERVED		(0x03 << REQ_TYPE_OFFSET)
+
+/* Combine one of the 3 above with one of the following 2 */
+#define REQ_DIR_OFFSET         7
+#define REQ_DIR_IN             (1 << REQ_DIR_OFFSET)
+#define REQ_DIR_OUT            (0 << REQ_DIR_OFFSET)
+
+/* Standard USB requests, see Chapter 9 */
+#define REQ_GET_STATUS          0
+#define REQ_CLEAR_FEATURE       1
+#define REQ_SET_FEATURE         3
+#define REQ_SET_ADDRESS         5
+#define REQ_GET_DESCRIPTOR      6
+#define REQ_SET_DESCRIPTOR      7
+#define REQ_GET_CONFIGURATION   8
+#define REQ_SET_CONFIGURATION   9
+#define REQ_GET_INTERFACE       10
+#define REQ_SET_INTERFACE       11
+#define REQ_SYNCH_FRAME         12
+
+#define DESC_TYPE_DEVICE         0x1
+#define DESC_TYPE_CONFIG         0x2
+#define DESC_TYPE_STRING         0x3
+#define DESC_TYPE_INTERFACE      0x4
+#define DESC_TYPE_ENDPOINT       0x5
+#define DESC_TYPE_QUALIFIER      0x6
+#define DESC_TYPE_OTHER_SPEED    0x7
+#define DESC_TYPE_INTF_POWER     0x8
+#define DESC_TYPE_OTG            0x9
+
+/*******************************************************************
+**
+** Values specific to CLEAR FEATURE commands (must go to common.h later)
+*/
+
+#define  ENDPOINT_HALT          0
+#define  DEVICE_SELF_POWERED    0
+#define  DEVICE_REMOTE_WAKEUP   1
+#define  DEVICE_TEST_MODE       2
+
+
+/* States of device instances on the device list */
+
+/* initial device state */
+#define  DEVSTATE_INITIAL        0x00
+
+/* device descriptor [0..7]*/
+#define  DEVSTATE_DEVDESC8       0x01
+
+/* address set */
+#define  DEVSTATE_ADDR_SET       0x02
+
+/* full device descriptor */
+#define  DEVSTATE_DEV_DESC       0x03
+
+/* config descriptor [0..7] */
+#define  DEVSTATE_GET_CFG9       0x04
+
+/* config set */
+#define  DEVSTATE_SET_CFG        0x05
+
+/* full config desc. read in */
+#define  DEVSTATE_CFG_READ       0x06
+
+/* application callbacks */
+#define  DEVSTATE_APP_CALL       0x07
+
+/* Select interface done */
+#define  DEVSTATE_SET_INTF       0x08
+
+#define  DEVSTATE_ENUM_OK        0x09
+
+#define  DEVSTATE_CHK_OTG        0x0A
+
+/* Event codes for attach/detach etc. callback */
+#define  USB_ATTACH_EVENT        1   /* device attach */
+#define  USB_DETACH_EVENT        2   /* device detach */
+#define  USB_CONFIG_EVENT        3   /* device reconfigured */
+#define  USB_INTF_EVENT          4   /* device interface selected */
+
+#endif /* __mvUsbCh9_h__ */
+
+/* EOF */
+
diff --git a/board/pxa/common/usbeth/mvUsbCore.h b/board/pxa/common/usbeth/mvUsbCore.h
new file mode 100644
index 0000000..056e9d0
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbCore.h
@@ -0,0 +1,757 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbCore_h__
+#define __mvUsbCore_h__
+
+#include "mvUsbTypes.h"
+
+/* VUSBHS specific defines */
+#define  VUSBHS_MAX_PORTS                          (8)
+#define  EHCI_CAP_LEN_MASK                         (0x000000FF)
+#define  EHCI_DATA_STRUCTURE_BASE_ADDRESS          (0)
+
+/* Command Register Bit Masks */
+#define  EHCI_CMD_RUN_STOP                         (0x00000001)
+#define  EHCI_CMD_CTRL_RESET                       (0x00000002)
+#define  EHCI_CMD_SETUP_TRIPWIRE_SET               (0x00002000)
+#define  EHCI_CMD_SETUP_TRIPWIRE_CLEAR             ~EHCI_CMD_SETUP_TRIPWIRE_SET
+
+#define  EHCI_CMD_ATDTW_TRIPWIRE_SET               (0x00004000)
+#define  EHCI_CMD_ATDTW_TRIPWIRE_CLEAR             ~EHCI_CMD_ATDTW_TRIPWIRE_SET
+
+/*bit 15,3,2 are for frame list size */
+#define  EHCI_CMD_FRAME_SIZE_1024                  (0x00000000) /* 000 */
+#define  EHCI_CMD_FRAME_SIZE_512                   (0x00000004) /* 001 */
+#define  EHCI_CMD_FRAME_SIZE_256                   (0x00000008) /* 010 */
+#define  EHCI_CMD_FRAME_SIZE_128                   (0x0000000C) /* 011 */
+#define  EHCI_CMD_FRAME_SIZE_64                    (0x00008000) /* 100 */
+#define  EHCI_CMD_FRAME_SIZE_32                    (0x00008004) /* 101 */
+#define  EHCI_CMD_FRAME_SIZE_16                    (0x00008008) /* 110 */
+#define  EHCI_CMD_FRAME_SIZE_8                     (0x0000800C) /* 111 */
+
+/* Hardware Rev 4.0 related change */                                             
+/* Mode Register Bit Masks */
+#define  VUSBHS_MODE_CTRL_MODE_IDLE                (0x00000000)
+#define  VUSBHS_MODE_CTRL_MODE_DEV                 (0x00000002)
+#define  VUSBHS_MODE_CTRL_MODE_HOST                (0x00000003)
+#define  VUSBHS_MODE_BIG_ENDIAN                    (0x00000004)
+#define  VUSBHS_MODE_SETUP_LOCK_DISABLE            (0x00000008)
+#define  VUSBHS_MODE_STREAM_DISABLE                (0x00000010)
+    
+/* Interrupt Enable Register Bit Masks */
+#define  EHCI_INTR_INT_EN                          (0x00000001)
+#define  EHCI_INTR_ERR_INT_EN                      (0x00000002)
+#define  EHCI_INTR_PORT_CHANGE_DETECT_EN           (0x00000004)
+
+#define  EHCI_INTR_ASYNC_ADV_AAE                   (0x00000020)
+#define  EHCI_INTR_ASYNC_ADV_AAE_ENABLE            (0x00000020) /* | with this to enable */
+#define  EHCI_INTR_ASYNC_ADV_AAE_DISABLE           (0xFFFFFFDF) /* & with this to disable */
+
+#define  EHCI_INTR_RESET_EN                        (0x00000040)
+#define  EHCI_INTR_SOF_UFRAME_EN                   (0x00000080)
+#define  EHCI_INTR_DEVICE_SUSPEND                  (0x00000100)
+
+/* Interrupt Status Register Masks */
+#define  EHCI_STS_SOF                              (0x00000080)
+#define  EHCI_STS_RESET                            (0x00000040)
+#define  EHCI_STS_SEI				   (0x00000010)
+#define  EHCI_STS_PORT_CHANGE                      (0x00000004)
+#define  EHCI_STS_ERR                              (0x00000002)
+#define  EHCI_STS_INT                              (0x00000001)
+#define  EHCI_STS_SUSPEND                          (0x00000100)
+#define  EHCI_STS_HC_HALTED                        (0x00001000)
+
+/* Endpoint Queue Head Bit Masks */
+#define  VUSB_EP_QUEUE_HEAD_IOS                    (0x00008000)
+#define  VUSB_EP_QUEUE_HEAD_IOC                    (0x00008000)
+#define  VUSB_EP_QUEUE_HEAD_INT                    (0x00000100)
+#define  VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE         (0x00000001)
+#define  VUSB_EP_QUEUE_HEAD_MAX_PKT_LEN_POS        (16)
+#define  VUSB_EP_QUEUE_HEAD_ZERO_LEN_TER_SEL       (0x20000000)
+#define  VUSB_EP_QUEUE_HEAD_MULT_POS               (30)
+#define  VUSB_EP_MAX_LENGTH_TRANSFER               (0x4000)
+
+#define  VUSB_EP_QUEUE_HEAD_STATUS_ACTIVE          (0x00000080)
+
+#define  VUSBHS_TD_NEXT_TERMINATE                  (0x00000001)
+#define  VUSBHS_TD_IOC                             (0x00008000)
+#define  VUSBHS_TD_STATUS_ACTIVE                   (0x00000080)
+#define  VUSBHS_TD_STATUS_HALTED                   (0x00000040)
+#define  VUSBHS_TD_RESERVED_FIELDS                 (0x00007F00)
+#define  VUSBHS_TD_ERROR_MASK                      (0x68)
+#define  VUSBHS_TD_ADDR_MASK                       (0xFFFFFFE0)
+#define  VUSBHS_TD_LENGTH_BIT_POS                  (16)
+
+#define  EHCI_EPCTRL_TX_ALL_MASK                   (0xFFFF0000)
+#define  EHCI_EPCTRL_RX_ALL_MASK                   (0x0000FFFF)
+
+#define  EHCI_EPCTRL_TX_DATA_TOGGLE_RST            (0x00400000)
+#define  EHCI_EPCTRL_TX_EP_STALL                   (0x00010000)
+#define  EHCI_EPCTRL_RX_EP_STALL                   (0x00000001)
+#define  EHCI_EPCTRL_RX_DATA_TOGGLE_RST            (0x00000040)
+#define  EHCI_EPCTRL_RX_ENABLE                     (0x00000080)
+#define  EHCI_EPCTRL_TX_ENABLE                     (0x00800000)
+#define  EHCI_EPCTRL_CONTROL                       (0x00000000)
+#define  EHCI_EPCTRL_ISOCHRONOUS                   (0x00040000)
+#define  EHCI_EPCTRL_BULK                          (0x00080000)
+#define  EHCI_EPCTRL_INT                           (0x000C0000)
+#define  EHCI_EPCTRL_TX_TYPE                       (0x000C0000)
+#define  EHCI_EPCTRL_RX_TYPE                       (0x0000000C)
+#define  EHCI_EPCTRL_DATA_TOGGLE_INHIBIT           (0x00000020)
+#define  EHCI_EPCTRL_TX_EP_TYPE_SHIFT              (18)
+#define  EHCI_EPCTRL_RX_EP_TYPE_SHIFT              (2)
+
+/* set bit 24 (PFSC) in PORTSCX register */
+#define  EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT     (0x01000000) 
+/* set bit 23 (PHCD) in PORTSCX register */
+#define  EHCI_PORTSCX_PHY_CLOCK_DISABLE            (0x00800000) 
+#define  EHCI_PORTSCX_PAR_XCVR_SELECT              (0xC0000000)
+#define  EHCI_PORTSCX_PORT_POWER                   (0x00001000)
+#define  EHCI_PORTSCX_LINE_STATUS_BITS             (0x00000C00)
+#define  EHCI_PORTSCX_LINE_STATUS_SE0              (0x00000000)
+#define  EHCI_PORTSCX_LINE_STATUS_KSTATE           (0x00000400)
+#define  EHCI_PORTSCX_LINE_STATUS_JSTATE           (0x00000800)
+#define  EHCI_PORTSCX_PORT_HIGH_SPEED              (0x00000200)
+#define  EHCI_PORTSCX_PORT_RESET                   (0x00000100)
+#define  EHCI_PORTSCX_PORT_SUSPEND                 (0x00000080)
+#define  EHCI_PORTSCX_PORT_FORCE_RESUME            (0x00000040)
+#define  EHCI_PORTSCX_PORT_EN_DIS_CHANGE           (0x00000008)
+#define  EHCI_PORTSCX_PORT_ENABLE                  (0x00000004)
+#define  EHCI_PORTSCX_CONNECT_STATUS_CHANGE        (0x00000002)
+#define  EHCI_PORTSCX_CURRENT_CONNECT_STATUS       (0x00000001)
+
+#define  VUSBHS_PORTSCX_PORT_SPEED_FULL            (0x00000000)
+#define  VUSBHS_PORTSCX_PORT_SPEED_LOW             (0x04000000)
+#define  VUSBHS_PORTSCX_PORT_SPEED_HIGH            (0x08000000)
+#define  VUSBHS_SPEED_MASK                         (0x0C000000)
+#define  VUSBHS_SPEED_BIT_POS                      (26)
+
+#define  EHCI_PORTSCX_W1C_BITS                     (0x2A)
+#define  VUSB_EP_QH_PACKET_SIZE                    (0x3FFF0000)
+#define  VUSB_EP_TR_PACKET_SIZE                    (0x7FFF0000)
+
+// These are not EHCI defined, but named so for consistency
+// // and are for selecting the transceiver (XCVR) type
+// //-------------------------------------------------------------
+#define  EHCI_PORTSCX_UTMI_XCVR_SELECT              (0x00000000)
+#define  EHCI_PORTSCX_ULPI_XCVR_SELECT              (0x80000000)
+#define  EHCI_PORTSCX_SERIAL_XCVR_SELECT            (0xC0000000)
+
+#define  VUSBHS_FRINDEX_MS_MASK                    (0xFFFFFFF8)
+#define  VUSBHS_ADDRESS_BIT_SHIFT                  (25)
+
+#define  VUSB20_DCC_MAX_ENDPTS_SUPPORTED           (0x1F)
+#define  VUSB20_DCC_HOST_MODE_MASK                 (1 << 8)               
+#define  VUSB20_DCC_DEVICE_MODE_MASK               (1 << 7)               
+
+#define  EHCI_HCC_PARAMS_64_BIT_ADDR_CAP           (0x01)
+#define  EHCI_HCC_PARAMS_PGM_FRM_LIST_FLAG         (0x02)
+#define  EHCI_HCC_PARAMS_ASYNC_PARK_CAP            (0x04)
+#define  EHCI_HCC_PARAMS_ISOCH_SCHED_THRESHOLD     (0xF0)
+#define  EHCI_HCC_PARAMS_ISOCH_FRAME_CACHED        (0x80)
+
+#define  VUSB20_HCS_PARAMS_PORT_POWER_CONTROL_FLAG (0x10)
+
+#define  VUSB20_HOST_INTR_EN_BITS                  (0x37)
+
+#define  VUSB20_DEFAULT_PERIODIC_FRAME_LIST_SIZE   (1024)
+#define  VUSB20_NEW_PERIODIC_FRAME_LIST_BITS       (2)
+#define  EHCI_FRAME_LIST_ELEMENT_POINTER_T_BIT     (0x01)
+#define  EHCI_ITD_T_BIT                            (0x01)
+#define  EHCI_SITD_T_BIT                           (0x01)
+#define  EHCI_QUEUE_HEAD_POINTER_T_BIT             (0x01)
+
+
+/************************************************************
+Split transatcions specific defines
+************************************************************/
+#define  EHCI_START_SPLIT_MAX_BUDGET               188
+
+#define  EHCI_ELEMENT_TYPE_ITD                     (0x00)
+#define  EHCI_ELEMENT_TYPE_QH                      (0x02)
+#define  EHCI_ELEMENT_TYPE_SITD                    (0x04)
+#define  EHCI_ELEMENT_TYPE_FSTN                    (0x06)
+#define  EHCI_ELEMENT_TYPE_MASK                    (0x06)
+
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_ITD          (0x00)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_QH           (0x01)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_SITD         (0x02)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_FSTN         (0x03)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_BIT_POS      (1)
+
+
+#define  EHCI_QH_ELEMENT_TYPE_ITD                  (0x00)
+#define  EHCI_QH_ELEMENT_TYPE_QH                   (0x01)
+#define  EHCI_QH_ELEMENT_TYPE_SITD                 (0x02)
+#define  EHCI_QH_ELEMENT_TYPE_FSTN                 (0x03)
+
+#define  EHCI_QH_ELEMENT_TYPE_BIT_POS              (1)
+
+#define  EHCI_QTD_PID_OUT_TOKEN                    (0x000)
+#define  EHCI_QTD_PID_IN_TOKEN                     (0x100)
+#define  EHCI_QTD_PID_SETUP_TOKEN                  (0x200)
+#define  EHCI_QTD_IOC                              (0x8000)
+#define  EHCI_QTD_STATUS_ACTIVE                    (0x0080)
+#define  EHCI_QTD_STATUS_HALTED                    (0x0040)
+#define  EHCI_QTD_PID_SETUP                        (0x0200)
+#define  EHCI_QTD_PID_IN                           (0x0100)
+#define  EHCI_QTD_PID_OUT                          (0x0000)
+#define  EHCI_QTD_LENGTH_BIT_POS                   (16)
+#define  EHCI_QTD_DATA_TOGGLE                      (0x80000000)
+#define  EHCI_QTD_DATA_TOGGLE_BIT_POS              (31)
+#define  EHCI_QTD_LENGTH_BIT_MASK                  (0x7FFF0000)
+#define  EHCI_QTD_ERROR_BITS_MASK                  (0x0000003E)
+#define  EHCI_QTD_DEFAULT_CERR_VALUE               (0xC00)
+
+#define  EHCI_SETUP_TOKEN                          (2)
+#define  EHCI_OUT_TOKEN                            (0)
+#define  EHCI_IN_TOKEN                             (1)
+
+#define  EHCI_QTD_T_BIT                            (0x01)
+
+#define  EHCI_QH_ENDPOINT_SPEED_FULL               (0x00)
+#define  EHCI_QH_ENDPOINT_SPEED_LOW                (0x01)
+#define  EHCI_QH_ENDPOINT_SPEED_HIGH               (0x02)
+#define  EHCI_QH_ENDPOINT_SPEED_RESERVED           (0x03)
+
+#define  EHCI_ITD_LENGTH_BIT_POS                   (16)
+#define  EHCI_ITD_IOC_BIT                          (0x00008000)
+#define  EHCI_ITD_ACTIVE_BIT                       (0x80000000)
+#define  EHCI_ITD_PG_SELECT_BIT_POS                (12)
+#define  EHCI_ITD_DIRECTION_BIT_POS                (11)
+#define  EHCI_ITD_EP_BIT_POS                       (8)
+#define  EHCI_ITD_STATUS                           (0xF0000000)
+#define  EHCI_ITD_STATUS_ACTIVE                    (0x80000000) /*bit 4 = 1000*/
+#define  EHCI_ITD_STATUS_DATA_BUFFER_ERR           (0x40000000) /*bit 3 = 0100*/
+#define  EHCI_ITD_STATUS_BABBLE_ERROR              (0x20000000) /*bit 2 = 0010*/
+#define  EHCI_ITD_STATUS_TRANSACTION_ERR           (0x10000000) /*bit 4 = 0001*/
+
+#define  EHCI_ITD_LENGTH_TRANSMITTED               (0x0FFF0000)
+#define  EHCI_ITD_BUFFER_OFFSET                    (0x00000FFF)
+#define  EHCI_ITD_PAGE_NUMBER                      (0x00007000)
+#define  EHCI_ITD_BUFFER_POINTER                   (0xFFFFF000)
+#define  EHCI_ITD_MULTI_TRANSACTION_BITS           (0x00000003)
+
+          
+
+/* SITD position bits */
+#define  EHCI_SITD_DIRECTION_BIT_POS                (31)
+#define  EHCI_SITD_PORT_NUMBER_BIT_POS              (24)
+#define  EHCI_SITD_HUB_ADDR_BIT_POS                 (16)
+#define  EHCI_SITD_EP_ADDR_BIT_POS                  (8)
+
+#define  EHCI_SITD_COMPLETE_SPLIT_MASK_BIT_POS      (8)
+
+#define  EHCI_SITD_IOC_BIT_SET                      (0x80000000)
+#define  EHCI_SITD_PAGE_SELECT_BIT_POS              (30)
+#define  EHCI_SITD_TRANSFER_LENGTH_BIT_POS          (16)
+#define  EHCI_SITD_STATUS_ACTIVE                    (0x80)
+
+#define  EHCI_SITD_STATUS                           (0xFF)
+#define  EHCI_SITD_LENGTH_TRANSMITTED               (0x03FF0000)
+#define  EHCI_SITD_BUFFER_OFFSET                    (0x00000FFF)
+#define  EHCI_SITD_PAGE_NUMBER                      (0x40000000)
+#define  EHCI_SITD_BUFFER_POINTER                   (0xFFFFF000)
+
+
+
+#define  EHCI_SITD_BUFFER_PTR_BIT_POS              (12)
+#define  EHCI_SITD_TP_BIT_POS                      (3)
+#define  EHCI_SITD_TP_ALL                          (0)
+#define  EHCI_SITD_TP_BEGIN                        (1)
+#define  EHCI_SITD_TP_MID                          (2)
+#define  EHCI_SITD_TP_END                          (3)
+
+
+
+/* Interrupt enable bit masks */
+#define  EHCI_IER_ASYNCH_ADVANCE                   (0x00000020)
+#define  EHCI_IER_HOST_SYS_ERROR                   (0x00000010)
+#define  EHCI_IER_FRAME_LIST_ROLLOVER              (0x00000008)
+#define  EHCI_IER_PORT_CHANGE                      (0x00000004)
+#define  EHCI_IER_USB_ERROR                        (0x00000002)
+#define  EHCI_IER_USB_INTERRUPT                    (0x00000001)
+
+/* Interrupt status bit masks */
+#define  EHCI_STS_RECLAIMATION                     (0x00002000)
+#define  EHCI_STS_SOF_COUNT                        (0x00000080)
+#define  EHCI_STS_ASYNCH_ADVANCE                   (0x00000020)
+#define  EHCI_STS_HOST_SYS_ERROR                   (0x00000010)
+#define  EHCI_STS_FRAME_LIST_ROLLOVER              (0x00000008)
+#define  EHCI_STS_PORT_CHANGE                      (0x00000004)
+#define  EHCI_STS_USB_ERROR                        (0x00000002)
+#define  EHCI_STS_USB_INTERRUPT                    (0x00000001)
+
+/* Status bit masks */
+#define  EHCI_STS_ASYNCH_SCHEDULE                  (0x00008000)
+#define  EHCI_STS_PERIODIC_SCHEDULE                (0x00004000)
+#define  EHCI_STS_RECLAMATION                      (0x00002000)
+#define  EHCI_STS_HC_HALTED                        (0x00001000)
+
+/* USB command bit masks */
+#define  EHCI_USBCMD_ASYNC_SCHED_ENABLE            (0x00000020)
+#define  EHCI_USBCMD_PERIODIC_SCHED_ENABLE         (0x00000010)
+
+#define  EHCI_HCS_PARAMS_N_PORTS                   (0x0F)
+
+#define  VUSB_HS_DELAY                             (3500)
+
+#define  EHCI_QH_EP_NUM_MASK                       (0x0F00)
+#define  EHCI_QH_EP_NUM_BITS_POS                   (8)
+#define  EHCI_QH_DEVICE_ADDRESS_MASK               (0x7F)
+#define  EHCI_QH_SPEED_BITS_POS                    (12)
+#define  EHCI_QH_MAX_PKT_SIZE_BITS_POS             (16)
+#define  EHCI_QH_NAK_COUNT_RL_BITS_POS             (28)
+#define  EHCI_QH_EP_CTRL_FLAG_BIT_POS              (27)
+#define  EHCI_QH_HEAD_RECLAMATION_BIT_POS          (15)
+#define  EHCI_QH_DTC_BIT_POS                       (14)
+#define  EHCI_QH_HIGH_BW_MULT_BIT_POS              (30)
+#define  EHCI_QH_HUB_PORT_NUM_BITS_POS             (23)
+#define  EHCI_QH_HUB_ADDR_BITS_POS                 (16)
+#define  EHCI_QH_SPLIT_COMPLETION_MASK_BITS_POS    (8)
+#define  EHCI_QH_SPLIT_COMPLETION_MASK             (0xFF00)
+#define  EHCI_QH_INTR_SCHED_MASK                   (0xFF)
+#define  EHCI_QH_INACTIVATE_NEXT_TR_BIT_POS        (7)
+#define  EHCI_QH_HORIZ_PHY_ADDRESS_MASK            (0xFFFFFFE0)
+#define  EHCI_QH_TR_OVERLAY_DT_BIT                 (0x80000000)
+
+#define  EHCI_SITD_SPLIT_COMPLETION_MASK_BITS_POS  (8)
+
+#define  EHCI_INTR_NO_THRESHOLD_IMMEDIATE          (0x00010000)
+#define  EHCI_NEW_PERIODIC_FRAME_LIST_SIZE         (1024)
+#define  EHCI_FRAME_LIST_SIZE_BITS_POS             (2)
+#define  EHCI_HORIZ_PHY_ADDRESS_MASK              (0xFFFFFFE0)
+
+#define  DEFAULT_MAX_NAK_COUNT                     (15)
+
+/* OTG Status and control register bit masks */
+
+/* OTG interrupt enable bit masks */
+#define  VUSBHS_OTGSC_INTERRUPT_ENABLE_BITS_MASK   (0x5F000000)
+#define  VUSBHS_OTGSC_DPIE                         (0x40000000)   /* Data-line pulsing IE */
+#define  VUSBHS_OTGSC_1MSIE                        (0x20000000)
+#define  VUSBHS_OTGSC_BSEIE                        (0x10000000)   /* B-session end IE */
+#define  VUSBHS_OTGSC_BSVIE                        (0x08000000)   /* B-session valid IE */
+#define  VUSBHS_OTGSC_ASVIE                        (0x04000000)   /* A-session valid IE */
+#define  VUSBHS_OTGSC_AVVIE                        (0x02000000)   /* A-V-bus valid IE */
+#define  VUSBHS_OTGSC_IDIE                         (0x01000000)   /* OTG ID IE */
+
+/* OTG interrupt status bit masks */
+#define  VUSBHS_OTGSC_INTERRUPT_STATUS_BITS_MASK   (0x005F0000)
+#define  VUSBHS_OTGSC_DPIS                         (0x00400000)   /* Data-line pulsing IS */
+#define  VUSBHS_OTGSC_1MSIS                        (0x00200000)
+#define  VUSBHS_OTGSC_BSEIS                        (0x00100000)   /* B-session end IS */
+#define  VUSBHS_OTGSC_BSVIS                        (0x00080000)   /* B-session valid IS */
+#define  VUSBHS_OTGSC_ASVIS                        (0x00040000)   /* A-session valid IS */
+#define  VUSBHS_OTGSC_AVVIS                        (0x00020000)   /* A-Vbus valid IS */
+#define  VUSBHS_OTGSC_IDIS                         (0x00010000)   /* OTG ID IS */
+
+/* OTG status bit masks */
+#define  VUSBHS_OTGSC_DPS                          (0x00004000)
+#define  VUSBHS_OTGSC_BSE                          (0x00001000)   /* B-session end */
+#define  VUSBHS_OTGSC_BSV                          (0x00000800)   /* B-session valid */
+#define  VUSBHS_OTGSC_ASV                          (0x00000400)   /* A-session valid */
+#define  VUSBHS_OTGSC_AVV                          (0x00000200)   /* A-Vbus Valid */
+#define  VUSBHS_OTGSC_ID                           (0x00000100)   /* OTG ID */
+
+/* OTG control bit masks */
+#define  VUSBHS_OTGSC_CTL_BITS                     (0x2F)
+#define  VUSBHS_OTGSC_HABA                         (0x00000080)   /* hardware assisted data pulse bits*/
+#define  VUSBHS_OTGSC_HADP                         (0x00000040)   /* hardware assisted data pulse bits*/
+
+#ifdef PATCH_3
+/* the following change is to be compatable with 4.0 revision of
+hardware. Enable the following switch in config.mk to enable the
+changes. */
+
+    /* WEB20040409 below line changed from VUSBHS_OTGSC_B_HOST_EN to VUSBHS_OTGSC_IDPU 
+       to reflect change in usbhs4.0  B_HOST_EN has not been used quite some time */
+    #define  VUSBHS_OTGSC_IDPU                         (0x00000020)   /* ID pull enable */
+#else
+    #define  VUSBHS_OTGSC_B_HOST_EN                    (0x00000020)   /* B_host_enable */
+#endif
+
+#define  VUSBHS_OTGSC_DP                           (0x00000010)   /* Data-pulsing */
+#define  VUSBHS_OTGSC_OT                           (0x00000008)   /* OTG termination */
+#if 0
+    #define  VUSBHS_OTGSC_VO                       (0x00000004)   /* Vbus on */
+#endif
+
+#define  VUSBHS_OTGSC_HAAR                         (0x00000004)   /* Auto reset bit*/
+
+#define  VUSBHS_OTGSC_VC                           (0x00000002)   /* Vbus charge */
+#define  VUSBHS_OTGSC_VD                           (0x00000001)   /* Vbus discharge */
+
+typedef  uint_32  USB_REGISTER, _PTR_ USB_REGISTER_PTR;
+
+/* The VUSB register structure */
+typedef struct {
+   union  {
+      struct  {
+         volatile USB_REGISTER   CAPLENGTH_HCIVER;
+         volatile USB_REGISTER   HCS_PARAMS;       /* HC structural parameters */
+         volatile USB_REGISTER   HCC_PARAMS;       /* HC Capability Parameters*/
+         volatile USB_REGISTER   RESERVED1[5];
+         volatile USB_REGISTER   DCI_VERSION;      /* DC version number and reserved 16 bits */
+         volatile USB_REGISTER   DCC_PARAMS;       /* DC Capability Parameters */
+      } CAPABILITY_REGISTERS;
+      
+      struct  {
+         volatile USB_REGISTER   USB_CMD;                   /* Command register */
+         volatile USB_REGISTER   USB_STS;                   /* Status register */
+         volatile USB_REGISTER   USB_INTR;                  /* Interrupt enable */
+         volatile USB_REGISTER   USB_FRINDEX;               /* Frame index */
+#if 0
+         volatile USB_REGISTER   CTRLDSSEGMENT;             /* 4G segment selector */
+#else
+         volatile USB_REGISTER   RESERVED2[1];
+#endif
+         volatile USB_REGISTER   DEVICE_ADDR;               /* Device Address */
+
+         volatile USB_REGISTER   EP_LIST_ADDR;              /* Endpoint List Address */
+	
+#if 1
+//xj add
+	
+         volatile USB_REGISTER   TT_CTRL;                   /* HOST TT status and control */
+         volatile USB_REGISTER   BURST_SIZE;                /* Programmable Burst Size */
+         volatile USB_REGISTER   TX_FILL_TUNING;               /* Host Transmit Pre-Buffer Packet Tuning */
+	
+         volatile USB_REGISTER   RESERVED0[4];
+
+         volatile USB_REGISTER   EP_NAK;                    /* Endpoint NAK */
+         volatile USB_REGISTER   EP_NAK_EN;                    /* Endpoint NAK Enable */
+#else
+         volatile USB_REGISTER   RESERVED0[9];
+#endif
+         volatile USB_REGISTER   CONFIG_FLAG;               /* Configured Flag register */
+         volatile USB_REGISTER   PORTSCX[VUSBHS_MAX_PORTS]; /* Port Status/Control x, x = 1..8 */
+         volatile USB_REGISTER   OTGSC;
+         volatile USB_REGISTER   USB_MODE;                  /* USB Host/Device mode */
+         volatile USB_REGISTER   ENDPT_SETUP_STAT;          /* Endpoint Setup Status */
+         volatile USB_REGISTER   ENDPTPRIME;                /* Endpoint Initialize */
+         volatile USB_REGISTER   ENDPTFLUSH;                /* Endpoint De-initialize */
+         volatile USB_REGISTER   ENDPTSTATUS;               /* Endpoint Status */
+         volatile USB_REGISTER   ENDPTCOMPLETE;             /* Endpoint Interrupt On Complete */
+         volatile USB_REGISTER   ENDPTCTRLX[16];            /* Endpoint Control, where x = 0.. 15 */
+//xj add
+         volatile USB_REGISTER   MCR;            	    /* Mux Control */
+         volatile USB_REGISTER   ISR;            	    /* Interrupt Status */
+         volatile USB_REGISTER   IER;            	    /* Interrupt Enable */
+//xj add end
+      } OPERATIONAL_DEVICE_REGISTERS;
+      
+#if 0
+      xj del
+      struct  {
+         volatile USB_REGISTER   USB_CMD;                   /* Command register */
+         volatile USB_REGISTER   USB_STS;                   /* Status register */
+         volatile USB_REGISTER   USB_INTR;                  /* Interrupt enable */
+         volatile USB_REGISTER   USB_FRINDEX;               /* Frame index */
+         volatile USB_REGISTER   CTRLDSSEGMENT;             /* 4G segment selector */
+         volatile USB_REGISTER   PERIODIC_LIST_BASE_ADDR;   /* Periodic schedule list */
+         volatile USB_REGISTER   CURR_ASYNC_LIST_ADDR;      /* Current Asynch schedule list */
+         volatile USB_REGISTER   ASYNCTTSTS;                /* Async buffer in embedded TT control */
+         volatile USB_REGISTER   RESERVED0[8];
+         volatile USB_REGISTER   CONFIG_FLAG;               /* Configured Flag register */
+         volatile USB_REGISTER   PORTSCX[VUSBHS_MAX_PORTS]; /* Port Status/Control x, x = 1..8 */
+
+         volatile USB_REGISTER   OTGSC;                     /* OTG status and control register */
+         volatile USB_REGISTER   USB_MODE;                  /* USB Host/Device mode */
+      } OPERATIONAL_HOST_REGISTERS;
+#endif
+   } REGISTERS;
+} VUSB20_REG_STRUCT, _PTR_ VUSB20_REG_STRUCT_PTR;
+
+typedef struct {
+   volatile uint_32   MAX_PKT_LENGTH;    /* Bits 16..26 Bit 15 is Interrupt 
+                                          ** On Setup 
+                                          */
+   volatile uint_32   CURR_DTD_PTR;        /* Current dTD Pointer */
+   volatile uint_32   NEXT_DTD_PTR;        /* Next dTD Pointer */
+   volatile uint_32   SIZE_IOC_INT_STS;    /* Total bytes (16..30), IOC (15), 
+                                          ** INT (8), STS (0-7) 
+                                          */
+   volatile uint_32   BUFF_PTR0;           /* Buffer pointer Page 0 (12-31) */
+   volatile uint_32   BUFF_PTR1;           /* Buffer pointer Page 1 (12-31) */
+   volatile uint_32   BUFF_PTR2;           /* Buffer pointer Page 2 (12-31) */
+   volatile uint_32   BUFF_PTR3;           /* Buffer pointer Page 3 (12-31) */
+   volatile uint_32   BUFF_PTR4;           /* Buffer pointer Page 4 (12-31) */
+   volatile uint_32   RESERVED1;
+   volatile uint_8    SETUP_BUFFER[8];     /* 8 bytes of setup data that follows 
+                                            ** the Setup PID 
+                                            */
+   volatile uint_32   RESERVED2[4];
+} VUSB20_EP_QUEUE_HEAD_STRUCT, _PTR_ VUSB20_EP_QUEUE_HEAD_STRUCT_PTR;
+
+typedef struct {
+   pointer              PRIVATE;
+   void (_CODE_PTR_     FREE)(pointer);
+   pointer              XD_FOR_THIS_DTD;
+} SCRATCH_STRUCT, _PTR_ SCRATCH_STRUCT_PTR;
+
+typedef struct ep_tr_struct {
+   volatile uint_32      NEXT_TR_ELEM_PTR; /* Memory address of next 
+                                          ** dTD to be processed (5-31)
+                                          ** and the T (bit 0) indicating 
+                                          ** pointer validity
+                                          */
+   volatile uint_32      SIZE_IOC_STS;     /* total bytes (16-30), 
+                                          ** IOC (15), Status (0-7) 
+                                          */
+   volatile uint_32      BUFF_PTR0;        /* Buffer pointer Page 0 */
+   volatile uint_32      BUFF_PTR1;        /* Buffer pointer Page 1 */
+   volatile uint_32      BUFF_PTR2;        /* Buffer pointer Page 2 */
+   volatile uint_32      BUFF_PTR3;        /* Buffer pointer Page 3 */
+   volatile uint_32      BUFF_PTR4;        /* Buffer pointer Page 4 */
+   volatile SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+} VUSB20_EP_TR_STRUCT, _PTR_ VUSB20_EP_TR_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of 
+                                          ** next schedule data structure 
+                                          ** item Type (1..2 ) and the 
+                                          ** T (bit 0) indicating pointer 
+                                          ** validity
+                                          */
+   uint_32      TR_STATUS_CTL_LIST[8];  /* bits 31-28: Status,
+                                                ** bits 27-16: Tr X length
+                                                ** bit 15: Int on complete
+                                                ** bits 14-12: Page Select
+                                                ** bits 11-0: Tr X offset
+                                                */
+   uint_32      BUFFER_PAGE_PTR_LIST[7];  /* bits 31-12 4K aligned pointer 
+                                                ** to physical memory 
+                                                ** bits 11-8 endpoint no.
+                                                ** bit 7: reserved
+                                                ** bits 6-0 device address*/
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer      PIPE_DESCR_FOR_THIS_ITD;
+   pointer      PIPE_TR_DESCR_FOR_THIS_ITD;
+   uint_32_ptr  frame_list_ptr;
+   uint_32      number_of_transactions;
+   /* 32-byte aligned structures */
+   uint_32        RESERVED[11];
+} EHCI_ITD_STRUCT, _PTR_ EHCI_ITD_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of 
+                                          ** next schedule data structure 
+                                          ** item Type (1..2 ) and the 
+                                          ** T (bit 0) indicating pointer 
+                                          ** validity
+                                          */
+   uint_32      EP_CAPAB_CHARAC;  /* bits 31: Direction (I/O),
+                                          ** bits 30-24: Port number
+                                          ** bit 23: reserved
+                                          ** bits 22-16: Hub address
+                                          ** bits 15-12: Reserved
+                                          ** bits 11-8: Endpoint number
+                                          ** bit 7: reserved
+                                          ** bits 6-0: device address
+                                          */
+   uint_32      UFRAME_SCHED_CTL; /* bits 31-16: reserved 
+                                          ** bits 15-8: Split completion mask
+                                          ** bits 7-0: Split start mask
+                                          */
+   uint_32      TRANSFER_STATE;   /* bit 31: int on complete
+                                          ** bit 30: Page Select
+                                          ** bits 29-26: Reserved
+                                          ** bits 25-16: total bytes to 
+                                          ** transfer
+                                          ** bits 15-8: uframe 
+                                          ** complete-split progress mask
+                                          ** bits 7-0: status
+                                          */
+   uint_32      BUFFER_PTR_0;     /* bits 31-12: 4K aligned pointer 
+                                          ** to physical memory 
+                                          ** bits 11-0: Current offset
+                                          */
+   uint_32      BUFFER_PTR_1;     /* bits 31-12: 4K aligned pointer 
+                                          ** to physical memory 
+                                          ** bits 11-5 reserved
+                                          ** bits 4-3 tr position
+                                          ** bits 2-0 tr count
+                                          */
+   uint_32      BACK_LINK_PTR;    /* bits 31-5 back pointer points to sITD 
+                                          ** bits 4-1: reserved
+                                          ** bit 0: terminate
+                                          */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer      PIPE_DESCR_FOR_THIS_SITD;
+   pointer      PIPE_TR_DESCR_FOR_THIS_SITD;
+   uint_32_ptr  frame_list_ptr;
+
+   /* align to 16 word boundry */
+   uint_32      RESERVED[5];
+
+} EHCI_SITD_STRUCT, _PTR_ EHCI_SITD_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NEXT_QTD_PTR;     /* (5-31) Memory address of 
+                                          ** next qTD to be processed
+                                          ** (4..1) reserved 
+                                          ** T (bit 0) indicating pointer 
+                                          ** validity
+                                          */
+   uint_32      ALT_NEXT_QTD_PTR; /* bits 31-5: alternate next 
+                                          ** qTD if the above one encounters 
+                                          ** a short packet
+                                          ** (4..1) reserved 
+                                          ** T (bit 0) indicating pointer 
+                                          ** validity
+                                          */
+   uint_32      TOKEN;            /* bits 31: data toggle 
+                                          ** bits 30-16: Total bytes to transfer
+                                          ** bit 15: Interrupt on Complete
+                                          ** bits 14-12: Current page
+                                          ** bits 11-10: Error Counter
+                                          ** bits 9-8: PID code
+                                          ** bits 7-0: status
+                                          */
+   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: Current Offset
+                                          */
+   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_2;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer     PIPE_DESCR_FOR_THIS_QTD;
+   pointer     TR_FOR_THIS_QTD;
+   uint_32     RESERVED[5];
+} EHCI_QTD_STRUCT, _PTR_ EHCI_QTD_STRUCT_PTR;
+
+typedef struct {
+   uint_32      HORIZ_LINK_PTR;   /* (5-31) Memory address of 
+                                          ** next data object to be processed
+                                          ** (4..3) reserved 
+                                          ** (2..1) type of the item
+                                          ** T (bit 0) indicating pointer 
+                                          ** validity
+                                          */
+   uint_32      EP_CAPAB_CHARAC1; /* bits 31-28: NAK count reload,
+                                          ** bit 27: Control endpoint flag
+                                          ** bit 26-16: Maximum packet length
+                                          ** bit 15: Head of reclamation 
+                                          ** list flag
+                                          ** bit 14: data toggle control
+                                          ** bits 13-12: endpoint speed
+                                          ** bit 11-8: endpoint number
+                                          ** bits 7: Inactivate on next tr
+                                          ** bits 6-0: Device address
+                                          */
+   uint_32      EP_CAPAB_CHARAC2; /* bits 31-30: High-BW pipe 
+                                          ** Multiplier, 
+                                          ** bit 29-23: Port number
+                                          ** bit 22-16: Hub address
+                                          ** bit 15-8: Split completion mask
+                                          ** bit 7-0: Interrupt schedule mask
+                                          */
+   uint_32      CURR_QTD_LINK_PTR;/* bits 31-5: physical memory address
+                                          ** of the current xaction processed
+                                          */
+   uint_32      NEXT_QTD_LINK_PTR;/* bits 31-5: physical memory address
+                                          ** of the current xaction processed
+                                          ** bit 0: Terminate bit
+                                          */
+   uint_32      ALT_NEXT_QTD_LINK_PTR;  /* bits 31-5: physical memory address
+                                                ** of the current xaction processed
+                                                ** bits 4-1: NAK counter
+                                                ** bit 0: Terminate bit
+                                                */
+   uint_32      STATUS;           /* bit 31: data-toggle
+                                          ** bits 30-16: total bytes to transfer
+                                          ** bit 15: Interrupt on complete
+                                          ** bits 11-10: Error counter
+                                          ** bit 0: Ping state/Err
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 7-0: Split-transaction, 
+                                          ** complete-split progress
+                                          */
+   uint_32      BUFFER_PTR_2;     /* bits 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bits 11-5: S-bytes
+                                          ** bits 4-0: Split-transaction 
+                                          ** frame tag
+                                          */
+   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned 
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer     PIPE_DESCR_FOR_THIS_QH;
+   uint_32     RESERVED[18];
+} EHCI_QH_STRUCT, _PTR_ EHCI_QH_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NORMAL_PATH_LINK_PTR;   /* (5-31) Memory address of 
+                                                ** next data object to be processed
+                                                ** in the periodic list
+                                                ** bits 4-3: reserved 
+                                                ** (2..1) type of the item
+                                                ** T (bit 0) indicating pointer 
+                                                ** validity
+                                                */
+   uint_32      BACK_PATH_LINK_PTR;     /* bits 31-5: Memory address of 
+                                                ** the queue head,
+                                                ** bit 4-3: reserved
+                                                ** (2..1) type of the item
+                                                ** T (bit 0) indicating pointer 
+                                                ** validity
+                                                */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   /* 32-bytes aligned */
+   uint_32              RESERVED[6];
+} EHCI_FSTN_STRUCT, _PTR_ EHCI_FSTN_STRUCT_PTR;
+
+typedef uint_32   EHCI_FRAME_LIST_ELEMENT_POINTER;
+
+#endif /* __mvUsbCore_h__ */
+/* EOF */
+
+
+
diff --git a/board/pxa/common/usbeth/mvUsbDebug.h b/board/pxa/common/usbeth/mvUsbDebug.h
new file mode 100644
index 0000000..65c0a31
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDebug.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDebug_h__
+#define __mvUsbDebug_h__
+
+#include "mvUsbTypes.h"
+
+#define MV_USB_RT_DEBUG
+
+/************************************************************
+The following array is used to make a run time trace route
+inside the USB stack.
+*************************************************************/
+
+#define ARC_DEBUG_FLAG_ANY      0x00000000
+
+#define ARC_DEBUG_FLAG_TRACE    0x00000001
+#define ARC_DEBUG_FLAG_CTRL     0x00000002
+#define ARC_DEBUG_FLAG_RX       0x00000004
+#define ARC_DEBUG_FLAG_TX       0x00000008
+#define ARC_DEBUG_FLAG_STALL    0x00000010
+#define ARC_DEBUG_FLAG_STATUS   0x00000020
+#define ARC_DEBUG_FLAG_TRANSFER 0x00000040
+#define ARC_DEBUG_FLAG_INIT     0x00000080
+#define ARC_DEBUG_FLAG_ISR      0x00000100
+#define ARC_DEBUG_FLAG_ERROR    0x00000200
+#define ARC_DEBUG_FLAG_ADDR     0x00000400
+#define ARC_DEBUG_FLAG_DUMP     0x00000800
+#define ARC_DEBUG_FLAG_SETUP    0x00001000
+#define ARC_DEBUG_FLAG_CLASS    0x00002000
+#define ARC_DEBUG_FLAG_SPEED    0x00004000
+#define ARC_DEBUG_FLAG_RESET    0x00008000
+#define ARC_DEBUG_FLAG_SUSPEND  0x00010000
+#define ARC_DEBUG_FLAG_RESUME   0x00020000
+#define ARC_DEBUG_FLAG_EP0      0x00040000
+#define ARC_DEBUG_FLAG_EP1      0x00080000
+#define ARC_DEBUG_FLAG_STATS    0x00100000
+
+
+#define ARC_DEBUG_FLAG_ALL      0xffffffff
+
+extern uint_32  usbDebugFlags;
+
+#ifdef MV_USB_RT_DEBUG
+#   define ARC_DEBUG_CODE(flags, code)    	        \
+        if( (usbDebugFlags & (flags)) == (flags) )  \
+            code
+#else
+#   define ARC_DEBUG_CODE(flags, code)
+#endif
+
+#define MV_USB_TRACE_PRINT 
+
+#if defined(MV_USB_TRACE_LOG)
+
+#define TRACE_ARRAY_SIZE 400
+#define MAX_STRING_SIZE  132
+
+extern uint_16 DEBUG_TRACE_ARRAY_COUNTER;
+extern char    DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE][MAX_STRING_SIZE];
+
+#define ARC_DEBUG_TRACE(flags, format, x...)                                        \
+{                                                                                   \
+    if( (usbDebugFlags & (flags)) == (flags))                                   \
+    {                                                                               \
+        USB_sprintf(DEBUG_TRACE_ARRAY[DEBUG_TRACE_ARRAY_COUNTER], format, ##x);     \
+        DEBUG_TRACE_ARRAY_COUNTER++;                                                \
+        if(DEBUG_TRACE_ARRAY_COUNTER >= TRACE_ARRAY_SIZE)                           \
+            {DEBUG_TRACE_ARRAY_COUNTER = 0;}                                        \
+    }                                                                               \
+}
+                                                    
+#elif defined(MV_USB_TRACE_PRINT)
+
+#   define ARC_DEBUG_TRACE(flags, format, x...)           \
+        if((usbDebugFlags & (flags)) == (flags))      \
+            USB_printf(format, ##x)
+
+/*if trace switch is not enabled define debug log trace to empty*/
+#else
+#   define ARC_DEBUG_TRACE(flags, fromat, x...)
+#endif
+
+
+/************************************************************
+The following are global data structures that can be used
+to copy data from stack on run time. This structure can
+be analyzed at run time to see the state of various other
+data structures in the memory.
+*************************************************************/
+
+#endif /* __mvUsbDebug_h__ */
+/* EOF */
+
diff --git a/board/pxa/common/usbeth/mvUsbDefs.h b/board/pxa/common/usbeth/mvUsbDefs.h
new file mode 100644
index 0000000..4aded4e
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDefs.h
@@ -0,0 +1,140 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDefs_h__
+#define __mvUsbDefs_h__
+
+#include "mvUsbTypes.h"
+
+/* Host specific */
+#define  USB_DEBOUNCE_DELAY                  (101)
+#define  USB_RESET_RECOVERY_DELAY            (11)
+#define  USB_RESET_DELAY                     (60)
+
+/* Error codes */
+#define  USB_OK                              (0x00)
+#define  USBERR_ALLOC                        (0x81)
+#define  USBERR_BAD_STATUS                   (0x82)
+#define  USBERR_CLOSED_SERVICE               (0x83)
+#define  USBERR_OPEN_SERVICE                 (0x84)
+#define  USBERR_TRANSFER_IN_PROGRESS         (0x85)
+#define  USBERR_ENDPOINT_STALLED             (0x86)
+#define  USBERR_ALLOC_STATE                  (0x87)
+#define  USBERR_DRIVER_INSTALL_FAILED        (0x88)
+#define  USBERR_DRIVER_NOT_INSTALLED         (0x89)
+#define  USBERR_INSTALL_ISR                  (0x8A)
+#define  USBERR_INVALID_DEVICE_NUM           (0x8B)
+#define  USBERR_ALLOC_SERVICE                (0x8C)
+#define  USBERR_INIT_FAILED                  (0x8D)
+#define  USBERR_SHUTDOWN                     (0x8E)
+#define  USBERR_INVALID_PIPE_HANDLE          (0x8F)
+#define  USBERR_OPEN_PIPE_FAILED             (0x90)
+#define  USBERR_INIT_DATA                    (0x91)
+#define  USBERR_SRP_REQ_INVALID_STATE        (0x92)
+#define  USBERR_TX_FAILED                    (0x93)
+#define  USBERR_RX_FAILED                    (0x94)
+#define  USBERR_EP_INIT_FAILED               (0x95)
+#define  USBERR_EP_DEINIT_FAILED             (0x96)
+#define  USBERR_TR_FAILED                    (0x97)
+#define  USBERR_BANDWIDTH_ALLOC_FAILED       (0x98)
+#define  USBERR_INVALID_NUM_OF_ENDPOINTS     (0x99)
+
+#define  USBERR_DEVICE_NOT_FOUND             (0xC0)
+#define  USBERR_DEVICE_BUSY                  (0xC1)
+#define  USBERR_NO_DEVICE_CLASS              (0xC3)
+#define  USBERR_UNKNOWN_ERROR                (0xC4)
+#define  USBERR_INVALID_BMREQ_TYPE           (0xC5)
+#define  USBERR_GET_MEMORY_FAILED            (0xC6)
+#define  USBERR_INVALID_MEM_TYPE             (0xC7)
+#define  USBERR_NO_DESCRIPTOR                (0xC8)
+#define  USBERR_NULL_CALLBACK                (0xC9)
+#define  USBERR_NO_INTERFACE                 (0xCA)
+#define  USBERR_INVALID_CFIG_NUM             (0xCB)
+#define  USBERR_INVALID_ANCHOR               (0xCC)
+#define  USBERR_INVALID_REQ_TYPE             (0xCD)
+
+/* Error Codes for lower-layer */
+#define  USBERR_ALLOC_EP_QUEUE_HEAD          (0xA8)
+#define  USBERR_ALLOC_TR                     (0xA9)
+#define  USBERR_ALLOC_DTD_BASE               (0xAA)
+#define  USBERR_CLASS_DRIVER_INSTALL         (0xAB)
+
+
+/* Pipe Types */
+#define  USB_ISOCHRONOUS_PIPE                (0x01)
+#define  USB_INTERRUPT_PIPE                  (0x02)
+#define  USB_CONTROL_PIPE                    (0x03)
+#define  USB_BULK_PIPE                       (0x04)
+
+#define  ARC_USB_STATE_UNKNOWN               (0xff)
+#define  ARC_USB_STATE_POWERED               (0x03)
+#define  ARC_USB_STATE_DEFAULT               (0x02)
+#define  ARC_USB_STATE_ADDRESS               (0x01)
+#define  ARC_USB_STATE_CONFIG                (0x00)
+#define  ARC_USB_STATE_SUSPEND               (0x80)
+
+#define  ARC_USB_SELF_POWERED                (0x01)
+#define  ARC_USB_REMOTE_WAKEUP               (0x02)
+
+/* Bus Control values */
+#define  ARC_USB_NO_OPERATION                (0x00)
+#define  ARC_USB_ASSERT_BUS_RESET            (0x01)
+#define  ARC_USB_DEASSERT_BUS_RESET          (0x02)
+#define  ARC_USB_ASSERT_RESUME               (0x03)
+#define  ARC_USB_DEASSERT_RESUME             (0x04)
+#define  ARC_USB_SUSPEND_SOF                 (0x05)
+#define  ARC_USB_RESUME_SOF                  (0x06)
+
+/* possible values of XD->bStatus */
+#define  ARC_USB_STATUS_IDLE                 (0)
+#define  ARC_USB_STATUS_TRANSFER_ACCEPTED    (1)
+#define  ARC_USB_STATUS_TRANSFER_PENDING     (2)
+#define  ARC_USB_STATUS_TRANSFER_IN_PROGRESS (3)
+#define  ARC_USB_STATUS_ERROR                (4)
+#define  ARC_USB_STATUS_DISABLED             (5)
+#define  ARC_USB_STATUS_STALLED              (6)
+#define  ARC_USB_STATUS_TRANSFER_QUEUED      (7)
+
+#define  ARC_USB_RECV                        (0)
+#define  ARC_USB_SEND                        (1)
+
+#define  ARC_USB_DEVICE_DONT_ZERO_TERMINATE  (0x1)
+
+#define  ARC_USB_SETUP_DATA_XFER_DIRECTION   (0x80)
+
+#define  ARC_USB_SPEED_FULL                  (0)
+#define  ARC_USB_SPEED_LOW                   (1)
+#define  ARC_USB_SPEED_HIGH                  (2)
+
+#define  ARC_USB_MAX_PKTS_PER_UFRAME         (0x6)
+
+/* USB 1.1 Setup Packet */
+typedef struct setup_struct {
+   uint_8      REQUESTTYPE;
+   uint_8      REQUEST;
+   uint_16     VALUE;
+   uint_16     INDEX;
+   uint_16     LENGTH;
+} SETUP_STRUCT, _PTR_ SETUP_STRUCT_PTR;
+
+#endif /* __mvUsbDefs_h__ */
+
+/* EOF */
+
diff --git a/board/pxa/common/usbeth/mvUsbDesc.h b/board/pxa/common/usbeth/mvUsbDesc.h
new file mode 100644
index 0000000..ef53f2c
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDesc.h
@@ -0,0 +1,163 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDesc_h__
+#define __mvUsbDesc_h__
+
+#include "mvUsbTypes.h"
+
+typedef struct usb_device_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 18 */
+   uint_8   bDescriptorType;  /* DEVICE descriptor type = 1 */
+   uint_8   bcdUSD[2];        /* USB spec in BCD, e.g. 0x0200 */
+   uint_8   bDeviceClass;     /* Class code, if 0 see interface */
+   uint_8   bDeviceSubClass;  /* Sub-Class code, 0 if class = 0 */
+   uint_8   bDeviceProtocol;  /* Protocol, if 0 see interface */
+   uint_8   bMaxPacketSize;   /* Endpoint 0 max. size */
+   uint_8   idVendor[2];      /* Vendor ID per USB-IF */
+   uint_8   idProduct[2];     /* Product ID per manufacturer */
+   uint_8   bcdDevice[2];     /* Device release # in BCD */
+   uint_8   iManufacturer;    /* Index to manufacturer string */
+   uint_8   iProduct;         /* Index to product string */
+   uint_8   iSerialNumber;    /* Index to serial number string */
+   uint_8   bNumConfigurations; /* Number of possible configurations */ 
+} DEVICE_DESCRIPTOR, _PTR_ DEVICE_DESCRIPTOR_PTR;  
+
+typedef struct usb_configuration_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 9 */
+   uint_8   bDescriptorType;  /* CONFIGURATION type = 2 or 7 */
+   uint_8   wTotalLength[2];  /* Length of concatenated descriptors */
+   uint_8   bNumInterfaces;   /* Number of interfaces, this config. */
+   uint_8   bConfigurationValue;  /* Value to set this config. */ 
+   uint_8   iConfig;          /* Index to configuration string */
+   uint_8   bmAttributes;     /* Config. characteristics */
+   #define  CONFIG_RES7       (0x80)  /* Reserved, always = 1 */
+   #define  CONFIG_SELF_PWR   (0x40)  /* Self-powered device */
+   #define  CONFIG_WAKEUP     (0x20)  /* Remote wakeup */
+   uint_8   bMaxPower;        /* Max.power from bus, 2mA units */
+} CONFIGURATION_DESCRIPTOR, _PTR_ CONFIGURATION_DESCRIPTOR_PTR;  
+
+typedef struct usb_interface_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 9 */
+   uint_8   bDescriptorType;  /* INTERFACE descriptor type = 4 */
+   uint_8   bInterfaceNumber; /* Interface no.*/
+   uint_8   bAlternateSetting;  /* Value to select this IF */
+   uint_8   bNumEndpoints;    /* Number of endpoints excluding 0 */
+   uint_8   bInterfaceClass;  /* Class code, 0xFF = vendor */
+   uint_8   bInterfaceSubClass;  /* Sub-Class code, 0 if class = 0 */
+   uint_8   bInterfaceProtocol;  /* Protocol, 0xFF = vendor */
+   uint_8   iInterface;       /* Index to interface string */
+} INTERFACE_DESCRIPTOR, _PTR_ INTERFACE_DESCRIPTOR_PTR;  
+
+typedef struct usb_endpoint_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 7 */
+   uint_8   bDescriptorType;  /* ENDPOINT descriptor type = 5 */
+   uint_8   bEndpointAddress; /* Endpoint # 0 - 15 | IN/OUT */
+   #define  IN_ENDPOINT    (0x80)   /* IN endpoint, device to host */
+   #define  OUT_ENDPOINT   (0x00)   /* OUT endpoint, host to device */
+   #define  ENDPOINT_MASK  (0x0F)   /* Mask endpoint # */
+   uint_8   bmAttributes;     /* Transfer type */
+   #define  CONTROL_ENDPOINT  (0x00)   /* Control transfers */
+   #define  ISOCH_ENDPOINT    (0x01)   /* Isochronous transfers */
+   #define  BULK_ENDPOINT     (0x02)   /* Bulk transfers */
+   #define  IRRPT_ENDPOINT    (0x03)   /* Interrupt transfers */
+   #define  EP_TYPE_MASK      (0x03)   /* Mask type bits */
+   /* Following must be zero except for isochronous endpoints */
+   #define  ISOCH_NOSYNC      (0x00)   /* No synchronization */
+   #define  ISOCH_ASYNC       (0x04)   /* Asynchronous */
+   #define  ISOCH_ADAPT       (0x08)   /* Adaptive */
+   #define  ISOCH_SYNCH       (0x0C)   /* Synchrounous */
+   #define  ISOCH_DATA        (0x00)   /* Data endpoint */
+   #define  ISOCH_FEEDBACK    (0x10)   /* Feedback endpoint */
+   #define  ISOCH_IMPLICIT    (0x20)   /* Implicit feedback */
+   #define  ISOCH_RESERVED    (0x30)   /* Reserved */
+   uint_8   wMaxPacketSize[2];   /* Bits 10:0 = max. packet size */
+   /* For high-speed interrupt or isochronous only, additional
+   **   transaction opportunities per microframe follow.*/
+   #define  PACKET_SIZE_MASK     (0x7FF)  /* packet size bits */
+   #define  NO_ADDITONAL      (0x0000)   /* 1 / microframe */
+   #define  ONE_ADDITIONAL    (0x0800)   /* 2 / microframe */
+   #define  TWO_ADDITIONAL    (0x1000)   /* 3 / microframe */
+   #define  ADDITIONAL_MASK   (ONE_ADDITIONAL | TWO_ADDITIONAL)
+   uint_8   iInterval;        /* Polling interval in (micro) frames */
+} ENDPOINT_DESCRIPTOR, _PTR_ ENDPOINT_DESCRIPTOR_PTR;  
+
+typedef struct usb_qualifier_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 10 */
+   uint_8   bDescriptorType;  /* DEVICE QUALIFIER type = 6 */
+   uint_8   bcdUSD[2];        /* USB spec in BCD, e.g. 0x0200 */
+   uint_8   bDeviceClass;     /* Class code, if 0 see interface */
+   uint_8   bDeviceSubClass;  /* Sub-Class code, 0 if class = 0 */
+   uint_8   bDeviceProtocol;  /* Protocol, if 0 see interface */
+   uint_8   bMaxPacketSize;   /* Endpoint 0 max. size */
+   uint_8   bNumConfigurations; /* Number of possible configurations */
+   uint_8   bReserved;        /* Reserved = 0 */ 
+} QUALIFIER_DESCRIPTOR, _PTR_ QUALIFIER_DESCRIPTOR_PTR;  
+
+/* Other-Config type 7 fields are identical to type 2 above */
+
+/* Interface-Power descriptor  type 8 not used  in this version */
+
+typedef struct usb_otg_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 9 */
+   uint_8   bDescriptorType;  /* CONFIGURATION type = 2 or 7 */
+   uint_8   bmAttributes;     /* OTG characteristics */
+   #define  OTG_SRP_SUPPORT   (0x01)  /* Supports SRP */
+   #define  OTG_HNP_SUPPORT   (0x02)  /* Supports HNP */
+} OTG_DESCRIPTOR, _PTR_ OTG_DESCRIPTOR_PTR;  
+
+typedef union descriptor_union
+{
+   uint_32                       word;
+   uint_8_ptr                    bufr;
+   pointer                       pntr;
+   DEVICE_DESCRIPTOR_PTR         dvic;
+   CONFIGURATION_DESCRIPTOR_PTR  cfig;
+   INTERFACE_DESCRIPTOR_PTR      intf;
+   ENDPOINT_DESCRIPTOR_PTR       ndpt;
+   QUALIFIER_DESCRIPTOR_PTR      qual;
+   OTG_DESCRIPTOR_PTR            otg;
+}  DESCRIPTOR_UNION, _PTR_ DESCRIPTOR_UNION_PTR;
+                           
+/* Prototypes */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern uint_32 usb_host_init(uint_8, uint_32, 
+                  _usb_host_handle _PTR_);
+extern uint_32 _usb_host_open_pipe(_usb_host_handle, 
+                  PIPE_INIT_PARAM_STRUCT_PTR, _usb_pipe_handle _PTR_ );
+
+#ifdef __cplusplus
+}
+#endif                         
+
+#endif /* __mvUsbDesc_h__ */
+
+/* EOF */
+
diff --git a/board/pxa/common/usbeth/mvUsbDevApi.h b/board/pxa/common/usbeth/mvUsbDevApi.h
new file mode 100644
index 0000000..41c74d8
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDevApi.h
@@ -0,0 +1,161 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDevApi_h__
+#define __mvUsbDevApi_h__
+
+//#include <linux/kernel.h>
+
+#include "mvUsbTypes.h"
+#include "mvUsbDebug.h"
+#include "mvUsbDefs.h"
+
+#define ARC_USB_MAX_ENDPOINTS               (16)
+
+#define MAX_EP_TR_DESCRS                    (16)
+// xj modify xd queue size in blob
+#define MAX_XDS_FOR_TR_CALLS                (16)
+#define MAX_USB_DEVICES                     (1)
+
+/*Assumption here is that all control endpoints are sequential 0,1,..
+if they are not you need to modify the tr_complete routine to handle that */
+#define USB_MAX_CONTROL_ENDPOINTS           (1)
+
+#define USB_MAX_CTRL_PAYLOAD                (64)
+
+
+/* Endpoint types */
+#define  ARC_USB_CONTROL_ENDPOINT             (0)
+#define  ARC_USB_ISOCHRONOUS_ENDPOINT         (1)
+#define  ARC_USB_BULK_ENDPOINT                (2)
+#define  ARC_USB_INTERRUPT_ENDPOINT           (3)
+
+/* Informational Request/Set Types */
+#define  ARC_USB_STATUS_DEVICE_STATE          (0x01)
+#define  ARC_USB_STATUS_INTERFACE             (0x02)
+#define  ARC_USB_STATUS_ADDRESS               (0x03)
+#define  ARC_USB_STATUS_CURRENT_CONFIG        (0x04)
+#define  ARC_USB_STATUS_SOF_COUNT             (0x05)
+#define  ARC_USB_STATUS_DEVICE                (0x06)
+#define  ARC_USB_STATUS_TEST_MODE             (0x07)
+#define  ARC_USB_FORCE_FULL_SPEED             (0x08)
+#define  ARC_USB_PHY_LOW_POWER_SUSPEND        (0x09)
+
+#define  ARC_USB_STATUS_ENDPOINT_NUMBER_MASK  (0x000F)
+#define  ARC_USB_STATUS_ENDPOINT_DIR_MASK     (0x0080)
+
+#define  ARC_USB_TEST_MODE_TEST_PACKET        (0x0400)
+
+/* Available service types */
+/* Services 0 through 15 are reserved for endpoints */
+#define  ARC_USB_SERVICE_EP0                  (0x00)
+#define  ARC_USB_SERVICE_EP1                  (0x01)
+#define  ARC_USB_SERVICE_EP2                  (0x02)
+#define  ARC_USB_SERVICE_EP3                  (0x03)
+#define  ARC_USB_SERVICE_BUS_RESET            (0x10)
+#define  ARC_USB_SERVICE_SUSPEND              (0x11)
+#define  ARC_USB_SERVICE_SOF                  (0x12)
+#define  ARC_USB_SERVICE_RESUME               (0x13)
+#define  ARC_USB_SERVICE_SLEEP                (0x14)
+#define  ARC_USB_SERVICE_SPEED_DETECTION      (0x15)
+#define  ARC_USB_SERVICE_ERROR                (0x16)
+#define  ARC_USB_SERVICE_STALL                (0x17)
+
+typedef pointer _usb_device_handle;
+typedef void (*USB_SERVICE_FUNC)(void* handle, uint_8, boolean, uint_8, 
+                                                 uint_8_ptr, uint_32, uint_8);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void    _usb_dci_vusb20_isr(void* handle);
+
+void    _usb_device_set_bsp_funcs(USB_IMPORT_FUNCS* pBspFuncs);
+
+uint_8  _usb_device_init(uint_8 devNo, void** pHandle);
+
+uint_8  _usb_device_get_max_endpoint(void* handle);
+
+uint_8  _usb_device_get_dev_num(void* handle);
+
+void    _usb_device_shutdown(void* handle);
+
+void    _usb_device_stop(void* handle);
+void    _usb_device_start(void* handle);
+
+uint_8  _usb_device_init_endpoint(void* handle, uint_8 ep_num, uint_16 max_pkt_size, 
+                                  uint_8 direction, uint_8 type, uint_8 flag);
+uint_8  _usb_device_deinit_endpoint(void* handle, uint_8 ep_num, uint_8 direction);
+
+uint_8  _usb_device_recv_data(void* handle, uint_8 ep_num, uint_8* buf_ptr, uint_32 size);
+uint_8  _usb_device_send_data(void* handle, uint_8 ep_num, uint_8* buf_ptr, uint_32 size);
+uint_8  _usb_device_cancel_transfer(void* handle, uint_8 ep_num, uint_8 direction);
+uint_8  _usb_device_get_transfer_status(void* handle, uint_8 ep_num, uint_8 direction);
+void    _usb_device_stall_endpoint(void* handle, uint_8 ep_num, uint_8 direction);
+void    _usb_device_unstall_endpoint(void* handle, uint_8 ep_num, uint_8 direction);
+uint_8  _usb_device_is_endpoint_stalled(void* handle, uint_8 ep_num, uint_8 direction);
+void    _usb_device_assert_resume(void* handle);
+uint_8  _usb_device_get_status(void* handle, uint_8 component, uint_16* status_ptr);
+uint_8  _usb_device_set_status(void* handle, uint_8 component, uint_16 setting);
+void    _usb_device_read_setup_data(void* handle, uint_8 ep_num, uint_8* buf_ptr);
+
+uint_8  _usb_device_register_service(void* handle, uint_8 type, USB_SERVICE_FUNC serviceFunc);
+
+uint_8  _usb_device_unregister_service(void* handle, uint_8 type);
+
+
+
+/* These functions that implement USB 2.0 standard Chapter 9 Setup requests */
+void    mvUsbCh9GetStatus(void* handle, boolean setup, 
+                                  SETUP_STRUCT* ctrl_req);
+
+void    mvUsbCh9ClearFeature(void* handle, boolean setup, 
+                                   SETUP_STRUCT* setup_ptr);
+
+void    mvUsbCh9SetFeature(void* handle, boolean setup, 
+                                 SETUP_STRUCT* setup_ptr);
+
+void    mvUsbCh9SetAddress(void* handle, boolean setup, 
+                                   SETUP_STRUCT* setup_ptr);
+
+/* DEBUG Functions */
+void    _usb_dci_vusb20_set_test_mode(void* handle, uint_16 testMode);   
+
+void    _usb_debug_set_flags(uint_32 flags);     
+uint_32 _usb_debug_get_flags(void);
+     
+void    _usb_debug_init_trace_log(void);
+void    _usb_debug_print_trace_log(void);
+
+void    _usb_regs(void* usbHandle);
+void    _usb_status(void* usbHandle);
+void    _usb_stats(void* usbHandle);
+void    _usb_clear_stats(void* usbHandle);
+void    _usb_ep_status(void* usbHandle, int ep_num, int direction);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __mvUsbDevApi_h__ */
+/* EOF */
+
+
diff --git a/board/pxa/common/usbeth/mvUsbDevCh9.c b/board/pxa/common/usbeth/mvUsbDevCh9.c
new file mode 100644
index 0000000..60536f7
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDevCh9.c
@@ -0,0 +1,340 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+#include "mvUsbCh9.h"
+
+static volatile boolean  ENTER_TEST_MODE = FALSE; 
+static volatile uint_16  test_mode_index = 0;
+
+
+void    mvUsbCh9GetStatus(_usb_device_handle handle, boolean setup, 
+                         SETUP_STRUCT* ctrl_req)
+{ /* Body */
+    uint_8                  endpoint, direction;
+    uint_16                 usb_status;
+    USB_DEV_STATE_STRUCT*   usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle; 
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
+
+    if(!setup)
+        return;
+
+    switch (ctrl_req->REQUESTTYPE) 
+    {
+       case (REQ_DIR_IN | REQ_RECIP_DEVICE):
+          /* Device request */
+          _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
+          break;
+
+       case (REQ_DIR_IN | REQ_RECIP_INTERFACE):
+          /* Interface request */
+          _usb_device_get_status(handle, ARC_USB_STATUS_INTERFACE, &usb_status);
+          break;
+    
+       case (REQ_DIR_IN | REQ_RECIP_ENDPOINT):
+          /* Endpoint request */
+          endpoint = ctrl_req->INDEX & ARC_USB_STATUS_ENDPOINT_NUMBER_MASK;
+          if( (ctrl_req->INDEX & (1 << REQ_DIR_OFFSET)) == REQ_DIR_IN)
+            direction = ARC_USB_SEND;
+          else
+            direction = ARC_USB_RECV;
+
+          usb_status = _usb_device_is_endpoint_stalled(handle, endpoint, direction);
+          break;
+       
+       default:
+          /* Unknown request */
+           USB_printf("GetStatus: Unknown request type 0x%x\n", ctrl_req->REQUESTTYPE);
+          _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+          return;
+    } /* Endswitch */
+
+    /* Send the requested data */
+    *usb_dev_ptr->STATUS_PTR = USB_16BIT_LE(usb_status);
+    _usb_device_send_data(handle, 0, (uint_8_ptr)usb_dev_ptr->STATUS_PTR, sizeof(uint_16));
+    
+    /* status phase */
+    _usb_device_recv_data(handle, 0, NULL, 0);
+    
+    return;
+} /* Endbody */
+
+void    mvUsbCh9ClearFeature(_usb_device_handle handle, boolean setup, 
+                            SETUP_STRUCT* setup_ptr)
+{ /* Body */
+    uint_8   endpoint, direction;
+    uint_16  usb_status;
+     
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
+
+    _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_status);
+    if ((usb_status != ARC_USB_STATE_CONFIG) && (usb_status != ARC_USB_STATE_ADDRESS)) 
+    {
+        USB_printf("ClearFeature: Wrong USB state %d\n", usb_status);
+        _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+        return;
+    } /* Endif */
+
+    if(!setup)
+        return;
+
+    switch (setup_ptr->REQUESTTYPE) 
+    {
+        case (REQ_DIR_OUT | REQ_RECIP_DEVICE):
+            /* DEVICE */
+            switch(setup_ptr->VALUE)
+            {
+                case DEVICE_REMOTE_WAKEUP: 
+                    /* clear remote wakeup */
+                    _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
+                    usb_status &= ~ARC_USB_REMOTE_WAKEUP;
+                    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, usb_status);
+                    USB_printf("Clear REMOTE_WAKEUP feature\n");
+                    break;
+
+                case DEVICE_TEST_MODE:
+                    /* Exit Test Mode */
+                    _usb_device_set_status(handle, ARC_USB_STATUS_TEST_MODE, 0);
+                    break;
+
+                default:
+                    USB_printf("ClearFeature: Unknown Device feature %d\n", 
+                                setup_ptr->VALUE);
+                    _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                    return;
+            } /* Endif */
+            break;
+         
+        case (REQ_DIR_OUT | REQ_RECIP_ENDPOINT):
+            /* ENDPOINT */
+            if (setup_ptr->VALUE != ENDPOINT_HALT) 
+            {
+                USB_printf("ClearFeature: Wrong Endpoint feature %d\n", 
+                            setup_ptr->VALUE);
+                _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                return;
+            } /* Endif */
+
+            endpoint = setup_ptr->INDEX & ARC_USB_STATUS_ENDPOINT_NUMBER_MASK;
+            if( (setup_ptr->INDEX & (1 << REQ_DIR_OFFSET)) == REQ_DIR_IN)
+                direction = ARC_USB_SEND;
+            else
+                direction = ARC_USB_RECV;
+
+            _usb_device_unstall_endpoint(handle, endpoint, direction);
+            break;
+
+        default:
+            USB_printf("ClearFeature: Unknown REQUEST_TYPE %d\n", 
+                                setup_ptr->REQUESTTYPE);
+
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+    } /* Endswitch */
+      
+    /* status phase */
+    _usb_device_send_data(handle, 0, 0, 0);
+}
+
+void    mvUsbCh9SetFeature(_usb_device_handle handle, boolean setup, 
+                          SETUP_STRUCT* setup_ptr)
+{
+   uint_16                  usb_status;
+   uint_8                   endpoint, direction;
+   USB_DEV_STATE_STRUCT*    usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle; 
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
+
+   if (setup) 
+   {
+      switch (setup_ptr->REQUESTTYPE) 
+      {
+         case (REQ_DIR_OUT | REQ_RECIP_DEVICE):
+            /* DEVICE */
+            switch (setup_ptr->VALUE) 
+            {
+               case DEVICE_REMOTE_WAKEUP:
+                  /* set remote wakeup */
+                  _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
+                  usb_status |= ARC_USB_REMOTE_WAKEUP;
+                  _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, usb_status);
+                  USB_printf("Set REMOTE_WAKEUP feature\n");
+                  break;
+
+               case DEVICE_TEST_MODE:
+                  /* Test Mode */
+                  if( (setup_ptr->INDEX & 0x00FF) || (usb_dev_ptr->SPEED != ARC_USB_SPEED_HIGH) ) 
+                  {
+                     USB_printf("SetFeature: Wrong Test mode parameters: mode=%d, speed=%d\n", 
+                                (setup_ptr->INDEX & 0x00FF), usb_dev_ptr->SPEED);
+                     _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                     return;
+                  } /* Endif */
+
+                  _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_status);
+                  if( (usb_status == ARC_USB_STATE_CONFIG)  || 
+                      (usb_status == ARC_USB_STATE_ADDRESS) || 
+                      (usb_status == ARC_USB_STATE_DEFAULT)) 
+                  {
+                      /* wait with Set Test mode */
+                      ENTER_TEST_MODE = TRUE;
+                      test_mode_index = (setup_ptr->INDEX & 0xFF00);
+                      USB_printf("SetFeature: Prepare for Test mode 0x%x\n", test_mode_index);
+                  } 
+                  else 
+                  {
+                     USB_printf("SetFeature: Wrong USB state for Test mode: state=%d\n", 
+                                usb_status);
+                     _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                     return;
+                  } /* Endif */
+                  break;
+
+               default:
+                    USB_printf("SetFeature: Unknown Device feature %d\n", 
+                                setup_ptr->VALUE);
+                  _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                  return;
+            } /* Endswitch */
+            break;
+            
+         case (REQ_DIR_OUT | REQ_RECIP_ENDPOINT):
+            /* ENDPOINT */
+            if (setup_ptr->VALUE != ENDPOINT_HALT) 
+            {
+                USB_printf("SetFeature: Unknown Endpoint feature %d\n", 
+                            setup_ptr->VALUE);
+                _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                return;
+            } /* Endif */
+
+            endpoint = setup_ptr->INDEX & ARC_USB_STATUS_ENDPOINT_NUMBER_MASK;
+            if( (setup_ptr->INDEX & (1 << REQ_DIR_OFFSET)) == REQ_DIR_IN)
+                direction = ARC_USB_SEND;
+            else
+                direction = ARC_USB_RECV;
+
+            _usb_device_stall_endpoint(handle, endpoint, direction);
+            break;
+
+         default:
+            USB_printf("SetFeature: Unknown REQUEST_TYPE %d\n", 
+                       setup_ptr->REQUESTTYPE);
+
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+      } /* Endswitch */
+      
+      /* status phase */
+      _usb_device_send_data(handle, 0, 0, 0);
+   } 
+   else 
+   {
+      if (ENTER_TEST_MODE) 
+      {
+         /* Enter Test Mode */
+          USB_printf("SetFeature: Activate Test mode 0x%x\n", test_mode_index);
+         _usb_device_set_status(handle, ARC_USB_STATUS_TEST_MODE, test_mode_index);
+      } /* Endif */
+   } /* Endif */
+}
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : ch9SetAddress
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetAddress command
+*     We setup a TX packet of 0 length ready for the IN token
+*     Once we get the TOK_DNE interrupt for the IN token, then
+*     we change the ADDR register and go to the ADDRESS state.
+* 
+*END*--------------------------------------------------------------------*/
+void    mvUsbCh9SetAddress(_usb_device_handle handle,
+                        boolean setup, SETUP_STRUCT* setup_ptr)
+{ /* Body */
+   static uint_8            new_address;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "usbDisk %s: setup=%d, address=%d\n", 
+                                    __FUNCTION__, (int)setup, setup_ptr->VALUE);
+
+   if (setup) 
+   {
+      new_address = setup_ptr->VALUE;
+      /*******************************************************
+       * if hardware assitance is enabled for set_address (see
+       * hardware rev for details) we need to do the set_address
+       * before queuing the status phase.
+       *******************************************************/
+#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE      
+       _usb_device_set_status(handle, ARC_USB_STATUS_ADDRESS, new_address);
+#endif
+      /* ack */
+      _usb_device_send_data(handle, 0, 0, 0);
+   } 
+   else 
+   {
+#ifndef SET_ADDRESS_HARDWARE_ASSISTANCE
+      _usb_device_set_status(handle, ARC_USB_STATUS_ADDRESS, new_address);
+#endif
+      _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE, ARC_USB_STATE_ADDRESS);        
+   }
+}
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : ch9SetConfig
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetConfig command
+*     We setup a TX packet of 0 length ready for the IN token
+*     Once we get the TOK_DNE interrupt for the IN token, then
+*     we change the configuration number and go to the CONFIG state.
+* 
+*END*--------------------------------------------------------------------*/
+void    mvUsbCh9SetConfig(_usb_device_handle handle,
+                        boolean setup, SETUP_STRUCT* setup_ptr)
+{ /* Body */
+   static uint_8            new_config;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "%s: setup=%d, config=%d\n", 
+                                    __FUNCTION__, (int)setup, setup_ptr->VALUE);
+
+   if (setup) 
+   {
+      new_config = setup_ptr->VALUE;
+      /*******************************************************
+       * if hardware assitance is enabled for set_address (see
+       * hardware rev for details) we need to do the set_address
+       * before queuing the status phase.
+       *******************************************************/
+       _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, new_config);
+      /* ack */
+      _usb_device_send_data(handle, 0, 0, 0);
+   } 
+   else 
+   {
+      _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, new_config);
+      _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE, ARC_USB_STATE_CONFIG);        
+   }
+}
+
diff --git a/board/pxa/common/usbeth/mvUsbDevMain.c b/board/pxa/common/usbeth/mvUsbDevMain.c
new file mode 100644
index 0000000..2ad156b
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDevMain.c
@@ -0,0 +1,770 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+
+USB_IMPORT_FUNCS*           global_import_funcs = NULL;
+
+#ifdef USB_UNDERRUN_WA
+USB_WA_FUNCS*               global_wa_funcs = NULL;
+int                         global_wa_threshold = 64;
+int                         global_wa_sram_parts = 2;
+#endif /* USB_UNDERRUN_WA */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_cleanup
+*  Returned Value : void
+*  Comments       :
+*        Cleanup allocated structures.
+*
+*END*-----------------------------------------------------------------*/
+
+static void    _usb_device_cleanup(USB_DEV_STATE_STRUCT_PTR usb_dev_ptr)
+{
+    /* Free all internal transfer descriptors */
+    if(usb_dev_ptr->XD_BASE != NULL)
+    {
+        USB_memfree((pointer)usb_dev_ptr->XD_BASE);
+    }
+   
+    /* Free all XD scratch memory */
+    if(usb_dev_ptr->XD_SCRATCH_STRUCT_BASE != NULL)
+    {
+        USB_memfree((pointer)usb_dev_ptr->XD_SCRATCH_STRUCT_BASE);
+    }
+    /* Free the temp ep init XD */
+    if(usb_dev_ptr->TEMP_XD_PTR != NULL)
+    {
+        USB_memfree((pointer)usb_dev_ptr->TEMP_XD_PTR);
+    }
+
+    if(usb_dev_ptr->STATUS_UNAIGNED_PTR != NULL)
+        USB_memfree((pointer)usb_dev_ptr->STATUS_UNAIGNED_PTR);
+
+    if(usb_dev_ptr->TEST_PKT_UNAIGNED_PTR != NULL)
+        USB_memfree((pointer)usb_dev_ptr->TEST_PKT_UNAIGNED_PTR);
+
+    /* Free the USB state structure */
+    USB_memfree((pointer)usb_dev_ptr);
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_free_XD
+*  Returned Value : void
+*  Comments       :
+*        Enqueues a XD onto the free XD ring.
+*
+*END*-----------------------------------------------------------------*/
+
+void _usb_device_free_XD
+   (
+      /* [IN] the dTD to enqueue */
+      pointer  xd_ptr
+   )
+{ /* Body */
+    int                         lockKey;
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+  
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)(((XD_STRUCT_PTR)xd_ptr)->SCRATCH_PTR->PRIVATE);
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "free_XD: xd_ptr=0x%x\n", (unsigned)xd_ptr);
+
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.free_XD_count++));
+
+   /*
+   ** This function can be called from any context, and it needs mutual
+   ** exclusion with itself.
+   */
+
+   lockKey = USB_lock();
+
+   /*
+   ** Add the XD to the free XD queue (linked via PRIVATE) and
+   ** increment the tail to the next descriptor
+   */
+   USB_XD_QADD(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, (XD_STRUCT_PTR)xd_ptr);
+   usb_dev_ptr->XD_ENTRIES++;
+
+   USB_unlock(lockKey);
+
+} /* Endbody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_set_bsp_funcs
+*  Returned Value : NONE
+*  Comments       :
+*        Set pointer to structure of imported BSP functions
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_set_bsp_funcs(USB_IMPORT_FUNCS* pBspFuncs)
+{
+    static  boolean isFirst = TRUE;
+    
+    if(isFirst)
+    {
+        global_import_funcs = pBspFuncs;
+       _usb_debug_init_trace_log();
+       isFirst = FALSE;
+    }
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_get_max_endpoint
+*  Returned Value : handle or NULL
+*  Comments       :
+*        Return maximum number of endpoints supportedby USB device 
+*        (for DEBUG only)
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_get_max_endpoint(_usb_device_handle handle)
+{
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    return usb_dev_ptr->MAX_ENDPOINTS;
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_get_dev_num
+*  Returned Value : handle or NULL
+*  Comments       :
+*        Return unique USB device number
+*        (for DEBUG only)
+*
+*END*-----------------------------------------------------------------*/
+uint_8  _usb_device_get_dev_num(_usb_device_handle handle)
+{
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    return usb_dev_ptr->DEV_NUM;
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_init
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Initializes the USB device specific data structures and calls 
+*  the low-level device controller chip initialization routine.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_init
+   (
+      /* [IN] the USB device controller to initialize */
+      uint_8                    devnum,
+
+      /* [OUT] the USB_USB_dev_initialize state structure */
+      _usb_device_handle*       handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+   XD_STRUCT_PTR                    xd_ptr;
+   uint_8                           i, error;
+   SCRATCH_STRUCT_PTR               temp_scratch_ptr;
+
+   /* global_import_funcs must be initailized before */
+   if(global_import_funcs == NULL)
+       return USBERR_INIT_FAILED;
+
+   if (devnum > MAX_USB_DEVICES) 
+   {
+        USB_printf("_usb_device_init, error invalid device number");
+        return USBERR_INVALID_DEVICE_NUM;
+   } /* Endif */
+   
+   /* Allocate memory for the state structure */
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)USB_memalloc(sizeof(USB_DEV_STATE_STRUCT));      
+   if (usb_dev_ptr == NULL) 
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for USB_DEV_STATE_STRUCT failed\n", 
+                    sizeof(USB_DEV_STATE_STRUCT));
+        return USBERR_ALLOC_STATE;
+   } /* Endif */
+   
+   /* Zero out the internal USB state structure */
+   USB_memzero(usb_dev_ptr, sizeof(USB_DEV_STATE_STRUCT));
+    
+   usb_dev_ptr->DEV_NUM = devnum;
+
+   /* Multiple devices will have different base addresses and 
+   ** interrupt vectors (For future)
+   */   
+   usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
+   
+   /* Allocate MAX_XDS_FOR_TR_CALLS */
+   xd_ptr = (XD_STRUCT_PTR)USB_memalloc(sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS);      
+   if (xd_ptr == NULL) 
+   {
+        _usb_device_cleanup(usb_dev_ptr);
+        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n", 
+                        sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS, MAX_XDS_FOR_TR_CALLS);
+        return USBERR_ALLOC_TR;
+   } /* Endif */
+   
+   usb_dev_ptr->XD_BASE = xd_ptr;
+
+   _usb_clear_stats(usb_dev_ptr);
+
+   USB_memzero(xd_ptr, sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS);
+
+   /* Allocate memory for internal scratch structure */   
+   usb_dev_ptr->XD_SCRATCH_STRUCT_BASE = (SCRATCH_STRUCT_PTR)
+                    USB_memalloc(sizeof(SCRATCH_STRUCT) * MAX_XDS_FOR_TR_CALLS);
+   if (usb_dev_ptr->XD_SCRATCH_STRUCT_BASE == NULL) 
+   {
+        _usb_device_cleanup(usb_dev_ptr);
+        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n", 
+                        sizeof(SCRATCH_STRUCT) * MAX_XDS_FOR_TR_CALLS, MAX_XDS_FOR_TR_CALLS);
+        return USBERR_ALLOC;
+   } /* Endif */
+
+   temp_scratch_ptr = usb_dev_ptr->XD_SCRATCH_STRUCT_BASE;
+   usb_dev_ptr->XD_HEAD = NULL;
+   usb_dev_ptr->XD_TAIL = NULL;
+   usb_dev_ptr->XD_ENTRIES = 0;
+
+   /* Enqueue all the XDs */   
+   for (i=0;i<MAX_XDS_FOR_TR_CALLS;i++) 
+   {
+      xd_ptr->SCRATCH_PTR = temp_scratch_ptr;
+      xd_ptr->SCRATCH_PTR->FREE = _usb_device_free_XD;
+      xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+      _usb_device_free_XD((pointer)xd_ptr);
+      xd_ptr++;
+      temp_scratch_ptr++;
+   } /* Endfor */
+
+   usb_dev_ptr->TEMP_XD_PTR = (XD_STRUCT_PTR)USB_memalloc(sizeof(XD_STRUCT));
+   if(usb_dev_ptr->TEMP_XD_PTR == NULL)
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for TEMP_XD_STRUCT failed\n", 
+                        sizeof(XD_STRUCT));
+        _usb_device_cleanup(usb_dev_ptr);
+        return USBERR_ALLOC;
+   }
+   USB_memzero(usb_dev_ptr->TEMP_XD_PTR, sizeof(XD_STRUCT));
+
+   /* Allocate 2 bytes for USB_STATUS to be sent over USB, so Cache line aligned */
+   usb_dev_ptr->STATUS_UNAIGNED_PTR = (uint_8*)USB_memalloc(sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
+   if(usb_dev_ptr->STATUS_UNAIGNED_PTR == NULL)
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for USB_STATUS failed\n", 
+                        sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
+        _usb_device_cleanup(usb_dev_ptr);
+        return USBERR_ALLOC;
+   }
+   USB_memzero(usb_dev_ptr->STATUS_UNAIGNED_PTR, sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
+   usb_dev_ptr->STATUS_PTR = (uint_16*)USB_CACHE_ALIGN((uint_32)usb_dev_ptr->STATUS_UNAIGNED_PTR);
+
+   /* Allocate 53 bytes for USB Test packet to be sent over USB, so Cache line aligned */
+   usb_dev_ptr->TEST_PKT_UNAIGNED_PTR = (uint_8*)USB_memalloc(USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
+   if(usb_dev_ptr->TEST_PKT_UNAIGNED_PTR == NULL)
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for USB Test packet failed\n", 
+                        USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
+        _usb_device_cleanup(usb_dev_ptr);
+        return USBERR_ALLOC;
+   }
+   USB_memzero(usb_dev_ptr->TEST_PKT_UNAIGNED_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
+   usb_dev_ptr->TEST_PKT_PTR = (uint_8*)USB_CACHE_ALIGN((uint_32)usb_dev_ptr->TEST_PKT_UNAIGNED_PTR);
+
+   
+   /* Initialize the USB controller chip */
+   error = _usb_dci_vusb20_init(devnum, usb_dev_ptr);
+   if (error) 
+   {
+        _usb_device_cleanup(usb_dev_ptr);
+        USB_printf("_usb_device_init, init failed");
+        return USBERR_INIT_FAILED;
+   } /* Endif */
+
+   USB_printf("device_init: pDev=0x%x, pXD(%d)=0x%x, pSCRATCH(%d)=0x%x, pTempXD=0x%x\n",
+                (unsigned)usb_dev_ptr, MAX_XDS_FOR_TR_CALLS, (unsigned)usb_dev_ptr->XD_BASE,
+                MAX_XDS_FOR_TR_CALLS, (unsigned)usb_dev_ptr->XD_SCRATCH_STRUCT_BASE,
+                (unsigned)usb_dev_ptr->TEMP_XD_PTR);
+
+   *handle = usb_dev_ptr;
+   return USB_OK;   
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_shutdown
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Shutdown an initialized USB device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_shutdown(_usb_device_handle handle)
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+    SERVICE_STRUCT_PTR           service_ptr;
+    int                          ep;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CTRL, "shutdown\n");
+   
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    for(ep=0; ep<(usb_dev_ptr->MAX_ENDPOINTS); ep++)
+    {
+        /* Cancel all transfers on all endpoints */
+        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_RECV) != 
+                                                    ARC_USB_STATUS_IDLE)
+        {
+            _usb_device_cancel_transfer(handle, ep, ARC_USB_RECV);
+        }
+        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_SEND) != 
+                                                    ARC_USB_STATUS_IDLE)
+        {
+            _usb_device_cancel_transfer(handle, ep, ARC_USB_SEND);
+        }
+    }
+    _usb_dci_vusb20_shutdown(usb_dev_ptr);
+   
+    /* Free all the Callback function structure memory */
+    for( service_ptr = usb_dev_ptr->SERVICE_HEAD_PTR; service_ptr;
+         service_ptr = service_ptr->NEXT) 
+    {
+        USB_printf("_usb_device_shutdown: free service_ptr = 0x%x\n", 
+                            service_ptr);
+        USB_memfree(service_ptr);
+    }
+    usb_dev_ptr->SERVICE_HEAD_PTR = NULL;
+
+    _usb_device_cleanup(usb_dev_ptr);
+} /* EndBody */
+
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : _usb_device_register_service
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Registers a callback routine for a specified event or endpoint.
+* 
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_register_service
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle         handle,
+      
+      /* [IN] type of event or endpoint number to service */
+      uint_8                     type,
+      
+      /* [IN] Pointer to the service's callback function */
+      void(_CODE_PTR_ service)(pointer, uint_8, boolean, uint_8, uint_8_ptr, uint_32, uint_8)
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR   usb_dev_ptr;
+   SERVICE_STRUCT_PTR         service_ptr;
+   SERVICE_STRUCT_PTR _PTR_   search_ptr;
+   int                        lockKey;
+ 
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   /* Needs mutual exclusion */
+   lockKey = USB_lock();
+   
+   /* Search for an existing entry for type */
+   for (search_ptr = &usb_dev_ptr->SERVICE_HEAD_PTR;
+      *search_ptr;
+      search_ptr = &(*search_ptr)->NEXT) 
+   {
+      if ((*search_ptr)->TYPE == type) 
+      {
+         /* Found an existing entry */
+         USB_unlock(lockKey);
+         USB_printf("_usb_device_register_service, service %d already opened\n");
+         return USBERR_OPEN_SERVICE;
+      } /* Endif */
+   } /* Endfor */
+   
+   /* No existing entry found - create a new one */
+   service_ptr = (SERVICE_STRUCT_PTR)USB_memalloc(sizeof(SERVICE_STRUCT));
+   if (!service_ptr) 
+   {
+      USB_unlock(lockKey);
+      USB_printf("_usb_device_register_service, malloc for %d bytes failed\n", 
+                    sizeof(SERVICE_STRUCT));
+      return USBERR_ALLOC;
+   } /* Endif */
+
+   service_ptr->TYPE = type;
+   service_ptr->SERVICE = service;
+   service_ptr->NEXT = NULL;
+   *search_ptr = service_ptr;
+   
+   USB_unlock(lockKey);
+
+   return USB_OK;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : _usb_device_unregister_service
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Unregisters a callback routine for a specified event or endpoint.
+* 
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_unregister_service
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle         handle,
+
+      /* [IN] type of event or endpoint number to service */
+      uint_8                     type
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR   usb_dev_ptr;
+   SERVICE_STRUCT_PTR         service_ptr;
+   SERVICE_STRUCT_PTR _PTR_   search_ptr;
+   int                        lockKey;
+ 
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   /* Needs mutual exclusion */
+   lockKey = USB_lock();
+   
+   /* Search for an existing entry for type */
+   for (search_ptr = &usb_dev_ptr->SERVICE_HEAD_PTR;
+      *search_ptr;
+      search_ptr = &(*search_ptr)->NEXT) 
+   {
+      if ((*search_ptr)->TYPE == type) {
+         /* Found an existing entry - delete it */
+         break;
+      } /* Endif */
+   } /* Endfor */
+   
+   /* No existing entry found */
+   if (!*search_ptr) 
+   {
+      USB_unlock(lockKey);
+      USB_printf("_usb_device_unregister_service, no service found\n");
+      return USBERR_CLOSED_SERVICE;
+   } /* Endif */
+   
+   service_ptr = *search_ptr;
+   *search_ptr = service_ptr->NEXT;
+
+   USB_memfree((pointer)service_ptr);
+   
+   USB_unlock(lockKey);
+
+   return USB_OK;
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : _usb_device_call_service
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Calls the appropriate service for the specified type, if one is
+*     registered. Used internally only.
+* 
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_call_service
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle   handle,
+
+      /* [OUT] Type of service or endpoint */
+      uint_8               type,
+      
+      /* [OUT] Is it a Setup transfer? */
+      boolean              setup,
+      
+      /* [OUT] Direction of transmission; is it a Transmit? */
+      boolean              direction,
+
+      /* [OUT] Pointer to the data */
+      uint_8_ptr           buffer_ptr,
+      
+      /* [OUT] Number of bytes in transmission */
+      uint_32              length,
+
+      /* [OUT] Any errors */
+      uint_8               errors
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   SERVICE_STRUCT _PTR_         service_ptr;
+   int                          lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   /* Needs mutual exclusion */
+   lockKey = USB_lock();
+   
+   /* Search for an existing entry for type */
+   for (service_ptr = usb_dev_ptr->SERVICE_HEAD_PTR;
+        service_ptr;
+        service_ptr = service_ptr->NEXT) 
+   {
+      if (service_ptr->TYPE == type) 
+      {
+         service_ptr->SERVICE(handle, type, setup, direction, buffer_ptr, length, errors);
+         USB_unlock(lockKey);
+
+         return USB_OK;
+      } /* Endif */
+      
+   } /* Endfor */
+
+   USB_unlock(lockKey);
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CTRL, "_usb_device_call_service, service %d is closed\n", type);
+
+   return USBERR_CLOSED_SERVICE;
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_init_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Initializes the endpoint and the data structures associated with the 
+*  endpoint
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_init_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] MAX Packet size for this endpoint */
+      uint_16                    max_pkt_size,
+            
+      /* [IN] Direction */
+      uint_8                     direction,
+            
+      /* [IN] Type of Endpoint */
+      uint_8                     type,
+            
+      /* [IN] After all data is transfered, should we terminate the transfer 
+      ** with a zero length packet if the last packet size == MAX_PACKET_SIZE? 
+      */
+      uint_8                     flag   
+   )
+{ /* Body */
+
+    int                         lockKey;
+    uint_8                      error = 0;
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+   
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    /* Initialize the transfer descriptor */
+    usb_dev_ptr->TEMP_XD_PTR->EP_NUM = ep_num;
+    usb_dev_ptr->TEMP_XD_PTR->BDIRECTION = direction;
+    usb_dev_ptr->TEMP_XD_PTR->WMAXPACKETSIZE = max_pkt_size;
+    usb_dev_ptr->TEMP_XD_PTR->EP_TYPE = type;
+    usb_dev_ptr->TEMP_XD_PTR->DONT_ZERO_TERMINATE = flag;
+    usb_dev_ptr->TEMP_XD_PTR->MAX_PKTS_PER_UFRAME = 
+                    ((flag & ARC_USB_MAX_PKTS_PER_UFRAME) >> 1);
+
+    lockKey = USB_lock();
+    error = _usb_dci_vusb20_init_endpoint(handle, usb_dev_ptr->TEMP_XD_PTR);
+    USB_unlock(lockKey);
+   
+   return error;
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_deinit_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*  Disables the endpoint and the data structures associated with the 
+*  endpoint
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_deinit_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                    ep_num,
+            
+      /* [IN] Direction */
+      uint_8                    direction
+   )
+{ /* Body */
+   int                          lockKey;
+   uint_8                       error = 0;
+   lockKey = USB_lock();
+
+   error = _usb_dci_vusb20_deinit_endpoint(handle, ep_num, direction);
+   
+   USB_unlock(lockKey);
+   
+   return error;
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_get_transfer_status
+*  Returned Value : Status of the transfer
+*  Comments       :
+*        returns the status of the transaction on the specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_get_transfer_status
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   uint_8                       status;
+   int                          lockKey;
+
+   lockKey = USB_lock();
+
+   status = _usb_dci_vusb20_get_transfer_status(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+   /* Return the status of the last queued transfer */
+   return (status);
+
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_read_setup_data
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Reads the setup data from the hardware
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_read_setup_data
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] buffer for receiving Setup packet */
+      uint_8_ptr                  buff_ptr
+   )
+{ /* Body */
+   int                           lockKey;
+ 
+   lockKey = USB_lock();
+
+   _usb_dci_vusb20_get_setup_data(handle, ep_num, buff_ptr);
+
+   USB_unlock(lockKey);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_cancel_transfer
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        returns the status of the transaction on the specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_cancel_transfer
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   uint_8                        error = USB_OK;
+   int                           lockKey;
+   
+   lockKey = USB_lock();
+
+   /* Cancel transfer on the specified endpoint for the specified 
+   ** direction 
+   */
+   error = _usb_dci_vusb20_cancel_transfer(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+   return error;
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_stop
+*  Returned Value : None
+*  Comments       :
+*        Stop USB device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_stop(_usb_device_handle handle)
+{
+    int         lockKey;
+
+    lockKey = USB_lock();
+    _usb_dci_vusb20_stop(handle);
+    USB_unlock(lockKey);
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_start
+*  Returned Value : None
+*  Comments       :
+*        Start USB device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_start(_usb_device_handle handle)
+{
+    int         lockKey;
+
+    lockKey = USB_lock();
+    _usb_dci_vusb20_start(handle);
+    USB_unlock(lockKey);
+}
+
diff --git a/board/pxa/common/usbeth/mvUsbDevPrv.h b/board/pxa/common/usbeth/mvUsbDevPrv.h
new file mode 100644
index 0000000..b3af624
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDevPrv.h
@@ -0,0 +1,270 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDevPrv_h__
+#define __mvUsbDevPrv_h__
+
+#include "mvUsbCore.h"
+
+//xj add
+#define SET_ADDRESS_HARDWARE_ASSISTANCE 1
+
+#define USB_TEST_MODE_TEST_PACKET_LENGTH   (53)
+
+ 
+#define USB_XD_QADD(head,tail,XD)      \
+   if ((head) == NULL) {         \
+      (head) = (XD);            \
+   } else {                      \
+      (tail)->SCRATCH_PTR->PRIVATE = (XD);   \
+   } /* Endif */                 \
+   (tail) = (XD);               \
+   (XD)->SCRATCH_PTR->PRIVATE = NULL
+   
+#define USB_XD_QGET(head,tail,XD)      \
+   (XD) = (head);               \
+   if (head) {                   \
+      (head) = (XD_STRUCT_PTR)((head)->SCRATCH_PTR->PRIVATE);  \
+      if ((head) == NULL) {      \
+         (tail) = NULL;          \
+      } /* Endif */              \
+   } /* Endif */
+
+#define EHCI_DTD_QADD(head,tail,dTD)      \
+   if ((head) == NULL) {         \
+      (head) = (dTD);            \
+   } else {                      \
+      (tail)->SCRATCH_PTR->PRIVATE = (void *) (dTD);   \
+   } /* Endif */                 \
+   (tail) = (dTD);               \
+   (dTD)->SCRATCH_PTR->PRIVATE = NULL
+   
+#define EHCI_DTD_QGET(head,tail,dTD)      \
+   (dTD) = (head);               \
+   if (head) {                   \
+      (head) = (head)->SCRATCH_PTR->PRIVATE;  \
+      if ((head) == NULL) {      \
+         (tail) = NULL;          \
+      } /* Endif */              \
+   } /* Endif */
+
+/***************************************
+**
+** Data structures
+**
+*/
+
+typedef struct
+{
+    uint_32     usb_isr_count;
+    uint_32     usb_reset_count;
+    uint_32     usb_send_count;
+    uint_32     usb_recv_count;
+    uint_32     usb_setup_count;
+    uint_32     free_XD_count;
+    uint_32     free_dTD_count;
+    uint_32     usb_cancel_count;
+    uint_32     usb_add_count;
+    uint_32     usb_add_not_empty_count;
+    uint_32     usb_empty_isr_count;
+    uint_32     usb_empty_complete_count;
+    uint_32     usb_read_setup_count;
+    uint_32     usb_complete_isr_count;
+    uint_32     usb_complete_count;
+    uint_32     usb_complete_max_count;
+    uint_32     usb_port_change_count; 
+    uint_32     usb_suspend_count;
+    uint_32     usb_complete_ep_count[ARC_USB_MAX_ENDPOINTS*2];
+
+} USB_STATS;
+
+
+
+/* Callback function storage structure */
+typedef struct service_struct 
+{
+    uint_8   TYPE;
+    void     (_CODE_PTR_ SERVICE)(pointer, uint_8, boolean, uint_8, uint_8_ptr, uint_32, uint_8);
+    struct service_struct _PTR_   NEXT;
+
+} SERVICE_STRUCT, _PTR_ SERVICE_STRUCT_PTR;
+
+typedef struct xd_struct 
+{
+    uint_8         EP_NUM;           /* Endpoint number */
+    uint_8         BDIRECTION;       /* Direction : Send/Receive */
+    uint_8         EP_TYPE;          /* Type of the endpoint: Ctrl, Isoch, Bulk, Int */
+    uint_8         BSTATUS;          /* Current transfer status */
+    uint_8_ptr     WSTARTADDRESS;    /* Address of first byte */
+    uint_32        WTOTALLENGTH;     /* Number of bytes to send/recv */
+    uint_32        WSOFAR;           /* Number of bytes recv'd so far */
+    uint_16        WMAXPACKETSIZE;   /* Max Packet size */
+    boolean        DONT_ZERO_TERMINATE;
+    uint_8         MAX_PKTS_PER_UFRAME;
+    SCRATCH_STRUCT *SCRATCH_PTR;
+} XD_STRUCT, _PTR_ XD_STRUCT_PTR;
+
+/* The USB Device State Structure */
+typedef struct 
+{
+    boolean                          BUS_RESETTING;       /* Device is 
+                                                         ** being reset */
+    volatile VUSB20_REG_STRUCT_PTR   CAP_REGS_PTR;        /* Capabilities registers */
+
+    volatile VUSB20_REG_STRUCT_PTR   DEV_PTR;            /* Device Controller 
+                                                         ** Register base 
+                                                         ** address */
+
+    SERVICE_STRUCT_PTR               SERVICE_HEAD_PTR;   /* Head struct 
+                                                         ** address of 
+                                                         ** registered services 
+                                                         */
+    XD_STRUCT_PTR                    TEMP_XD_PTR;         /* Temp xd for ep init */
+    XD_STRUCT_PTR                    XD_BASE;
+    XD_STRUCT_PTR                    XD_HEAD;             /* Head Transaction 
+                                                         ** descriptors 
+                                                         */
+    XD_STRUCT_PTR                    XD_TAIL;             /* Tail Transaction 
+                                                         ** descriptors 
+                                                         */
+    uint_32                          XD_ENTRIES;
+    uint_8*                          EP_QUEUE_HEAD_BASE;
+    uint_32                          EP_QUEUE_HEAD_PHYS;
+    uint_32                          EP_QUEUE_HEAD_SIZE;
+    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  EP_QUEUE_HEAD_PTR;   /* Endpoint Queue head */   
+
+    uint_8*                          DTD_BASE_PTR;        /* Device transfer descriptor pool address */
+    uint_32                          DTD_BASE_PHYS;
+    uint_32                          DTD_SIZE;
+    VUSB20_EP_TR_STRUCT_PTR          DTD_ALIGNED_BASE_PTR;/* Aligned transfer descriptor pool address */
+
+    VUSB20_EP_TR_STRUCT_PTR          DTD_HEAD;
+    VUSB20_EP_TR_STRUCT_PTR          DTD_TAIL;
+    VUSB20_EP_TR_STRUCT_PTR          EP_DTD_HEADS[ARC_USB_MAX_ENDPOINTS * 2];
+    VUSB20_EP_TR_STRUCT_PTR          EP_DTD_TAILS[ARC_USB_MAX_ENDPOINTS * 2];
+    SCRATCH_STRUCT_PTR               XD_SCRATCH_STRUCT_BASE;
+   
+   
+    SCRATCH_STRUCT_PTR               SCRATCH_STRUCT_BASE;
+   
+    uint_16                          USB_STATE;
+    uint_16                          USB_DEVICE_STATE;
+    uint_16                          USB_SOF_COUNT;
+    uint_16                          DTD_ENTRIES;
+    uint_16                          ERRORS;
+    uint_16                          ERROR_STATE;
+    uint_16                          USB_DEV_STATE_B4_SUSPEND;
+    uint_8                           DEV_NUM;             /* USB device number 
+                                                         ** on the board 
+                                                         */
+    uint_8                           SPEED;               /* Low Speed, 
+                                                         ** High Speed, 
+                                                         ** Full Speed 
+                                                         */
+    uint_8                           MAX_ENDPOINTS;       /* Max endpoints
+                                                         ** supported by this
+                                                         ** device
+                                                         */
+                                                         
+    uint_8                           USB_CURR_CONFIG;                                                         
+    uint_8                           DEVICE_ADDRESS;
+    uint_8                           FORCE_FS;
+    USB_STATS                        STATS;
+
+    uint_8*                          STATUS_UNAIGNED_PTR;
+    uint_16*                         STATUS_PTR;
+
+    uint_8*                          TEST_PKT_UNAIGNED_PTR;
+    uint_8*                          TEST_PKT_PTR;
+
+} USB_DEV_STATE_STRUCT, _PTR_ USB_DEV_STATE_STRUCT_PTR;
+
+/* ONLY For data bases allocated by the driver (when PHYS and VIRT bases are known) */
+#define USB_EP_QH_VIRT_TO_PHYS(handle, virtAddr)                                                    \
+    (((virtAddr) == NULL) ? 0 : ((handle)->EP_QUEUE_HEAD_PHYS +                                \
+                          ((uint_32)(virtAddr) - (uint_32)(handle)->EP_QUEUE_HEAD_BASE)))
+
+#define USB_DTD_VIRT_TO_PHYS(handle, virtAddr)                                                    \
+    (((virtAddr) == NULL) ? 0 : ((handle)->DTD_BASE_PHYS +                                \
+                          ((uint_32)(virtAddr) - (uint_32)(handle)->DTD_BASE_PTR)))
+
+#define USB_DTD_PHYS_TO_VIRT(handle, physAddr)                                                    \
+    (((physAddr) == 0) ? NULL : ((handle)->DTD_BASE_PTR +                             \
+                                ((physAddr) - (handle)->DTD_BASE_PHYS)))
+
+
+/***************************************
+**
+** Prototypes
+**
+*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern uint_8  _usb_device_call_service(void* handle, uint_8, boolean,
+                                 boolean, uint_8_ptr, uint_32, uint_8);
+
+extern uint_8   _usb_dci_vusb20_init(uint_8, _usb_device_handle);
+extern void     _usb_device_free_XD(pointer);
+extern void     _usb_dci_vusb20_free_dTD(pointer);
+extern uint_8   _usb_dci_vusb20_add_dTD(_usb_device_handle, XD_STRUCT_PTR);
+extern uint_8   _usb_dci_vusb20_cancel_transfer(_usb_device_handle, uint_8, uint_8);
+extern uint_8   _usb_dci_vusb20_get_transfer_status(_usb_device_handle, uint_8, uint_8);
+extern XD_STRUCT_PTR _usb_dci_vusb20_get_transfer_details(_usb_device_handle, uint_8, uint_8);
+extern void     _usb_dci_vusb20_process_tr_complete(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_reset(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_tr_complete(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_suspend(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_SOF(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_port_change(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_error(_usb_device_handle);
+extern void     _usb_dci_vusb20_shutdown(_usb_device_handle);
+extern void     _usb_dci_vusb20_set_speed_full(_usb_device_handle, uint_8);
+extern void     _usb_dci_vusb20_suspend_phy(_usb_device_handle, uint_8);
+extern void     _usb_dci_vusb20_hnp_shutdown(void);
+extern void     _usb_dci_vusb20_set_address(_usb_device_handle, uint_8);
+extern void     _usb_dci_vusb20_get_setup_data(_usb_device_handle, uint_8, uint_8_ptr);
+extern void     _usb_dci_vusb20_assert_resume(_usb_device_handle);
+extern uint_8   _usb_dci_vusb20_init_endpoint(_usb_device_handle, XD_STRUCT_PTR);
+extern void     _usb_dci_vusb20_stall_endpoint(_usb_device_handle, uint_8, uint_8);
+extern void     _usb_dci_vusb20_unstall_endpoint(_usb_device_handle, uint_8, uint_8);
+extern uint_8   _usb_dci_vusb20_is_endpoint_stalled(_usb_device_handle, uint_8, uint_8);
+extern uint_8   _usb_dci_vusb20_deinit_endpoint(_usb_device_handle, uint_8, uint_8);
+extern void     _usb_dci_vusb20_chip_initialize(_usb_device_handle);
+extern void     _usb_dci_vusb20_stop(_usb_device_handle handle);
+extern void     _usb_dci_vusb20_start(_usb_device_handle handle);
+
+#if defined(USB_UNDERRUN_WA)
+
+extern uint_8*  usbSramBase;
+extern int      usbSramSize;
+
+void    _usb_reset_send_queue(void);
+void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir, 
+                        uint_8_ptr buffer, uint_32 length, uint_8 error);
+#endif /* USB_UNDERRUN_WA */
+                         
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/board/pxa/common/usbeth/mvUsbDevRecv.c b/board/pxa/common/usbeth/mvUsbDevRecv.c
new file mode 100644
index 0000000..492a6db
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDevRecv.c
@@ -0,0 +1,100 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_recv_data
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Receives data on a specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_recv_data
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] buffer to receive data */
+      uint_8_ptr                 buff_ptr,
+            
+      /* [IN] length of the transfer */
+      uint_32                    size
+   )
+{ /* Body */
+    int                              lockKey;
+    uint_8                           error = USB_OK;
+    XD_STRUCT_PTR                    xd_ptr;
+    USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+   
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RX, "recv_data: ep=%d, buf_ptr=0x%x, size=%d\n",
+                                       ep_num, (unsigned)buff_ptr, (int)size);
+
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_recv_count++));
+
+    if(buff_ptr != NULL)
+        USB_dcache_inv((pointer)buff_ptr,size);   
+    
+    lockKey = USB_lock();
+
+    if (!usb_dev_ptr->XD_ENTRIES) 
+    {
+        USB_unlock(lockKey);
+        USB_printf("_usb_device_recv_data, transfer in progress\n");
+        return ARC_USB_STATUS_TRANSFER_IN_PROGRESS;
+    } /* Endif */
+
+    /* Get a transfer descriptor for the specified endpoint 
+    ** and direction 
+    */
+    USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
+   
+    usb_dev_ptr->XD_ENTRIES--;
+
+    /* Initialize the new transfer descriptor */      
+    xd_ptr->EP_NUM = ep_num;
+    xd_ptr->BDIRECTION = ARC_USB_RECV;
+    xd_ptr->WTOTALLENGTH = size;
+    xd_ptr->WSOFAR = 0;
+    xd_ptr->WSTARTADDRESS = buff_ptr;
+   
+    xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
+
+    error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
+
+    USB_unlock(lockKey);
+   
+    if (error) 
+    {
+        USB_printf("_usb_device_recv_data, receive failed\n");
+        return USBERR_RX_FAILED;
+    } /* Endif */
+
+    return error;
+
+} /* EndBody */
+
diff --git a/board/pxa/common/usbeth/mvUsbDevSend.c b/board/pxa/common/usbeth/mvUsbDevSend.c
new file mode 100644
index 0000000..ff9ce1c
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDevSend.c
@@ -0,0 +1,373 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+
+#if defined(USB_UNDERRUN_WA)
+
+typedef struct
+{
+    uint_8*     buff_ptr[MAX_XDS_FOR_TR_CALLS];
+    uint_32     size[MAX_XDS_FOR_TR_CALLS];
+    uint_8      ep_num[MAX_XDS_FOR_TR_CALLS];
+    int         head;
+    int         tail;
+    int         tail_dma;
+    int         num;
+    int         num_dma;
+
+} USB_SEND_QUEUE;
+
+uint_8*         usbSramBase;
+int             usbSramSize;
+int		        usbSramPartSize;
+USB_SEND_QUEUE  usbSendQueue;
+
+uint_32         usbSentSize = 0;
+uint_32         usbDmaSize = 0;
+
+#define S_FREE	    0
+#define S_BUSY	    1
+
+uint_32		    dma_index = 0;
+uint_32		    sent_index = 0;
+uint_32		    sram_parts[USB_SRAM_MAX_PARTS];
+
+
+void    _usb_reset_send_queue(void)
+{
+    int     i;
+
+    usbSendQueue.num = 0;
+	usbSendQueue.num_dma = 0;
+    usbSendQueue.head = 0;
+    usbSendQueue.tail = 0;
+	usbSendQueue.tail_dma = 0;
+    for(i=0; i<MAX_XDS_FOR_TR_CALLS; i++)
+    {
+        usbSendQueue.size[i] = 0;
+        usbSendQueue.buff_ptr[i] = NULL;
+        usbSendQueue.ep_num[i] = 0;
+    }        
+	usbSramPartSize = usbSramSize/global_wa_sram_parts;
+
+    for(i=0; i<global_wa_sram_parts; i++)
+    {
+		sram_parts[i] = S_FREE;
+    }
+}
+
+uint_8 _usb_prepare_to_send(void*   handle)
+{
+    XD_STRUCT_PTR               xd_ptr;
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+    uint_8*                     buff_ptr;
+    uint_8*			            tmp_buff;
+    uint_32                     size;
+    int                         num_dma, tail_dma, i;
+    uint_8			            error = 0;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    tail_dma = usbSendQueue.tail_dma;
+    num_dma = usbSendQueue.num_dma;
+    buff_ptr = usbSendQueue.buff_ptr[tail_dma];
+    size = usbSendQueue.size[tail_dma];
+
+    if(num_dma == 0)
+	    return 0;
+
+/*
+    USB_printf("_usb_prepare_to_send: num=%d, tail=%d, sentSize=%d, size=%d, buff=%p\n", 
+                num_dma, tail_dma, usbSentSize, size, buff_ptr);
+*/
+    for(i=0; i<global_wa_sram_parts; i++)
+    {
+	    if(sram_parts[dma_index] != S_FREE)
+	        break;
+	
+	    if(usbDmaSize >= usbSendQueue.size[tail_dma])
+	    {
+	        /* Remove from the usbSendQueues */
+	        num_dma--;
+            tail_dma++;
+            if(tail_dma == MAX_XDS_FOR_TR_CALLS)
+                tail_dma = 0;
+
+            usbSendQueue.tail_dma = tail_dma;
+            usbSendQueue.num_dma = num_dma;
+            usbDmaSize = 0;
+
+            if(num_dma == 0)
+                break;
+        }
+
+	    buff_ptr = usbSendQueue.buff_ptr[tail_dma] + usbDmaSize;
+	    size = MIN(usbSramPartSize, (usbSendQueue.size[tail_dma] - usbDmaSize) ); 
+
+	    usbDmaSize += size;
+
+	    if(size > global_wa_threshold)
+	    {
+	        tmp_buff = buff_ptr;
+	        buff_ptr = (uint_8*)((int)usbSramBase + (dma_index * usbSramPartSize));
+	        USB_idma_copy(buff_ptr, tmp_buff, size);
+
+	        sram_parts[dma_index] = S_BUSY;
+            dma_index++;
+            if(dma_index == global_wa_sram_parts)
+                dma_index = 0;
+	    }
+        
+
+	    /* Get a transfer descriptor */
+	    USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
+
+	    usb_dev_ptr->XD_ENTRIES--;
+	    USB_dcache_flush((pointer)buff_ptr, size);   
+
+	    /* Initialize the new transfer descriptor */      
+	    xd_ptr->EP_NUM = usbSendQueue.ep_num[tail_dma];
+	    xd_ptr->BDIRECTION = ARC_USB_SEND;
+	    xd_ptr->WTOTALLENGTH = size;
+	    xd_ptr->WSOFAR = 0;
+	    xd_ptr->WSTARTADDRESS = buff_ptr;   
+	    xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
+
+	    error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
+
+	    if(error)
+	        break;
+    }
+
+    return error;    
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : usbSendComplete
+*  Returned Value : None
+*  Comments       :
+*        Callback for send transfer complete event.
+*
+*END*-----------------------------------------------------------------*/
+void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir, 
+                        uint_8_ptr buffer, uint_32 length, uint_8 error)
+{
+    /* Check if this complete is one from the sendQueue */
+    if( (usbSendQueue.ep_num[usbSendQueue.tail] == type) &&
+        (usbSendQueue.num > 0) )
+    {
+        USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+        uint_8*                     buff_ptr;
+        uint_32                     size;
+        int                         num, tail;
+
+        usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+        tail = usbSendQueue.tail;
+        num = usbSendQueue.num;
+        buff_ptr = usbSendQueue.buff_ptr[tail];
+        size = usbSendQueue.size[tail];
+/*
+        USB_printf("usbSendComplete: num=%d, tail=%d, usbSentSize=%d, type=%d, length=%d (%d), buff=%p (%p)\n", 
+                num, tail, usbSentSize, type, length, usbSendQueue.size[tail], 
+                buffer, usbSendQueue.buff_ptr[tail]);
+*/
+        usbSentSize += length;
+
+	    /* if the buffer was on the SRAM */
+	    if( ((unsigned)buffer >= (unsigned)usbSramBase) &&
+	    ((unsigned)buffer < ((unsigned)usbSramBase + (usbSramPartSize * global_wa_sram_parts))) )
+	    {
+	        sram_parts[sent_index] = S_FREE;
+            sent_index++;
+            if(sent_index == global_wa_sram_parts)
+                sent_index = 0;
+	    }
+
+        if(usbSentSize >= usbSendQueue.size[tail])
+        {
+            /* Remove from the usbSendQueues */
+            num--;
+            tail++;
+            if(tail == MAX_XDS_FOR_TR_CALLS)
+                tail = 0;
+
+            usbSendQueue.tail = tail;
+            usbSendQueue.num = num;
+            usbSentSize = 0;
+
+            /* Call complete callback */
+            _usb_device_call_service(handle, type, setup, dir, 
+                         buff_ptr, size, error);
+
+            if(num == 0)
+                return;
+        }
+
+	    error = _usb_prepare_to_send(handle);	
+        if (error) 
+        {
+            USB_printf("usbSendComplete, add_dTD failed\n");
+        }	
+
+    }
+    else
+    {
+        /* Call complete callback */
+        _usb_device_call_service(handle, type, setup, dir, 
+                        buffer, length, error);
+    }
+}
+#endif /* USB_UNDERRUN_WA */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_send_data
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Sends data on a specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_send_data
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] buffer to send */
+      uint_8_ptr                 buff_ptr,
+            
+      /* [IN] length of the transfer */
+      uint_32                    size
+   )
+{ /* Body */
+   int 	                        lockKey;
+   uint_8                       error = 0;
+   XD_STRUCT_PTR                xd_ptr;
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   boolean                      toSend = TRUE;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TX,
+       "send_data: handle=%p, ep=%d, pBuf=0x%x, size=%d, EP_QH=%p\n", 
+       handle, ep_num, (unsigned)buff_ptr, (int)size, usb_dev_ptr->EP_QUEUE_HEAD_PTR);
+
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_send_count++));
+      
+   lockKey = USB_lock();
+
+   if (!usb_dev_ptr->XD_ENTRIES) 
+   {
+      USB_unlock(lockKey);
+      USB_printf("_usb_device_send_data, transfer in progress\n");
+      return ARC_USB_STATUS_TRANSFER_IN_PROGRESS;
+   } /* Endif */
+
+#if defined(USB_UNDERRUN_WA)
+    {
+        int 			                head;
+       	VUSB20_EP_QUEUE_HEAD_STRUCT* 	ep_queue_head_ptr;
+
+		ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
+                       						                  2*ep_num + ARC_USB_SEND;
+
+        if( ((ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF) > global_wa_threshold) 
+        {
+            /* Only Endpoints with maxPktSize more than 128 bytes need special processing */
+            if( (size > global_wa_threshold) || 
+                (usbSendQueue.num != 0) )
+            {
+
+                USB_printf("_usb_device_send_data: ep_num=%d, maxPktSize=%d, size=%d\n",
+                        ep_num, (ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF, size);
+
+                /* Check if usbSendQueue is not Full */
+                if(usbSendQueue.num == MAX_XDS_FOR_TR_CALLS)
+                {
+                    USB_printf("ep=%d: usbSendQueue is FULL\n", ep_num);
+                    USB_unlock(lockKey);
+                    return USBERR_TX_FAILED;
+                }
+
+                /* Add to usbSendQueu */
+                head = usbSendQueue.head;
+
+                usbSendQueue.num++;
+		        usbSendQueue.num_dma++;
+                usbSendQueue.size[head] = size;
+                usbSendQueue.buff_ptr[head] = buff_ptr;
+                usbSendQueue.ep_num[head] = ep_num;
+
+                head++;
+                if(head == MAX_XDS_FOR_TR_CALLS)
+                    head = 0;
+
+                usbSendQueue.head = head;
+
+                /* Process first usbSendQueue element if possible */
+                if(usbSendQueue.num == 1)
+                {
+		            error = _usb_prepare_to_send(handle);
+		        }
+		        toSend = FALSE;
+            }
+        }
+    }
+#endif /* USB_UNDERRUN_WA */
+
+    if(toSend == TRUE)
+    {
+        /* Get a transfer descriptor */
+        USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
+
+        usb_dev_ptr->XD_ENTRIES--;
+
+        if(buff_ptr != NULL)
+            USB_dcache_flush((pointer)buff_ptr, size);   
+
+        /* Initialize the new transfer descriptor */      
+        xd_ptr->EP_NUM = ep_num;
+        xd_ptr->BDIRECTION = ARC_USB_SEND;
+        xd_ptr->WTOTALLENGTH = size;
+        xd_ptr->WSOFAR = 0;
+        xd_ptr->WSTARTADDRESS = buff_ptr;   
+        xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
+
+        error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
+    }
+    USB_unlock(lockKey);
+   
+    if (error) 
+    {
+        return USBERR_TX_FAILED;
+    } /* Endif */
+    return error;
+
+} /* EndBody */
+
+
diff --git a/board/pxa/common/usbeth/mvUsbDevUtl.c b/board/pxa/common/usbeth/mvUsbDevUtl.c
new file mode 100644
index 0000000..340444e
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbDevUtl.c
@@ -0,0 +1,651 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_unstall_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Unstalls the endpoint in specified direction
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_unstall_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR   	usb_dev_ptr;
+   int							lockKey;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+ 
+   lockKey = USB_lock();
+   
+   _usb_dci_vusb20_unstall_endpoint(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+  
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : _usb_device_get_status
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Provides API to access the USB internal state.
+* 
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_get_status
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle   handle,
+      
+      /* [IN] What to get the status of */
+      uint_8               component,
+      
+      /* [OUT] The requested status */
+      uint_16_ptr          status
+   )
+{ /* Body */
+   	USB_DEV_STATE_STRUCT_PTR 	usb_dev_ptr;
+	int							lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+  
+   lockKey = USB_lock();
+
+   switch (component) 
+   {
+      case ARC_USB_STATUS_DEVICE_STATE:
+         *status = usb_dev_ptr->USB_STATE;
+         break;
+
+      case ARC_USB_STATUS_DEVICE:
+         *status = usb_dev_ptr->USB_DEVICE_STATE;
+         break;
+
+      case ARC_USB_STATUS_INTERFACE:
+          *status = 0;
+         break;
+         
+      case ARC_USB_STATUS_ADDRESS:
+         *status = usb_dev_ptr->DEVICE_ADDRESS;
+         break;
+         
+      case ARC_USB_STATUS_CURRENT_CONFIG:
+         *status = usb_dev_ptr->USB_CURR_CONFIG;
+         break;
+
+      case ARC_USB_STATUS_SOF_COUNT:
+         *status = usb_dev_ptr->USB_SOF_COUNT;
+         break;
+   
+      default:
+            USB_unlock(lockKey);
+            USB_printf("_usb_device_get_status, bad status\n");
+            return USBERR_BAD_STATUS;
+  
+   } /* Endswitch */
+   USB_unlock(lockKey);
+  
+   return USB_OK;   
+} /* EndBody */  
+ 
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : _usb_device_set_status
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Provides API to set internal state
+* 
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_set_status
+   (
+      /* [IN] Handle to the usb device */
+      _usb_device_handle   handle,
+      
+      /* [IN] What to set the status of */
+      uint_8               component,
+      
+      /* [IN] What to set the status to */
+      uint_16              setting
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR usb_dev_ptr;
+   int 					    lockKey;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STATUS, 
+            "set_status: component=0x%x, value=0x%x\n", component, setting);
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   lockKey = USB_lock();
+
+   switch (component) 
+   {
+      case ARC_USB_STATUS_DEVICE_STATE:
+         usb_dev_ptr->USB_STATE = setting;
+         break;
+
+      case ARC_USB_STATUS_DEVICE:
+         usb_dev_ptr->USB_DEVICE_STATE = setting;
+         break;
+
+      case ARC_USB_STATUS_INTERFACE:
+         break;
+
+      case ARC_USB_STATUS_CURRENT_CONFIG:
+         usb_dev_ptr->USB_CURR_CONFIG = setting;
+         break;
+
+      case ARC_USB_STATUS_SOF_COUNT:
+         usb_dev_ptr->USB_SOF_COUNT = setting;
+         break;
+
+      case ARC_USB_FORCE_FULL_SPEED:
+         _usb_dci_vusb20_set_speed_full((pointer)usb_dev_ptr, setting);
+         break;
+
+      case ARC_USB_PHY_LOW_POWER_SUSPEND:
+         _usb_dci_vusb20_suspend_phy((pointer)usb_dev_ptr, setting);
+         break;
+
+      case ARC_USB_STATUS_ADDRESS:
+         usb_dev_ptr->DEVICE_ADDRESS = setting;
+
+         _usb_dci_vusb20_set_address((pointer)usb_dev_ptr, setting);
+         break;
+      
+      case ARC_USB_STATUS_TEST_MODE:
+         _usb_dci_vusb20_set_test_mode(handle, setting);
+         break;
+         
+      default:
+            USB_unlock(lockKey);
+            USB_printf("_usb_device_set_status, bad status\n");
+            return USBERR_BAD_STATUS;
+  
+   } /* Endswitch */
+
+   USB_unlock(lockKey);
+   
+   return USB_OK;   
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_stall_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Stalls the endpoint.
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_stall_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   int							lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   lockKey = USB_lock();
+
+   _usb_dci_vusb20_stall_endpoint(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+   
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_is_endpoint_stalled
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Stalls the endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_is_endpoint_stalled
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   uint_8                       val;
+   int							lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   lockKey = USB_lock();
+
+   val = _usb_dci_vusb20_is_endpoint_stalled(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+   return val;
+   
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_process_resume
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Process Resume event
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_assert_resume
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR      usb_dev_ptr;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   _usb_dci_vusb20_assert_resume(handle);
+
+} /* EndBody */
+
+
+/***************************/
+/* ARC USB Debug functions */
+/***************************/
+void _usb_status(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+
+    if(pUsbDev == NULL)
+    {
+        USB_printf("USB Device core is not initialized\n");
+        return;
+    }
+
+    USB_printf("\n\tUSB Status\n\n");
+
+    USB_printf("DEV_NUM=%d, DEV_ADDR=%d, CAP_REGS=0x%x, DEV_REGS=0x%x, MAX_EP=%d\n",
+                pUsbDev->DEV_NUM,
+                pUsbDev->DEVICE_ADDRESS,
+                (unsigned)pUsbDev->CAP_REGS_PTR, 
+                (unsigned)pUsbDev->DEV_PTR, 
+                pUsbDev->MAX_ENDPOINTS);
+
+    USB_printf("BUS_RESET=%s, USB_STATE=0x%02x, USB_DEV_STATE=0x%02x, SPEED=%d, ERRORS=0x%04x\n",
+                pUsbDev->BUS_RESETTING ? "Yes" : "No",
+                pUsbDev->USB_STATE,
+                pUsbDev->USB_DEVICE_STATE,
+                pUsbDev->SPEED, 
+                pUsbDev->ERRORS);
+
+    USB_printf("EP_QUEUE_HEAD: SIZE=%d, BASE=%p (0x%08x), ALIGNED=%p, SERVICE_HEAD=%p\n",
+                pUsbDev->EP_QUEUE_HEAD_SIZE,
+                pUsbDev->EP_QUEUE_HEAD_BASE, 
+                pUsbDev->EP_QUEUE_HEAD_PHYS,
+                pUsbDev->EP_QUEUE_HEAD_PTR,
+                pUsbDev->SERVICE_HEAD_PTR);
+
+    USB_printf("XD: BASE=%p, HEAD=%p, TAIL=%p, ENTRIES=%d, SCRATCH=%p, TEMP=%p\n",
+                pUsbDev->XD_BASE,
+                pUsbDev->XD_HEAD,
+                pUsbDev->XD_TAIL,
+                pUsbDev->XD_ENTRIES,
+                pUsbDev->XD_SCRATCH_STRUCT_BASE,
+                pUsbDev->TEMP_XD_PTR);
+
+    USB_printf("DTD: SIZE=%d, BASE=%p (0x%08x), ALIGNED=%p, HEAD=0x%08x, TAIL=0x%08x, ENTRIES=%d, SCRATCH=%p\n",
+                pUsbDev->DTD_SIZE,
+                pUsbDev->DTD_BASE_PTR,
+                pUsbDev->DTD_BASE_PHYS,
+                pUsbDev->DTD_ALIGNED_BASE_PTR,
+                pUsbDev->DTD_HEAD,
+                pUsbDev->DTD_TAIL,
+                pUsbDev->DTD_ENTRIES,
+                pUsbDev->SCRATCH_STRUCT_BASE);
+}
+
+void _usb_stats(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+    USB_STATS*              pUsbStats = &pUsbDev->STATS;
+    int                     i;
+
+    USB_printf("\n\tUSB Statistics\n\n");
+
+    USB_printf("isr=%u, empty_isr=%u, reset=%u, setup=%u, read_setup=%u\n", 
+                    pUsbStats->usb_isr_count, pUsbStats->usb_empty_isr_count, 
+                    pUsbStats->usb_reset_count, pUsbStats->usb_setup_count, 
+                    pUsbStats->usb_read_setup_count);
+
+    USB_printf("recv=%u, send=%u, add=%u (%u), cancel=%u\n", 
+                pUsbStats->usb_recv_count, pUsbStats->usb_send_count, 
+                pUsbStats->usb_add_count, pUsbStats->usb_add_not_empty_count, 
+                pUsbStats->usb_cancel_count);
+
+    USB_printf("free_XD=%u, free_dTD=%u\n", 
+            pUsbStats->free_XD_count, pUsbStats->free_dTD_count);
+
+    USB_printf("complete_isr=%u, complete=%u, empty_complete=%u, max_complete=%u\n", 
+                pUsbStats->usb_complete_isr_count, pUsbStats->usb_complete_count, 
+                pUsbStats->usb_empty_complete_count, pUsbStats->usb_complete_max_count);
+
+    USB_printf("port_change=%u, suspend=%u\n", 
+                pUsbStats->usb_port_change_count, pUsbStats->usb_suspend_count);
+    for(i=0; i<(pUsbDev->MAX_ENDPOINTS); i++)
+    {
+        if( (pUsbStats->usb_complete_ep_count[i*2] == 0) && 
+            (pUsbStats->usb_complete_ep_count[i*2+1] == 0) )
+            continue;
+
+        USB_printf("EP #%d: RECV (OUT) = %3u, \tSEND (IN) = %u\n", i,
+                    pUsbStats->usb_complete_ep_count[i*2], 
+                    pUsbStats->usb_complete_ep_count[i*2+1]);
+    }
+    USB_printf("\n");
+}
+
+void _usb_clear_stats(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+
+    USB_memzero(&pUsbDev->STATS, sizeof(pUsbDev->STATS));
+}
+
+void _usb_regs(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+    VUSB20_REG_STRUCT*      cap_regs, *dev_regs;
+    int                     dev_num;
+
+    if(pUsbDev == NULL)
+    {
+        USB_printf("USB Device core is not initialized\n");
+        return;
+    }
+    USB_printf("\n\tUSB Capability Registers\n\n");
+
+    cap_regs = pUsbDev->CAP_REGS_PTR;
+    USB_printf("CAPLENGTH_HCIVER (0x%08x) = 0x%08x\n", 
+        (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER,
+        (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER));
+
+    USB_printf("DCI_VERSION      (0x%08x) = 0x%08x\n", 
+        (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCI_VERSION,
+        (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCI_VERSION));
+
+    USB_printf("DCC_PARAMS       (0x%08x) = 0x%08x\n", 
+        (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS,
+        (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS));
+
+    dev_regs = pUsbDev->DEV_PTR;
+    dev_num = pUsbDev->DEV_NUM;
+    USB_printf("\n\tUSB Device Operational Registers\n\n");
+
+    USB_printf("USB_CMD          (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
+
+    USB_printf("USB_STS          (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS));
+
+    USB_printf("USB_INTR         (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR));
+
+    USB_printf("USB_FRINDEX      (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX));
+
+    /* Skip CTRLDSSEGMENT register */
+    USB_printf("DEVICE_ADDR      (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR));
+
+    USB_printf("EP_LIST_ADDR     (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR));
+
+    /* Skip CONFIG_FLAG register */
+
+    /* Skip PORTSCX[0..15] registers*/
+    USB_printf("PORTSCX[0]       (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0],
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]));
+
+    /* Skip OTGSC register */
+
+    USB_printf("USB_MODE         (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_MODE,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_MODE));
+
+    USB_printf("ENDPT_SETUP_STAT (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT));
+
+    USB_printf("ENDPTPRIME       (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME));
+
+    USB_printf("ENDPTFLUSH       (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH));
+
+    USB_printf("ENDPTSTATUS      (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS));
+
+    USB_printf("ENDPTCOMPLETE    (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE));
+
+    USB_printf("OTGSC            (0x%08x) = 0x%08x\n", 
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.OTGSC,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.OTGSC));
+}
+
+    
+void _usb_ep_status(void* usbHandle, int ep_num, int direction)
+{
+    USB_DEV_STATE_STRUCT*               pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+    int                                 i, ep_idx;
+    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR     ep_queue_head_ptr;
+    VUSB20_EP_TR_STRUCT_PTR             dTD_ptr, head_dTD_ptr, tail_dTD_ptr, next_dTD_ptr;
+    XD_STRUCT_PTR                       xd_ptr, next_xd_ptr;
+    VUSB20_REG_STRUCT_PTR               dev_regs;
+
+    if(pUsbDev == NULL)
+    {
+        USB_printf("USB Device core is not initialized\n");
+        return;
+    }
+
+    USB_printf("\n\tUSB Endpoint #%d - %s status\n\n", ep_num,
+        (direction == ARC_USB_SEND) ? "SEND (IN)" : "RECV (OUT)" );
+
+    ep_idx = ep_num*2 + direction;
+    dev_regs = pUsbDev->DEV_PTR;
+
+    USB_printf("ENDPTCTRLX[%d]    (0x%08x) = 0x%08x\n", ep_num,
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num],
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]));
+
+    ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)pUsbDev->EP_QUEUE_HEAD_PTR + ep_idx;
+
+    head_dTD_ptr = pUsbDev->EP_DTD_HEADS[ep_idx];
+    tail_dTD_ptr = pUsbDev->EP_DTD_TAILS[ep_idx];
+
+    USB_printf("EP_QH=0x%08x: MAX_PKT=0x%x, SIZE_IOC_INT_STS=0x%x, CURR_DTD=0x%x, NEXT_DTD=0x%x\n", 
+                (unsigned)ep_queue_head_ptr, (unsigned)USB_32BIT_LE(ep_queue_head_ptr->MAX_PKT_LENGTH), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->NEXT_DTD_PTR));
+
+    USB_printf("\tBUF_0=0x%08x, BUF_1=0x%08x, BUF_2=0x%08x, BUF_3=0x%08x, BUF_4=0x%08x\n",
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR0), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR1), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR2), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR3), 
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR4));
+    
+    USB_printf("\tSETUP_BUFFER (%p): ", ep_queue_head_ptr->SETUP_BUFFER);
+    for(i=0; i<sizeof(ep_queue_head_ptr->SETUP_BUFFER); i++)
+        USB_printf("%02x", ep_queue_head_ptr->SETUP_BUFFER[i] & 0xFF);
+    USB_printf("\n");
+
+    USB_printf("\ndTD_HEAD=0x%08x, dTD_TAIL=0x%08x\n", 
+                (unsigned)head_dTD_ptr, (unsigned)tail_dTD_ptr);
+
+    dTD_ptr = head_dTD_ptr;
+    i = 0;
+    while(dTD_ptr != NULL)
+    {
+        USB_printf("%d. dTD=0x%08x (0x%08x), SIZE_IOC_STS=0x%08x, BUF_0=0x%08x, NEXT=0x%08x\n", 
+                    i, (unsigned)dTD_ptr, USB_DTD_VIRT_TO_PHYS(pUsbDev, dTD_ptr),
+                    (unsigned)USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS), 
+                    (unsigned)USB_32BIT_LE(dTD_ptr->BUFF_PTR0), 
+                    (unsigned)USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR));
+
+        xd_ptr = dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+
+        next_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(pUsbDev, 
+                           (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK));
+        if(next_dTD_ptr != NULL) 
+            next_xd_ptr = next_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+        else
+            next_xd_ptr = NULL;
+
+        if(next_xd_ptr != xd_ptr)
+        {
+            USB_printf("\tXD=0x%08x, ADDR=0x%08x, SIZE=%u, STATUS=0x%02x\n",
+                (unsigned)xd_ptr, (unsigned)xd_ptr->WSTARTADDRESS, 
+                (unsigned)xd_ptr->WTOTALLENGTH, xd_ptr->BSTATUS);
+        }
+        i++;
+        dTD_ptr = next_dTD_ptr;
+    }
+}
+
+
+/* DEBUG */
+uint_32 usbDebugFlags = ARC_DEBUG_FLAG_STATS
+                      | ARC_DEBUG_FLAG_INIT 
+                      | ARC_DEBUG_FLAG_ERROR 
+#if 1
+//		      | ARC_DEBUG_FLAG_TRACE	// for free dTD check
+                      | ARC_DEBUG_FLAG_ISR	//xj add
+//                      | ARC_DEBUG_FLAG_CTRL	//xj add
+                      | ARC_DEBUG_FLAG_RX	//xj add
+                      | ARC_DEBUG_FLAG_TX	//xj add
+                      | ARC_DEBUG_FLAG_INIT	//xj add
+                      | ARC_DEBUG_FLAG_TRANSFER	//xj add
+//                      | ARC_DEBUG_FLAG_SETUP	//xj add
+//                      | ARC_DEBUG_FLAG_EP0	//xj add
+//                      | ARC_DEBUG_FLAG_ADDR	//xj add
+#endif
+                      | ARC_DEBUG_FLAG_STALL
+                      | ARC_DEBUG_FLAG_RESET;
+                      /*| ARC_DEBUG_FLAG_TRANSFER;*/
+
+void    _usb_debug_set_flags(uint_32 flags)     
+{
+    usbDebugFlags = (flags);                        
+}
+
+uint_32 _usb_debug_get_flags(void)     
+{
+    return usbDebugFlags;  
+}
+
+#if defined(MV_USB_TRACE_LOG)
+
+uint_16 DEBUG_TRACE_ARRAY_COUNTER = 0;
+char    DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE][MAX_STRING_SIZE];
+
+void  _usb_debug_init_trace_log(void)                   
+{                                                  
+    USB_memzero(DEBUG_TRACE_ARRAY, TRACE_ARRAY_SIZE*MAX_STRING_SIZE);
+	DEBUG_TRACE_ARRAY_COUNTER =0;                  
+}                               
+
+void    _usb_debug_print_trace_log(void)                     
+{                                                       
+    int     i;                                          
+                                                        
+    USB_printf("USB Trace log: start=0x%x, end=0x%x, idx=%d, flags=0x%x\n\n", 
+               &DEBUG_TRACE_ARRAY[0][0], &DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE-1][0], 
+               DEBUG_TRACE_ARRAY_COUNTER, usbDebugFlags);      
+
+    for(i=DEBUG_TRACE_ARRAY_COUNTER; i<TRACE_ARRAY_SIZE; i++)                      
+    {                                                 
+        if(DEBUG_TRACE_ARRAY[i][0] == '\0')              
+            continue;                     
+        
+        USB_printf("%3d. %s", i, DEBUG_TRACE_ARRAY[i]);
+    }                                                 
+    for(i=0; i<DEBUG_TRACE_ARRAY_COUNTER; i++)       
+    {                                                 
+        if(DEBUG_TRACE_ARRAY[i][0] == '\0')           
+            continue;                                 
+        USB_printf("%3d. %s", i, DEBUG_TRACE_ARRAY[i]);
+    }                          
+    _usb_debug_init_trace_log();
+}
+#else
+void  _usb_debug_init_trace_log(void)                   
+{
+}
+
+void    _usb_debug_print_trace_log(void)
+{
+    USB_printf("USB trace log is not supported\n");
+}
+#endif /* MV_USB_TRACE_LOG */
+
+
+
+
+
diff --git a/board/pxa/common/usbeth/mvUsbHsDevCncl.c b/board/pxa/common/usbeth/mvUsbHsDevCncl.c
new file mode 100644
index 0000000..495748c
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbHsDevCncl.c
@@ -0,0 +1,225 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_cancel_transfer
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Cancels a transfer
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_cancel_transfer
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+     
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR             usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR              dTD_ptr, check_dTD_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR      ep_queue_head_ptr;
+   XD_STRUCT_PTR                        xd_ptr;
+   uint_32                              temp, bit_pos;
+   volatile unsigned long               timeout, status_timeout;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+   bit_pos = (1 << (16 * direction + ep_num));
+   temp = (2*ep_num + direction);
+   
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+   
+   /* Unlink the dTD */
+   dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
+   
+   if (dTD_ptr) 
+   {
+      ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_cancel_count++));
+
+      check_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, 
+                            ((uint_32)USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK));
+
+      if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE) 
+      {
+         /* Flushing will halt the pipe */
+         /* Write 1 to the Flush register */
+         dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(bit_pos);
+
+         /* Wait until flushing completed */
+         timeout = 0x1000000;
+         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos) 
+         {
+            /* ENDPTFLUSH bit should be cleared to indicate this operation is complete */
+            timeout--;
+            if(timeout == 0)
+            {
+                USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, bit_pos=0x%x \n", 
+                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH), 
+                      (unsigned)bit_pos);
+                break;
+            }
+         } /* EndWhile */
+         status_timeout = 0x100000;
+         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos) 
+         {
+            status_timeout--;
+            if(status_timeout == 0)
+            {
+                USB_printf("USB Cancel: - TIMEOUT for ENDPTSTATUS=0x%x, bit_pos=0x%x\n", 
+                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                      (unsigned)bit_pos);
+                break;
+            }
+
+            /* Write 1 to the Flush register */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(bit_pos);
+         
+            /* Wait until flushing completed */
+            timeout = 0x1000000;
+            while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos) 
+            {
+               /* ENDPTFLUSH bit should be cleared to indicate this operation is complete */
+               timeout--;
+               if(timeout == 0)
+                {
+                    USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n", 
+                            (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH), 
+                            (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                            (unsigned)bit_pos);
+                    break;
+                }
+            } /* EndWhile */
+         } /* EndWhile */
+      } /* Endif */
+      
+      /* Retire the current dTD */
+      dTD_ptr->SIZE_IOC_STS = 0;
+      dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSBHS_TD_NEXT_TERMINATE);
+      
+      /* The transfer descriptor for this dTD */
+      xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+      dTD_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
+                      "cncl_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p, bit=0x%x\n",
+                       usb_dev_ptr->STATS.usb_cancel_count & 0xFFFF, 
+                       USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
+                       ep_num, direction ? "in" : "out", 
+                       xd_ptr->WSTARTADDRESS, xd_ptr->WTOTALLENGTH, xd_ptr, 
+                       dTD_ptr, check_dTD_ptr, bit_pos);
+       
+      /* Free the dTD */
+      _usb_dci_vusb20_free_dTD((pointer)dTD_ptr);
+      
+      /* Update the dTD head and tail for specific endpoint/direction */
+      if (!check_dTD_ptr) 
+      {
+         usb_dev_ptr->EP_DTD_HEADS[temp] = NULL;
+         usb_dev_ptr->EP_DTD_TAILS[temp] = NULL;
+         if (xd_ptr) 
+         {
+            xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+            /* Free the transfer descriptor */
+            _usb_device_free_XD((pointer)xd_ptr);
+         } /* Endif */
+         /* No other transfers on the queue */
+         ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE);
+         ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+      } 
+      else 
+      {
+         usb_dev_ptr->EP_DTD_HEADS[temp] = check_dTD_ptr;
+            
+         if (xd_ptr) 
+         {
+            if ((uint_32)check_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != (uint_32)xd_ptr) 
+            {
+               xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+               /* Free the transfer descriptor */
+               _usb_device_free_XD((pointer)xd_ptr);
+            } /* Endif */
+         } /* Endif */
+         
+         if (USB_32BIT_LE(check_dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE) 
+         {         
+            /* Start CR 1015 */
+            /* Prime the Endpoint */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+
+            if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)) 
+            {
+               timeout = 0x100000;
+               while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos) 
+               {
+                  /* Wait for the ENDPTPRIME to go to zero */
+                  timeout--;
+                  if(timeout == 0)
+                  {
+                      USB_printf("USB Cancel: - TIMEOUT for ENDPTPRIME=0x%x, bit_pos=0x%x\n", 
+                                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME), 
+                                (unsigned)bit_pos);
+                      break;
+                  }
+               } /* EndWhile */
+
+               if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos) 
+               {
+                  /* The endpoint was not not primed so no other transfers on 
+                  ** the queue 
+                  */
+                  goto done;
+               } /* Endif */
+            } 
+            else 
+            {
+               goto done;
+            } /* Endif */
+
+#if 0 //xj del, otherwise SET EPPRIME twice, USBSTS[SEI] bit would be set, and EP never work again
+            /* No other transfers on the queue */
+            ep_queue_head_ptr->NEXT_DTD_PTR = (uint_32)USB_32BIT_LE((uint_32)check_dTD_ptr);
+            ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+
+            /* Prime the Endpoint */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+#endif
+         } /* Endif */
+      } /* Endif */
+   } /* Endif */
+   
+done:
+
+   /* End CR 1015 */  
+   return USB_OK;
+} /* EndBody */
+
+/* EOF */
+
diff --git a/board/pxa/common/usbeth/mvUsbHsDevMain.c b/board/pxa/common/usbeth/mvUsbHsDevMain.c
new file mode 100644
index 0000000..457fa09
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbHsDevMain.c
@@ -0,0 +1,1990 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_init
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Initializes the USB device controller.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_init
+   (
+      /* [IN] the USB device controller to initialize */
+      uint_8                     devnum,
+
+      /* [OUT] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR    	dev_ptr;
+    uint_32                     temp;
+    uint_8*                     pBuf;
+    unsigned long               phyAddr;
+      
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    usb_dev_ptr->CAP_REGS_PTR = 
+       (VUSB20_REG_STRUCT_PTR)USB_get_cap_reg_addr(devnum);
+      
+    /* Get the base address of the VUSB_HS registers */
+    usb_dev_ptr->DEV_PTR = 
+      (VUSB20_REG_STRUCT_PTR)(((uint_32)usb_dev_ptr->CAP_REGS_PTR) + 
+       (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER) & 
+                                                                EHCI_CAP_LEN_MASK));
+
+    /* Get the maximum number of endpoints supported by this USB controller */
+    usb_dev_ptr->MAX_ENDPOINTS = 
+      (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS) & 
+                                                VUSB20_DCC_MAX_ENDPTS_SUPPORTED);
+
+    USB_printf("USB init: CAP_REGS=0x%x, DEV_REGS=0x%x, MAX_EP=%d\n",
+                (unsigned)usb_dev_ptr->CAP_REGS_PTR, (unsigned)usb_dev_ptr->DEV_PTR, 
+                usb_dev_ptr->MAX_ENDPOINTS);
+
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR; 
+    USB_printf("          DEVICE_ADDR(%x)=0x%x, EP_LIST_ADDR(%x)=0x%x, EP_NAK(%x)=%x, OTGSC(%x)=%x, MCR(%x)=%x\n",
+       &dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR,        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR, 
+       &dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR,       dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR, 
+       &dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_NAK,              dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_NAK, 
+       &dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.OTGSC,              dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.OTGSC,
+       &dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.MCR,       	    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.MCR); 
+
+    temp = (usb_dev_ptr->MAX_ENDPOINTS * 2);
+   
+    pBuf = (uint_8*)USB_uncached_memalloc(temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT), 
+                                          2048, &phyAddr);      
+    if (pBuf == NULL) 
+    {
+        USB_printf("_usb_dci_vusb20_init, malloc of %d bytes in Uncached area failed\n",
+                        temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT));
+        return USBERR_ALLOC;
+    }
+
+    /****************************************************************   
+      Assign QH base
+    ****************************************************************/   
+    usb_dev_ptr->EP_QUEUE_HEAD_BASE = pBuf;
+    usb_dev_ptr->EP_QUEUE_HEAD_PHYS = (uint_32)phyAddr;
+
+    /* Align the endpoint queue head to 2K boundary */   
+    usb_dev_ptr->EP_QUEUE_HEAD_PTR = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)
+                USB_MEM2048_ALIGN((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
+
+    usb_dev_ptr->EP_QUEUE_HEAD_SIZE = temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT) +
+                                      ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR - 
+                                       (uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
+
+    /****************************************************************   
+      Zero out the memory allocated
+    ****************************************************************/   
+    USB_memzero( (void*)usb_dev_ptr->EP_QUEUE_HEAD_PTR, 
+                 temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT));
+
+    USB_printf("USB EP_QH: Base=%p (0x%x), Aligned(%d)=%p, Size=%d\n",
+                usb_dev_ptr->EP_QUEUE_HEAD_BASE, usb_dev_ptr->EP_QUEUE_HEAD_PHYS,
+                2048, usb_dev_ptr->EP_QUEUE_HEAD_PTR, usb_dev_ptr->EP_QUEUE_HEAD_SIZE);
+
+    /****************************************************************   
+      Assign DTD base
+    ****************************************************************/   
+    pBuf = (uint_8*)USB_uncached_memalloc(MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT), 
+                                          32, &phyAddr);      
+    if (pBuf == NULL) 
+    {
+        USB_printf("_usb_dci_vusb20_init, malloc of %d bytes in Uncached area failed\n",
+                        MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT));
+        return USBERR_ALLOC;
+    }
+
+    usb_dev_ptr->DTD_BASE_PTR = pBuf;
+    usb_dev_ptr->DTD_BASE_PHYS = (uint_32)phyAddr;
+    
+    /* Align the dTD base to 32 byte boundary */   
+    usb_dev_ptr->DTD_ALIGNED_BASE_PTR = (VUSB20_EP_TR_STRUCT_PTR)
+                        USB_MEM32_ALIGN((uint_32)usb_dev_ptr->DTD_BASE_PTR);
+
+    usb_dev_ptr->DTD_SIZE = MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT) +
+                                ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR - 
+                                 (uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
+
+    /****************************************************************   
+      Zero out the memory allocated
+    ****************************************************************/   
+    USB_memzero((void*)usb_dev_ptr->DTD_ALIGNED_BASE_PTR, 
+                MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT));
+
+    /****************************************************************   
+      Assign SCRATCH Structure base
+    ****************************************************************/   
+    /* Allocate memory for internal scratch structure */   
+    pBuf = USB_memalloc(MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
+    if (pBuf == NULL) 
+    {
+        USB_printf("_usb_dci_vusb20_init, malloc of %d bytes failed\n",
+                        MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
+        return USBERR_ALLOC;
+    }
+    usb_dev_ptr->SCRATCH_STRUCT_BASE = (SCRATCH_STRUCT_PTR)pBuf;
+    USB_memzero(usb_dev_ptr->SCRATCH_STRUCT_BASE, 
+            MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
+
+    USB_printf("USB dTD(%d): Base=%p (0x%x), Aligned(%d)=%p, Size=%d, Scratch=%p\n",
+                MAX_EP_TR_DESCRS, usb_dev_ptr->DTD_BASE_PTR, usb_dev_ptr->DTD_BASE_PHYS,
+                32, usb_dev_ptr->DTD_ALIGNED_BASE_PTR, usb_dev_ptr->DTD_SIZE,
+                usb_dev_ptr->SCRATCH_STRUCT_BASE);
+
+#ifdef USB_UNDERRUN_WA
+    usbSramBase = (uint_8*)USB_get_sram_addr(&usbSramSize);
+    if (usbSramBase == NULL) 
+    {
+        USB_printf("_usb_dci_vusb20_init, SRAM is not available\n");                        
+        return USBERR_ALLOC;
+    }
+    USB_memzero(usbSramBase, usbSramSize);
+    USB_printf("USB WA_Queue: base=%p, size=%d, parts=%d\n", 
+                    usbSramBase, usbSramSize, global_wa_sram_parts);
+#endif /* USB_UNDERRUN_WA */
+
+    usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
+
+    /* Initialize the VUSB_HS controller */   
+    _usb_dci_vusb20_chip_initialize((pointer)usb_dev_ptr);
+
+    return USB_OK;   
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_chip_initialize
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Initializes the USB device controller.
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_chip_initialize
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR            dev_ptr;
+    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  ep_queue_head_ptr;
+    VUSB20_EP_TR_STRUCT_PTR          dTD_ptr;
+    uint_32                          i, port_control;
+    SCRATCH_STRUCT_PTR               temp_scratch_ptr;
+    volatile unsigned long           delay;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "chip_initialize\n");
+   
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+    /* Stop the controller */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~(USB_32BIT_LE(EHCI_CMD_RUN_STOP));
+      
+    /* Reset the controller to get default values */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_CTRL_RESET);
+
+    USB_printf("USB Init: Wait for RESET completed\n");
+   
+    delay = 0x100000;
+    while (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD & 
+                                    (USB_32BIT_LE(EHCI_CMD_CTRL_RESET))) 
+    {
+        /* Wait for the controller reset to complete */
+        delay--;
+        if(delay == 0)
+            break;
+    } /* EndWhile */
+
+    if(delay == 0)
+    {
+        USB_printf("USB Init: Wait for RESET completed TIMEOUT\n");
+    }
+    else
+    {
+        USB_printf("USB Init: RESET completed\n");
+    }
+    /* Call BSP callback to complete reset process */
+    USB_reset_complete(usb_dev_ptr->DEV_NUM);
+
+    /* Initialize the internal dTD head and tail to NULL */   
+    usb_dev_ptr->DTD_HEAD = NULL;
+    usb_dev_ptr->DTD_TAIL = NULL;
+    usb_dev_ptr->DTD_ENTRIES = 0; 
+    usb_dev_ptr->ERROR_STATE = 0;
+
+   /* Make sure the 16 MSBs of this register are 0s */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(0);
+   
+   ep_queue_head_ptr = usb_dev_ptr->EP_QUEUE_HEAD_PTR;
+
+   /* Initialize all device queue heads */
+   for (i=0; i<(usb_dev_ptr->MAX_ENDPOINTS*2); i++) 
+   {
+      /* Interrupt on Setup packet */
+      (ep_queue_head_ptr + i)->MAX_PKT_LENGTH = (USB_32BIT_LE(
+          ((uint_32)USB_MAX_CTRL_PAYLOAD << VUSB_EP_QUEUE_HEAD_MAX_PKT_LEN_POS) | 
+            VUSB_EP_QUEUE_HEAD_IOS));
+
+      (ep_queue_head_ptr + i)->NEXT_DTD_PTR = (USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE));
+   } /* Endfor */
+
+   /* Configure the Endpoint List Address */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR = 
+                            USB_32BIT_LE(USB_EP_QH_VIRT_TO_PHYS(usb_dev_ptr, ep_queue_head_ptr));
+      
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
+   if (usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.HCS_PARAMS & 
+                                        USB_32BIT_LE(VUSB20_HCS_PARAMS_PORT_POWER_CONTROL_FLAG)) 
+   {
+      port_control &= (~EHCI_PORTSCX_W1C_BITS | ~EHCI_PORTSCX_PORT_POWER);
+   } /* Endif */
+   
+   if(usb_dev_ptr->FORCE_FS == TRUE)
+   {
+       port_control |= EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT;
+   }
+   else
+   {
+       port_control &= (~EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT);
+#ifdef XJ_DEBUG
+       port_control |= EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT;
+#endif
+   }
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] = USB_32BIT_LE(port_control);
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
+ //  USB_printf("PORTSCX[0]===========%x\n", port_control);
+
+   dTD_ptr = usb_dev_ptr->DTD_ALIGNED_BASE_PTR;
+
+   temp_scratch_ptr = usb_dev_ptr->SCRATCH_STRUCT_BASE;
+
+   /* Enqueue all the dTDs */   
+   for (i=0; i<MAX_EP_TR_DESCRS; i++) 
+   {
+      dTD_ptr->SCRATCH_PTR = temp_scratch_ptr;
+      dTD_ptr->SCRATCH_PTR->FREE = _usb_dci_vusb20_free_dTD;
+      /* Set the dTD to be invalid */
+      dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSBHS_TD_NEXT_TERMINATE);
+      /* Set the Reserved fields to 0 */
+      dTD_ptr->SIZE_IOC_STS &= ~(USB_32BIT_LE(VUSBHS_TD_RESERVED_FIELDS));
+      dTD_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+      _usb_dci_vusb20_free_dTD((pointer)dTD_ptr);
+      dTD_ptr++;
+      temp_scratch_ptr++;
+   } /* Endfor */
+
+
+#if 1
+   //xj add
+
+   /* Initialize the endpoint 0 properties */
+   // TX_DATA_TOGGLE_RST & RX_DATA_TOGGLE_RST are reserved for Tavor PV - JZhou
+   //dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0] = USB_32BIT_LE(
+   //   (EHCI_EPCTRL_TX_DATA_TOGGLE_RST | EHCI_EPCTRL_RX_DATA_TOGGLE_RST));
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0] &= ~(USB_32BIT_LE
+      (EHCI_EPCTRL_TX_EP_STALL | EHCI_EPCTRL_RX_EP_STALL));
+
+   /*USB_printf("ENDPOINTCTRL0: 0x%x -> 0x%x\n",
+				&dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0],
+				dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]);	  */
+
+   // Enable USB2 PHY for operation	- moved to Usb2COtgFocus.c
+   //usb_dev_ptr->U2P_PTR->U2PT0 |= USB_32BIT_LE(USB_REG_ARC_DPDM_MODE);
+         
+   // DCB RETURN: TPV A0 app specific, set UTMI+
+   // interface and 8 bit width
+   //-------------------------------------------
+//	if (gsUsb2CIConfig.gbU2HDevice)
+//		_usb_dci_vusb20_set_xcvr_interface( handle, EHCI_PORTSCX_SERIAL_XCVR_SELECT, 0 );
+//	else
+//		_usb_dci_vusb20_set_xcvr_interface( handle, EHCI_PORTSCX_UTMI_XCVR_SELECT, 0 );
+ 
+#endif
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_free_dTD
+*  Returned Value : void
+*  Comments       :
+*        Enqueues a dTD onto the free DTD ring.
+*
+*END*-----------------------------------------------------------------*/
+
+void _usb_dci_vusb20_free_dTD
+   (
+      /* [IN] the dTD to enqueue */
+      pointer  dTD_ptr
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   int                          lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)(((VUSB20_EP_TR_STRUCT_PTR)dTD_ptr)->SCRATCH_PTR->PRIVATE);
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "free_dTD: dTD_ptr=0x%x\n", (unsigned)dTD_ptr);
+
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.free_dTD_count++));
+
+
+   /*
+   ** This function can be called from any context, and it needs mutual
+   ** exclusion with itself.
+   */
+   lockKey = USB_lock();
+
+   /*
+   ** Add the dTD to the free dTD queue (linked via PRIVATE) and
+   ** increment the tail to the next descriptor
+   */
+   EHCI_DTD_QADD(usb_dev_ptr->DTD_HEAD, usb_dev_ptr->DTD_TAIL, (VUSB20_EP_TR_STRUCT_PTR)dTD_ptr);
+   usb_dev_ptr->DTD_ENTRIES++;
+
+   USB_unlock(lockKey);
+
+} /* Endbody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_add_dTD
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Adds a device transfer desriptor(s) to the queue.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_add_dTD
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+     
+      /* [IN] The transfer descriptor address */
+      XD_STRUCT_PTR              xd_ptr
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR            dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR          dTD_ptr, temp_dTD_ptr, first_dTD_ptr = NULL;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  ep_queue_head_ptr;
+   uint_32                          curr_pkt_len, remaining_len; 
+   uint_32                          curr_offset, temp, bit_pos;
+   volatile unsigned long           timeout;
+  
+   /*********************************************************************
+   For a optimal implementation, we need to detect the fact that
+   we are adding DTD to an empty list. If list is empty, we can
+   actually skip several programming steps esp. those for ensuring
+   that there is no race condition.The following boolean will be useful
+   in skipping some code here.
+   *********************************************************************/
+   boolean           list_empty = FALSE;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   remaining_len = xd_ptr->WTOTALLENGTH;
+   
+   curr_offset = 0;
+   temp = (2*xd_ptr->EP_NUM + xd_ptr->BDIRECTION);
+   bit_pos = (1 << (16 * xd_ptr->BDIRECTION + xd_ptr->EP_NUM));
+   
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+
+   /*********************************************************************
+   This loops iterates through the length of the transfer and divides
+   the data in to DTDs each handling the a max of 0x4000 bytes of data.
+   The first DTD in the list is stored in a pointer called first_dTD_ptr.
+   This pointer is later linked in to QH for processing by the hardware.   
+   *********************************************************************/
+
+    do 
+    {
+        /* Check if we need to split the transfer into multiple dTDs */
+        if (remaining_len > VUSB_EP_MAX_LENGTH_TRANSFER) 
+        {
+            curr_pkt_len = VUSB_EP_MAX_LENGTH_TRANSFER;
+        } 
+        else 
+        {
+            curr_pkt_len = remaining_len;
+        } /* Endif */
+   
+        /* Get a dTD from the queue */   
+        EHCI_DTD_QGET(usb_dev_ptr->DTD_HEAD, usb_dev_ptr->DTD_TAIL, dTD_ptr);
+   
+        if (!dTD_ptr) 
+        {
+            USB_printf("Error: Can't get dTD\n");
+            return USBERR_TR_FAILED;
+        } /* Endif */
+
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_add_count++));
+
+        USB_printf("add_dTD_%d: ep=%d %s, size=%d, CURR_dTD=0x%x, xd_ptr=0x%x, dTD_ptr=0x%x\n",
+                        usb_dev_ptr->STATS.usb_add_count, xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV",
+                        (int)remaining_len, (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR),
+                        (unsigned)xd_ptr, (unsigned)dTD_ptr);
+
+        remaining_len -= curr_pkt_len;
+
+        usb_dev_ptr->DTD_ENTRIES--;
+
+        if (curr_offset == 0) 
+        {
+            first_dTD_ptr = dTD_ptr;
+        } /* Endif */
+
+        /* Zero the dTD. Leave the last 4 bytes as that is the scratch pointer */
+        USB_memzero((void *) dTD_ptr,(sizeof(VUSB20_EP_TR_STRUCT) - 4));
+
+        /* Initialize the dTD */
+        dTD_ptr->SCRATCH_PTR->PRIVATE = handle;
+   
+        /* Set the Terminate bit */
+        dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE);
+
+        /*************************************************************
+        FIX ME: For hig-speed and high-bandwidth ISO IN endpoints,
+        we must initialize the multiplied field so that Host can issues
+        multiple IN transactions on the endpoint. See the DTD data
+        structure for MultiIO field.
+      
+        S Garg 11/06/2003
+        *************************************************************/
+      
+        /* Fill in the transfer size */
+        if (!remaining_len) 
+        {
+            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len << 
+                    VUSBHS_TD_LENGTH_BIT_POS) | (VUSBHS_TD_IOC) | (VUSBHS_TD_STATUS_ACTIVE));
+        } 
+        else 
+        {
+            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len << VUSBHS_TD_LENGTH_BIT_POS) 
+                                                   | VUSBHS_TD_STATUS_ACTIVE);
+        } /* Endif */
+   
+        /* Set the reserved field to 0 */
+        dTD_ptr->SIZE_IOC_STS &= ~USB_32BIT_LE(VUSBHS_TD_RESERVED_FIELDS);
+
+        /* 4K apart buffer page pointers */
+        if(xd_ptr->WSTARTADDRESS != NULL) 
+        {
+            uint_32 physAddr = USB_virt_to_phys((uint_8*)xd_ptr->WSTARTADDRESS + curr_offset);
+
+#if 1 //xj for test
+	    uint_32 virtAddr = (uint_8*)xd_ptr->WSTARTADDRESS + curr_offset;
+            
+            dTD_ptr->BUFF_PTR0 = USB_32BIT_LE(physAddr);
+
+            virtAddr += 4096;
+	    physAddr = USB_virt_to_phys(virtAddr);
+            dTD_ptr->BUFF_PTR1 = USB_32BIT_LE(physAddr);
+
+            virtAddr += 4096;
+	    physAddr = USB_virt_to_phys(virtAddr);
+            dTD_ptr->BUFF_PTR2 = USB_32BIT_LE(physAddr);
+
+            virtAddr += 4096;
+	    physAddr = USB_virt_to_phys(virtAddr);
+            dTD_ptr->BUFF_PTR3 = USB_32BIT_LE(physAddr);
+
+            virtAddr += 4096;
+	    physAddr = USB_virt_to_phys(virtAddr);
+            dTD_ptr->BUFF_PTR4 = USB_32BIT_LE(physAddr);
+#else
+            dTD_ptr->BUFF_PTR0 = USB_32BIT_LE(physAddr);
+            
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR1 = USB_32BIT_LE(physAddr);
+
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR2 = USB_32BIT_LE(physAddr);
+
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR3 = USB_32BIT_LE(physAddr);
+
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR4 = USB_32BIT_LE(physAddr);
+#endif
+        }
+        else
+        {
+            dTD_ptr->BUFF_PTR0 = dTD_ptr->BUFF_PTR1 = dTD_ptr->BUFF_PTR2 = 0;
+            dTD_ptr->BUFF_PTR3 = dTD_ptr->BUFF_PTR4 = 0;
+        }
+        curr_offset += curr_pkt_len;
+
+      /* Maintain the first and last device transfer descriptor per 
+      ** endpoint and direction 
+      */
+      if (!usb_dev_ptr->EP_DTD_HEADS[temp]) 
+      {
+         usb_dev_ptr->EP_DTD_HEADS[temp] = dTD_ptr;
+
+         /***********************************************
+         If list does not have a head, it means that list
+         is empty. An empty condition is detected.
+         ***********************************************/
+         list_empty = TRUE;
+      } /* Endif */ 
+   
+      /* Check if the transfer is to be queued at the end or beginning */
+      temp_dTD_ptr = usb_dev_ptr->EP_DTD_TAILS[temp];
+      
+      /* Remember which XD to use for this dTD */
+      dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD = (pointer)xd_ptr;
+      
+      /* New tail */
+      usb_dev_ptr->EP_DTD_TAILS[temp] = dTD_ptr;
+      if (temp_dTD_ptr) 
+      {
+         /* Should not do |=. The Terminate bit should be zero */
+         temp_dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, dTD_ptr));
+      } /* Endif */
+   } while (remaining_len); /* EndWhile */
+
+
+   /**************************************************************
+   In the loop above DTD has already been added to the list
+   However endpoint has not been primed yet. If list is not empty 
+   we need safter ways to add DTD to the existing list. 
+   Else we just skip to adding DTD to QH safely.
+   **************************************************************/
+   
+    if(list_empty == FALSE)
+    {
+        volatile boolean    read_safe = FALSE;                      
+        uint_32             prime, temp_ep_stat=0;
+
+        /*********************************************************
+        Hardware v3.2+ require the use of semaphore to ensure that
+        QH is safely updated.
+        *********************************************************/
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_add_not_empty_count++));
+
+        /*********************************************************
+        Check the prime bit. If set goto done
+        *********************************************************/
+        prime = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME);
+
+	USB_printf("%03d: Add not empty: bit_pos=0x%x, prime=%x, status=0x%x, qh->sts=0x%x\n",
+                    usb_dev_ptr->STATS.usb_add_not_empty_count, bit_pos, prime,
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                    USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) );
+
+        if(prime & bit_pos)
+        {
+            timeout = 0x1000;
+            while( dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME
+                    & USB_32BIT_LE(bit_pos) ) 
+            {
+               /* Wait for the ENDPTPRIME to go to zero */
+                timeout--;
+                if(timeout <= 0)
+                {
+                    USB_printf(
+                        "timeout: CTRL=%x, PRIME=%x, STAT=%x, INTR=%x, ADDR=%x, PORTSC=%x, dTD=%p, temp_dTD=%p\n",
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME), 
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]), 
+                        first_dTD_ptr, temp_dTD_ptr);
+
+                    _usb_ep_status(handle, xd_ptr->EP_NUM, xd_ptr->BDIRECTION);
+
+      		    _usb_dci_vusb20_free_dTD((pointer)dTD_ptr);
+                    return USBERR_TR_FAILED;
+                }
+            } /* EndWhile */
+
+            /*ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,*/
+            if(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS & USB_32BIT_LE(bit_pos))
+            {
+                goto done;
+            }
+        }
+
+        read_safe = FALSE;
+        timeout = 1000000;
+        while(read_safe == FALSE)
+        {
+            timeout--;
+            if(timeout <= 0)
+            {
+                USB_printf("%s: Timeout for ATDTW_TRIPWIRE reg = 0x%x\n", __FUNCTION__, 
+                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
+      		_usb_dci_vusb20_free_dTD((pointer)dTD_ptr);
+                return USBERR_TR_FAILED;
+            }
+
+           /*********************************************************
+           start with setting the semaphores
+           *********************************************************/
+           dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |= 
+                                          USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_SET);
+               
+           /*********************************************************
+           Read the endpoint status
+           *********************************************************/
+           temp_ep_stat = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) 
+                                        & bit_pos; 
+
+           /*********************************************************
+           Reread the ATDTW semaphore bit to check if it is cleared.
+           When hardware see a hazard, it will clear the bit or
+           else we remain set to 1 and we can proceed with priming
+           of endpoint if not already primed.
+           *********************************************************/
+           if( dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD & 
+                                          USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_SET))
+           {
+               read_safe = TRUE;
+           }
+
+        }/*end while loop */
+
+        /*********************************************************
+        Clear the semaphore
+        *********************************************************/
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= 
+                                       USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_CLEAR);
+
+        /*********************************************************
+         * If endpoint is not active, we activate it now.               
+         *********************************************************/
+         if(!temp_ep_stat)
+         {
+            /* No other transfers on the queue */
+            ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(
+                        USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, first_dTD_ptr));
+            ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+
+	    /* Prime the Endpoint */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+
+         }
+    }
+    else
+    {
+         /* No other transfers on the queue */
+         ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(
+                            USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, first_dTD_ptr));
+         ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+   
+         /* Prime the Endpoint */
+         dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+#if 0 //xj del
+         /* delay */
+         timeout = 0x100;
+         while(timeout > 0)
+             timeout--;
+
+         dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+#endif
+    }
+
+done:
+   if(first_dTD_ptr == NULL)
+       USB_printf("ERROR !!!! first_dTD_ptr=NULL\n");
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
+               " add_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p, empty=%d\n",
+               usb_dev_ptr->STATS.usb_add_count & 0xFFFF, 
+               USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
+               xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "in" : "out", 
+               xd_ptr->WSTARTADDRESS, (int)xd_ptr->WTOTALLENGTH, 
+               xd_ptr, (unsigned)first_dTD_ptr, 
+               usb_dev_ptr->EP_DTD_HEADS[temp], list_empty);
+   return USB_OK;
+   /* End CR 1015 */
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_tr_complete
+*  Returned Value : None
+*  Comments       :
+*        Services transaction complete interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_tr_complete
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   volatile VUSB20_REG_STRUCT_PTR               dev_ptr;
+   volatile VUSB20_EP_TR_STRUCT_PTR             dTD_ptr; 
+   VUSB20_EP_TR_STRUCT_PTR                      temp_dTD_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR              ep_queue_head_ptr;
+   uint_32                                      temp, i, ep_num = 0, direction = 0, bit_pos;
+   uint_32                                      remaining_length = 0;
+   uint_32                                      actual_transfer_length = 0;
+   uint_32                                      counter, errors = 0;
+   XD_STRUCT_PTR                                xd_ptr;
+   XD_STRUCT_PTR                                temp_xd_ptr = NULL;
+   uint_8_ptr                                   buff_start_address = NULL;
+   boolean                                      endpoint_detected = FALSE;
+//   boolean					setup_dir;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_tr_complete_isr\n");
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_isr_count++));
+
+   /* We use separate loops for ENDPTSETUPSTAT and ENDPTCOMPLETE because the 
+   ** setup packets are to be read ASAP 
+   */
+   
+   /* Process all Setup packet received interrupts */
+   bit_pos = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT);
+   
+   if (bit_pos) 
+   {
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "setup_isr: bit_pos=0x%x\n", (unsigned)bit_pos);
+      for(i=0; i<USB_MAX_CONTROL_ENDPOINTS; i++) 
+      {
+         if (bit_pos & (1 << i)) 
+         {
+            ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_setup_count++));
+            _usb_device_call_service(handle, i, TRUE, 0, 0, 8, 0);
+         } /* Endif */
+      } /* Endfor */
+   } /* Endif */
+
+   /* Don't clear the endpoint setup status register here. It is cleared as a 
+   ** setup packet is read out of the buffer 
+   */
+
+   /* Process non-setup transaction complete interrupts */   
+   bit_pos = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE);
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "tr_complete: bit_pos = 0x%x\n", (unsigned)bit_pos); 
+
+   if (bit_pos) 
+   {
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_count++));
+
+   	/* Clear the bits in the register */
+   	dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE = USB_32BIT_LE(bit_pos);
+
+        /* Get the endpoint number and the direction of transfer */
+        counter = 0;
+	/* for u-boot polling mode, dealing with send irq first */
+        for (i=(ARC_USB_MAX_ENDPOINTS*2);i>0; i--) 
+        {
+            endpoint_detected = FALSE;
+            if ((i < ARC_USB_MAX_ENDPOINTS) && (bit_pos & (1 << i)))
+            {
+                ep_num = i;
+                direction = ARC_USB_RECV;
+                endpoint_detected = TRUE;
+            }
+            else
+            {
+                if( (i >= ARC_USB_MAX_ENDPOINTS) && 
+                    (bit_pos & (1 << (i+16-ARC_USB_MAX_ENDPOINTS))))
+                {
+                    ep_num = (i - ARC_USB_MAX_ENDPOINTS);
+                    direction = ARC_USB_SEND;
+                    endpoint_detected = TRUE;
+                }            
+            }
+
+            if(endpoint_detected)
+            {
+                temp = (2*ep_num + direction);
+
+                /* Get the first dTD */      
+                dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
+            
+                ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+
+		ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, " ep_num %d temp %d tr_complete: dTD_ptr %p ep_queue_head_ptr %p\n", 
+			ep_num, temp, dTD_ptr, ep_queue_head_ptr);
+
+                /* Process all the dTDs for respective transfers */
+                while (dTD_ptr) 
+                {            
+                    if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE) 
+                    {
+                        /* No more dTDs to process. Next one is owned by VUSB */
+                        if(counter == 0)
+                        {
+                            ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "tr_complete - break: ep=%d %s, bit_pos=0x%x\n",
+                                    (unsigned)ep_num, direction ? "SEND" : "RECV", (unsigned)bit_pos);
+
+                            ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_empty_complete_count++));
+                        }
+			if (direction == ARC_USB_SEND) {
+				extern unsigned long temp_remove_count;
+				int count = 10000;
+					
+				while( (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE) && count--);
+				
+				if (count <=0)
+					printf("remove break\n");
+			} else 
+				break;
+
+                        break;
+                    } /* Endif */
+               
+                    /* Get the correct internal transfer descriptor */
+                    xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+                    if (xd_ptr) 
+                    {
+                        buff_start_address = xd_ptr->WSTARTADDRESS;
+                        actual_transfer_length = xd_ptr->WTOTALLENGTH;
+                        temp_xd_ptr = xd_ptr;
+                    } /* Endif */
+               
+                    /* Get the address of the next dTD */
+                    temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, 
+                                (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) );
+                  
+                    /* Read the errors */
+                    errors = (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_ERROR_MASK);                  
+                    if (!errors) 
+                    {
+                        /* No errors */
+                        /* Get the length of transfer from the current dTD */   
+                        remaining_length += ((USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+                        actual_transfer_length -= remaining_length;
+                    } 
+                    else 
+                    {
+			    //mv_debug = 1;
+                        USB_printf("complete_tr error: ep=%d %s: error = 0x%x\n", 
+                                    (unsigned)ep_num, direction ? "SEND" : "RECV", (unsigned)errors);
+                        if (errors & VUSBHS_TD_STATUS_HALTED) 
+                        {
+                            /* Clear the errors and Halt condition */
+                            ep_queue_head_ptr->SIZE_IOC_INT_STS &= USB_32BIT_LE(~errors);
+                        } /* Endif */
+                    } /* Endif */
+               
+                    /* Retire the processed dTD */
+
+                    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "tr_complete - cancel: ep=%d %s, bit_pos = 0x%x\n",
+                                    (unsigned)ep_num, direction ? "SEND" : "RECV", (unsigned)bit_pos);
+
+                    counter++;
+                    _usb_dci_vusb20_cancel_transfer(handle, ep_num, direction);
+                    if( (temp_dTD_ptr == NULL) || 
+                        (temp_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != temp_xd_ptr) ) 
+                    {
+                        /* Transfer complete. Call the register service function for the endpoint */
+                        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_ep_count[temp]++));
+
+#if defined(USB_UNDERRUN_WA)
+                        if( (direction == ARC_USB_SEND) && 
+                            (((ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF) > global_wa_threshold) )
+                            usbSendComplete(handle, ep_num, FALSE, direction, 
+                                   buff_start_address, actual_transfer_length, errors);
+                        else
+#endif /* USB_UNDERRUN_WA */
+                            _usb_device_call_service(handle, ep_num, FALSE, direction, 
+                                   buff_start_address, actual_transfer_length, errors);
+                        remaining_length = 0;
+
+                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
+                            "comp_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p %p, COMP=0x%x\n", 
+                            usb_dev_ptr->STATS.usb_complete_count & 0xFFFF, 
+                            USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
+                            (unsigned)ep_num, direction ? "in" : "out", 
+                            buff_start_address, actual_transfer_length,
+                            temp_xd_ptr, dTD_ptr, temp_dTD_ptr, usb_dev_ptr->EP_DTD_HEADS[temp], (unsigned)bit_pos);
+
+                    } /* Endif */
+                    else
+                    {
+                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER, "tr_complete not completed: ep=%d %s\n", 
+                                (unsigned)ep_num, direction ? "SEND" : "RECV");
+                    }
+                    if( (temp_dTD_ptr == NULL) && (usb_dev_ptr->EP_DTD_HEADS[temp] != NULL) )
+                    {
+/*
+                        USB_printf("tr_complete: ep=%d, temp_dTD=%p, dTD_ptr=%p (%p), DTD_HEADS=%p, remain=%d\n",
+                                    temp, temp_dTD_ptr, dTD_ptr, 
+                                    USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) ),
+                                    usb_dev_ptr->EP_DTD_HEADS[temp], remaining_length);
+*/
+                        dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
+                    }
+                    else
+                    {
+                        dTD_ptr = temp_dTD_ptr;
+                    }
+                    errors = 0;
+                } /* Endwhile */
+            } /* Endif */
+        } /* Endfor */
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, 
+               ( {if(usb_dev_ptr->STATS.usb_complete_max_count < counter) 
+                            usb_dev_ptr->STATS.usb_complete_max_count = counter;}));
+   } /* Endif */
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_isr
+*  Returned Value : None
+*  Comments       :
+*        Services all the VUSB_HS interrupt sources
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_isr
+   (
+      _usb_device_handle handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   uint_32                      status;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_isr_count++));
+
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   status = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS);
+
+   status &= USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR);
+
+   if(status == 0) 
+   {
+       ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_empty_isr_count++));
+       return;
+   } /* Endif */
+
+    USB_printf("\nUSB_ISR: FRINDEX=0x%x (Frame# %d), status=0x%x, PORTSC=0x%x, EP_SETUP=0x%x, EP_COMPLETE=0x%x, EP_PRIME=0x%x\n", 
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+                    (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX)>>3),
+                    status, 
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME));
+
+   
+   /* Clear all the interrupts occured */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS = USB_32BIT_LE(status);
+   
+   if (status & EHCI_STS_ERR) 
+   {
+      _usb_dci_vusb20_process_error((pointer)usb_dev_ptr);
+      USB_printf("USB process error: status=0x%x\n", status);
+      usb_dev_ptr->ERROR_STATE |= (status & 0xFFFF);
+   } /* Endif */
+
+   if (status & EHCI_STS_RESET) 
+   {
+       _usb_dci_vusb20_process_reset((pointer)usb_dev_ptr);
+   } /* Endif */
+   
+   if (status & EHCI_STS_PORT_CHANGE) 
+   {
+      _usb_dci_vusb20_process_port_change((pointer)usb_dev_ptr);
+   } /* Endif */
+      
+   if (status & EHCI_STS_SOF) 
+   {
+      _usb_dci_vusb20_process_SOF((pointer)usb_dev_ptr);
+   } /* Endif */
+   
+   if (status & EHCI_STS_INT) 
+   {
+      _usb_dci_vusb20_process_tr_complete((pointer)usb_dev_ptr);
+   } /* Endif */
+   
+    if (status & EHCI_STS_SUSPEND) 
+    {
+        _usb_dci_vusb20_process_suspend((pointer)usb_dev_ptr);
+    } /* Endif */
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_reset
+*  Returned Value : None
+*  Comments       :
+*        Services reset interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_reset
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   uint_32                      temp;
+   volatile unsigned long       timeout;
+   static int			reset_done;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_reset\n");
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_reset_count++));
+   
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Inform the application so that it can cancel all previously queued transfers */
+   _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_BUS_RESET, 0, 0, 0, 0, 0);
+
+#if defined(USB_UNDERRUN_WA)
+    _usb_reset_send_queue();
+#endif /* USB_UNDERRUN_WA */
+   
+   /* The address bits are past bit 25-31. Set the address */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR &= ~USB_32BIT_LE(0xFE000000);
+   
+   /* Clear all the setup token semaphores */
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT);
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(temp);
+
+   /* Clear all the endpoint complete status bits */   
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE);
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE = USB_32BIT_LE(temp);
+   
+    timeout = 0x10000;
+    while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & 0xFFFFFFFF) 
+    {
+        timeout--;
+        if(timeout <= 0)
+        {
+            USB_printf("%s: Timeout for ENDPTPRIME = 0x%x\n", __FUNCTION__, 
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME));
+            break;
+        }
+
+      /* Wait until all ENDPTPRIME bits cleared */
+    } /* Endif */
+   
+   /* Write 1s to the Flush register */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(0xFFFFFFFF);
+   
+    if( (usb_dev_ptr->ERROR_STATE == 0x0) &&
+        (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
+                                                EHCI_PORTSCX_PORT_RESET) )
+    {
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT,
+                    "USB Bus Reset: fri=0x%x, dev_ptr=%p, STATE=%d, PORTSC=0x%x, CMD=0x%x, ENDPT[0]=0x%x\n", 
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 
+                    usb_dev_ptr, usb_dev_ptr->USB_STATE,
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]));
+
+        usb_dev_ptr->BUS_RESETTING = TRUE;
+        usb_dev_ptr->USB_STATE = ARC_USB_STATE_POWERED;
+    } 
+    else 
+    { 
+        USB_printf("USB Chip reinit: PORTSC=0x%x, frame# %d ERROR_STATE %x\n", 
+                USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+		USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX)>>3,
+		usb_dev_ptr->ERROR_STATE);
+
+#if 1
+    // xj add
+    if(reset_done) {
+            goto reinit;
+    } else {
+	    reset_done = 1;
+    }
+#endif
+        /* re-initialize */      
+        _usb_dci_vusb20_chip_initialize((pointer)usb_dev_ptr);
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "process_reset, Chip reinit hw\n");
+    } /* Endif */
+   
+reinit:
+    _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_BUS_RESET, 1, 0, 0, 0, 0);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_suspend
+*  Returned Value : None
+*  Comments       :
+*        Services suspend interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_suspend
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR        dev_ptr;
+   
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_suspend\n");
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_suspend_count++));
+   
+    usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND = usb_dev_ptr->USB_STATE;
+   
+    usb_dev_ptr->USB_STATE = ARC_USB_STATE_SUSPEND;
+
+    /* Inform the upper layers */
+    _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SLEEP, 0, 0, 0, 0, 0);
+   
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_SOF
+*  Returned Value : None
+*  Comments       :
+*        Services SOF interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_SOF
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_SOF\n");
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Inform the upper layer */   
+   _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SOF, 0, 0, 0, 
+      USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 0);
+
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_port_change
+*  Returned Value : None
+*  Comments       :
+*        Services port change detect interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_port_change
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR                        dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_port_change\n");
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_port_change_count++));
+
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    USB_printf("port_change: PORTSC=0x%x, DTD_ENTRIES=%d, XD_ENTRIES=%d\n", 
+                USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+                usb_dev_ptr->DTD_ENTRIES, usb_dev_ptr->XD_ENTRIES);
+
+    if (usb_dev_ptr->BUS_RESETTING) 
+    {
+        /* Bus reset operation complete */
+        usb_dev_ptr->BUS_RESETTING = FALSE;
+    } /* Endif */
+   
+    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
+                                                EHCI_PORTSCX_PORT_RESET)) 
+    {
+        /* Get the speed */
+        if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
+                                            EHCI_PORTSCX_PORT_HIGH_SPEED) 
+        {
+            usb_dev_ptr->SPEED = ARC_USB_SPEED_HIGH;
+        } 
+        else 
+        {
+            usb_dev_ptr->SPEED = ARC_USB_SPEED_FULL;
+        } /* Endif */
+
+        USB_printf("USB %s speed device detected\n", 
+                (usb_dev_ptr->SPEED == ARC_USB_SPEED_HIGH) ? "High" : "Full");
+
+        /* Inform the upper layers of the speed of operation */      
+        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SPEED_DETECTION, 0, 0, 
+                                0, usb_dev_ptr->SPEED, 0);
+    } /* Endif */
+      
+    if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & 
+                                                EHCI_PORTSCX_PORT_SUSPEND) 
+    {   
+        usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND = usb_dev_ptr->USB_STATE;
+        usb_dev_ptr->USB_STATE = ARC_USB_STATE_SUSPEND;
+
+        /* Inform the upper layers */
+        USB_printf("USB suspend\n");
+        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SUSPEND, 0, 0, 0, 0, 0);
+    } /* Endif */
+   
+    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & EHCI_PORTSCX_PORT_SUSPEND) 
+                    && (usb_dev_ptr->USB_STATE == ARC_USB_STATE_SUSPEND)) 
+    {
+        USB_printf("USB resume\n");
+        usb_dev_ptr->USB_STATE = usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND;
+        /* Inform the upper layers */
+        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_RESUME, 0, 0, 0, 0, 0);
+
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SUSPEND, "process_port_change, SUCCESSFUL, resumed\n");
+        return;
+    } /* Endif */
+   
+    usb_dev_ptr->USB_STATE = ARC_USB_STATE_DEFAULT;
+      
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_error
+*  Returned Value : None
+*  Comments       :
+*        Services error interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_error
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR          usb_dev_ptr;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ERROR, "process_error\n");
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   
+   /* Increment the error count */
+   usb_dev_ptr->ERRORS++;
+   
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_set_speed_full
+*  Returned Value : None
+*  Comments       :
+*        Force the controller port in full speed mode.
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_set_speed_full
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+     
+      /* The port number on the device */
+      uint_8                     port_number
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   uint_32                                      port_control;
+   
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ANY, "FORCE set_speed_full\n");
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);   
+   port_control |= EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT;
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number] = USB_32BIT_LE(port_control);
+  
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_suspend_phy
+*  Returned Value : None
+*  Comments       :
+*        Suspends the PHY in low power mode
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_suspend_phy
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+     
+      /* The port number on the device */
+      uint_8                     port_number
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   uint_32                                      port_control;
+      
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SUSPEND, "set_suspend_phy\n");
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);   
+   port_control |= EHCI_PORTSCX_PHY_CLOCK_DISABLE;
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number] = USB_32BIT_LE(port_control);
+   
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_set_address
+*  Returned Value : None
+*  Comments       :
+*        Sets the newly assigned device address
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_set_address
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+     
+      /* Address of the device assigned by the host */
+      uint_8                     address
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR          usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR             dev_ptr;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "set_address: address=%d\n",address);
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE   
+   /***********************************************************
+   Hardware Rev 4.0 onwards have special assistance built in
+   for handling the set_address command. As per the USB specs
+   a device should be able to receive the response on a new
+   address, within 2 msecs after status phase of set_address is
+   completed. Since 2 mili second may be a very small time window
+   (on high interrupt latency systems) before software could 
+   come to the code below and write the device register,
+   this routine will be called in advance when status phase of
+   set_address is still not finished. The following line in the
+   code will set the bit 24 to '1' and hardware will take
+   the address and queue it in an internal buffer. From which
+   it will use it to decode the next USB token. Please look
+   at hardware rev details for the implementation of this
+   assistance.
+   
+   Also note that writing bit 24 to 0x01 will not break
+   any old hardware revs because it was an unused bit.
+   ***********************************************************/
+   /* The address bits are past bit 25-31. Set the address 
+   also set the bit 24 to 0x01 to start hardware assitance*/
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR = 
+      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT) | 
+      (0x01 << (VUSBHS_ADDRESS_BIT_SHIFT -1)); 
+#else
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR = 
+      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT); 
+#endif /* SET_ADDRESS_HARDWARE_ASSISTANCE */
+   
+   usb_dev_ptr->USB_STATE = ARC_USB_STATE_ADDRESS;
+      
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_get_setup_data
+*  Returned Value : None
+*  Comments       :
+*        Reads the Setup data from the 8-byte setup buffer
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_get_setup_data
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [OUT] address of the buffer to read the setup data into */
+      uint_8_ptr                  buffer_ptr
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR                    usb_dev_ptr;
+    volatile VUSB20_REG_STRUCT_PTR              dev_ptr;
+    volatile VUSB20_EP_QUEUE_HEAD_STRUCT_PTR    ep_queue_head_ptr;
+    volatile boolean                            read_safe = FALSE;                      
+    volatile unsigned long                      timeout;
+
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Get the endpoint queue head */
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
+                                                                2*ep_num + ARC_USB_RECV;
+
+   /********************************************************************
+   CR 1219. Hardware versions 2.3+ have a implementation of tripwire 
+   semaphore mechanism that requires that we read the contents of 
+   QH safely by using the semaphore. Read the USBHS document to under
+   stand how the code uses the semaphore mechanism. The following are
+   the steps in brief
+   
+   1. USBCMD Write 1 to Setup Tripwire in register.
+   2. Duplicate contents of dQH.StatusBuffer into local software byte
+      array.
+   3  Read Setup TripWire in register. (if set - continue; if
+      cleared goto 1.)
+   4. Write '0' to clear Setup Tripwire in register.
+   5. Process setup packet using local software byte array copy and
+      execute status/handshake phases.
+   
+           
+   ********************************************************************/
+    timeout = 0x100000;
+    while(!read_safe)
+    {
+        /*********************************************************
+        start with setting the semaphores
+        *********************************************************/
+
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |= 
+                                                USB_32BIT_LE(EHCI_CMD_SETUP_TRIPWIRE_SET);
+
+        /* Copy the setup packet to private buffer */
+        USB_memcopy((uint_8_ptr)ep_queue_head_ptr->SETUP_BUFFER, buffer_ptr, 8);
+
+        /*********************************************************
+        If setup tripwire semaphore is cleared by hardware it means
+        that we have a danger and we need to restart.
+        else we can exit out of loop safely.
+        *********************************************************/
+        if(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD) &
+                                                   EHCI_CMD_SETUP_TRIPWIRE_SET)
+        {
+            read_safe = TRUE; /* we can proceed exiting out of loop*/
+        }
+        if(timeout <= 0)
+        {
+            USB_printf("%s: Timeout for SETUP_TRIPWIRE = 0x%x\n", __FUNCTION__, 
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
+            break;
+        }
+    }
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_read_setup_count++));
+  
+   /*********************************************************
+   Clear the semaphore bit now
+   *********************************************************/
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &=
+                                    USB_32BIT_LE(EHCI_CMD_SETUP_TRIPWIRE_CLEAR);                         
+   
+   /* Clear the bit in the ENDPTSETUPSTAT */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(1 << ep_num);
+   
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_init_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Initializes the specified endpoint and the endpoint queue head
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_init_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the transaction descriptor address */
+      XD_STRUCT_PTR              xd_ptr
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT _PTR_            ep_queue_head_ptr;
+   uint_32                                      val, bit_pos;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Get the endpoint queue head address */
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
+                                                    2*xd_ptr->EP_NUM + xd_ptr->BDIRECTION;
+      
+   bit_pos = (1 << (16 * xd_ptr->BDIRECTION + xd_ptr->EP_NUM));
+
+   /* Check if the Endpoint is Primed */
+   if ((!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) && 
+       (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos))) 
+   { 
+      /* Set the max packet length, interrupt on Setup and Mult fields */
+      if (xd_ptr->EP_TYPE == ARC_USB_ISOCHRONOUS_ENDPOINT) 
+      {
+         /* Mult bit should be set for isochronous endpoints */
+         ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) | 
+            ((xd_ptr->MAX_PKTS_PER_UFRAME ?  xd_ptr->MAX_PKTS_PER_UFRAME : 1) << 
+            VUSB_EP_QUEUE_HEAD_MULT_POS));
+      } 
+      else 
+      {
+         if (xd_ptr->EP_TYPE != ARC_USB_CONTROL_ENDPOINT) 
+         {
+             /* BULK or INTERRUPT */
+            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) | 
+               (xd_ptr->DONT_ZERO_TERMINATE ? VUSB_EP_QUEUE_HEAD_ZERO_LEN_TER_SEL : 0));
+         } 
+         else 
+         {
+             /* CONTROL */
+            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) | 
+                                                    VUSB_EP_QUEUE_HEAD_IOS);
+         } /* Endif */
+      } /* Endif */
+      
+      /* Enable the endpoint for Rx or Tx and set the endpoint type */
+      val = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM];
+      if(xd_ptr->BDIRECTION  == ARC_USB_SEND)
+      {
+          val &= ~(USB_32BIT_LE(EHCI_EPCTRL_TX_ALL_MASK));
+          val |= USB_32BIT_LE((EHCI_EPCTRL_TX_ENABLE | EHCI_EPCTRL_TX_DATA_TOGGLE_RST) | 
+                          (xd_ptr->EP_TYPE << EHCI_EPCTRL_TX_EP_TYPE_SHIFT));
+      }
+      else
+      {
+          val &= ~(USB_32BIT_LE(EHCI_EPCTRL_RX_ALL_MASK));
+          val |= USB_32BIT_LE((EHCI_EPCTRL_RX_ENABLE | EHCI_EPCTRL_RX_DATA_TOGGLE_RST) | 
+                          (xd_ptr->EP_TYPE << EHCI_EPCTRL_RX_EP_TYPE_SHIFT));
+      }
+      dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] = val;
+      
+      /* Implement Guideline (GL# USB-7) The unused endpoint type must  */
+      /* be programmed to bulk.                                         */
+      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] & 
+            USB_32BIT_LE(EHCI_EPCTRL_RX_ENABLE)) == 0)
+      {
+          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |= 
+              USB_32BIT_LE(ARC_USB_BULK_ENDPOINT << EHCI_EPCTRL_RX_EP_TYPE_SHIFT);
+      }
+
+      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] & 
+            USB_32BIT_LE(EHCI_EPCTRL_TX_ENABLE)) == 0)
+      {
+          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |= 
+              USB_32BIT_LE(ARC_USB_BULK_ENDPOINT << EHCI_EPCTRL_TX_EP_TYPE_SHIFT);
+      }
+
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT,
+                    "init ep #%d %s: type=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n", 
+                        xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV", xd_ptr->EP_TYPE, 
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM]),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
+   } 
+   else 
+   { 
+      USB_printf("ep=%d %s: Init ERROR: ENDPTPRIME=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                (unsigned)xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV",
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                (unsigned)bit_pos);
+        return USBERR_EP_INIT_FAILED;
+   } /* Endif */
+      
+   return USB_OK;
+   
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_get_transfer_status
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Gets the status of a transfer
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_get_transfer_status
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+     
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR                      dTD_ptr;
+   XD_STRUCT_PTR                                xd_ptr;
+   uint_8                                       status;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+  
+   /* Unlink the dTD */
+   dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[2*ep_num + direction];
+
+   if (dTD_ptr) 
+   {
+      /* Get the transfer descriptor for the dTD */
+      xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+      status = xd_ptr->BSTATUS;
+   } 
+   else 
+   {
+      status = ARC_USB_STATUS_IDLE;
+   } /* Endif */
+   
+   return (status);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_get_transfer_details
+*  Returned Value : pointer to structure that has details for transfer
+*        Gets the status of a transfer
+*
+*END*-----------------------------------------------------------------*/
+XD_STRUCT_PTR  _usb_dci_vusb20_get_transfer_details
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+     
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR                      dTD_ptr, temp_dTD_ptr;
+   XD_STRUCT_PTR                                xd_ptr;
+   uint_32                                      temp, remaining_bytes;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR              ep_queue_head_ptr;
+
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   temp = (2*ep_num + direction);
+
+   /* get a pointer to QH for this endpoint */   
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "get_transfer_details\n");
+   
+   /* Unlink the dTD */
+   dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[2*ep_num + direction];
+
+   if (dTD_ptr) 
+   {      
+      /* Get the transfer descriptor for the dTD */
+      xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+      if(!xd_ptr) return NULL;
+      
+      /* Initialize the transfer length field */
+      xd_ptr->WSOFAR =0;
+      remaining_bytes =0;
+      
+      /*if length of this transfer is greater than 20K
+      we have multiple DTDs to count */
+      if(xd_ptr->WTOTALLENGTH > VUSB_EP_MAX_LENGTH_TRANSFER)
+      {
+         /* it is a valid DTD. We should parse all DTDs for this XD
+         and find the total bytes used so far */
+         temp_dTD_ptr = dTD_ptr;
+      
+         /*loop through the list of DTDS until an active DTD is found
+         or list has finished */
+         while(!(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_NEXT_TERMINATE))         
+         {
+            
+            /**********************************************************
+            If this DTD has been overlayed, we take the actual length 
+            from QH.
+            **********************************************************/
+
+            if ((uint_32)(USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR) & VUSBHS_TD_ADDR_MASK) ==
+                                     USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, temp_dTD_ptr) )
+            {
+                remaining_bytes += 
+                  ((USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+            }
+            else
+            {
+               /* take the length from DTD itself */
+                remaining_bytes += 
+                  ((USB_32BIT_LE(temp_dTD_ptr->SIZE_IOC_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+            }
+   
+            dTD_ptr = temp_dTD_ptr;
+             
+            /* Get the address of the next dTD */
+            temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, 
+                                (uint_32)(USB_32BIT_LE(temp_dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) );
+         }
+         xd_ptr->WSOFAR = xd_ptr->WTOTALLENGTH - remaining_bytes;
+      }
+      else
+      {
+         /*look at actual length from QH*/
+         xd_ptr->WSOFAR = xd_ptr->WTOTALLENGTH - 
+            ((USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);         
+      }      
+   } 
+   else 
+   {
+      xd_ptr = NULL;
+   } /* Endif */
+   
+   return (xd_ptr);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_deinit_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Disables the specified endpoint and the endpoint queue head
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_deinit_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR        usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR           dev_ptr;
+    VUSB20_EP_QUEUE_HEAD_STRUCT*    ep_queue_head_ptr;
+    uint_32                         bit_pos;
+    uint_8                          status = USB_OK;
+   
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+    /* Get the endpoint queue head address */
+    ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
+                                                                    (2*ep_num + direction);
+      
+    bit_pos = (1 << (16 * direction + ep_num));
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT,
+               "deinit ep #%d-%s: bit_pos=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n", 
+                   ep_num, direction ? "SEND" : "RECV", bit_pos,
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
+      
+    /* Check if the Endpoint is Primed */
+    if( ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) || 
+        ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)) ) 
+    { 
+        USB_printf("ep=%d %s: Deinit ERROR: ENDPTPRIME=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                (unsigned)ep_num, direction ? "SEND" : "RECV",
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS), 
+                (unsigned)bit_pos);
+        status = USBERR_EP_DEINIT_FAILED;
+    }
+
+    /* Reset the max packet length and the interrupt on Setup */
+    ep_queue_head_ptr->MAX_PKT_LENGTH = 0;
+      
+    /* Disable the endpoint for Rx or Tx and reset the endpoint type */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &= 
+         USB_32BIT_LE( ~((direction ? EHCI_EPCTRL_TX_ENABLE : EHCI_EPCTRL_RX_ENABLE) | 
+                        (direction ? EHCI_EPCTRL_TX_TYPE : EHCI_EPCTRL_RX_TYPE)));
+      
+   return status;
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_shutdown
+*  Returned Value : None
+*  Comments       :
+*        Shuts down the VUSB_HS Device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_shutdown
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+    /* Disable interrupts */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &= 
+      ~(USB_32BIT_LE(EHCI_INTR_INT_EN | EHCI_INTR_ERR_INT_EN |
+      EHCI_INTR_PORT_CHANGE_DETECT_EN | EHCI_INTR_RESET_EN));
+      
+    USB_uncached_memfree(usb_dev_ptr->EP_QUEUE_HEAD_BASE, 
+                        usb_dev_ptr->EP_QUEUE_HEAD_SIZE, 
+                        usb_dev_ptr->EP_QUEUE_HEAD_PHYS);
+
+    USB_uncached_memfree(usb_dev_ptr->DTD_BASE_PTR, 
+                        usb_dev_ptr->DTD_SIZE, 
+                        usb_dev_ptr->DTD_BASE_PHYS);
+
+    USB_memfree(usb_dev_ptr->SCRATCH_STRUCT_BASE);
+
+    USB_printf("USB shutdown: usb_dev_ptr=%p\n", usb_dev_ptr);
+
+   /* Reset the Run the bit in the command register to stop VUSB */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~USB_32BIT_LE(EHCI_CMD_RUN_STOP);
+   
+   /* Reset the controller to get default values */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_CTRL_RESET);
+              
+} /* EndBody */
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_stop
+*  Returned Value : None
+*  Comments       :
+*        Stop USB device controller
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_stop(_usb_device_handle handle)
+{
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    /* Disable interrupts */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &= 
+            ~(USB_32BIT_LE(EHCI_INTR_INT_EN | EHCI_INTR_ERR_INT_EN |
+                           EHCI_INTR_PORT_CHANGE_DETECT_EN | EHCI_INTR_RESET_EN));
+
+   /* Reset the Run the bit in the command register to stop VUSB */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~USB_32BIT_LE(EHCI_CMD_RUN_STOP);
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_start
+*  Returned Value : None
+*  Comments       :
+*        Start USB device controller
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_start(_usb_device_handle handle)
+{
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+      /* Enable interrupts */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR = USB_32BIT_LE(
+                           EHCI_INTR_INT_EN
+                         | EHCI_INTR_ERR_INT_EN 
+                         | EHCI_INTR_PORT_CHANGE_DETECT_EN 
+                         | EHCI_INTR_RESET_EN 
+                         | EHCI_INTR_DEVICE_SUSPEND
+                       /*  
+                         | EHCI_INTR_SOF_UFRAME_EN 
+                        */
+                         );
+   
+   usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
+   
+   /* Set the Run bit in the command register */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_RUN_STOP);
+}
+
+//----------------------------------------------------------------------------------------
+//  _usb_dci_vusb20_set_xcvr_interface()
+//
+//
+//----------------------------------------------------------------------------------------
+void _usb_dci_vusb20_set_xcvr_interface( _usb_device_handle handle, unsigned int setting, unsigned int port )
+{
+    USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR            dev_ptr;
+    unsigned int                           temp;
+    
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+    dev_ptr     = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+    temp        = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port];
+    
+    temp &= ~EHCI_PORTSCX_PAR_XCVR_SELECT;
+    temp |= setting;
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port] = temp;
+}
+
+
+/* EOF */
+
+
diff --git a/board/pxa/common/usbeth/mvUsbHsDevUtl.c b/board/pxa/common/usbeth/mvUsbHsDevUtl.c
new file mode 100644
index 0000000..287c2e4
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbHsDevUtl.c
@@ -0,0 +1,272 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#include "mvUsbDevApi.h"
+#include "mvUsbDevPrv.h"
+#include "mvUsbDefs.h"
+
+/* Test packet for Test Mode : TEST_PACKET. USB 2.0 Specification section 7.1.20 */
+uint_8 test_packet[USB_TEST_MODE_TEST_PACKET_LENGTH] = 
+{
+   /* Synch */
+   /* DATA 0 PID */
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 
+   0xAA, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 
+   0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
+   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF, 
+   0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF, 
+   0xEF, 0xF7, 0xFB, 0xFD, 0x7E
+};
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_assert_resume
+*  Returned Value : None
+*  Comments       :
+*        Resume signalling for remote wakeup
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_assert_resume
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR             dev_ptr;
+   uint_32                                      temp;
+ 
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Assert the Resume signal */   
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
+   temp &= ~EHCI_PORTSCX_W1C_BITS;
+   temp |= EHCI_PORTSCX_PORT_FORCE_RESUME;
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] = USB_32BIT_LE(temp);
+   
+   /* Port change interrupt will be asserted at the end of resume 
+   ** operation 
+   */
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_stall_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Stalls the specified endpoint
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_stall_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR             usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                dev_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT _PTR_    ep_queue_head_ptr;
+      
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+   /* Get the endpoint queue head address */
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + 
+                                                                    2*ep_num + direction;
+   /* Stall the endpoint for Rx or Tx and set the endpoint type */
+   if (ep_queue_head_ptr->MAX_PKT_LENGTH & USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_IOS)) 
+   {
+      /* This is a control endpoint so STALL both directions */
+      dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+         USB_32BIT_LE((EHCI_EPCTRL_TX_EP_STALL | EHCI_EPCTRL_RX_EP_STALL));
+   } 
+   else 
+   {   
+       if(direction) 
+       {
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+                        USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL);
+       }
+       else {
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+                        USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL);
+       }
+   } /* Endif */
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL, 
+                    "STALL ep=%d %s: EPCTRLX=0x%x, CURR_dTD=0x%x, NEXT_dTD=0x%x, SIZE=0x%x\n", 
+                    ep_num, direction ? "SEND" : "RECV",
+                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]),
+                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR), 
+                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->NEXT_DTD_PTR),
+                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS));
+      
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_unstall_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Unstall the specified endpoint in the specified direction
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_unstall_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+            
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+            
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+   /* Enable the endpoint for Rx or Tx and set the endpoint type */
+   if(direction)
+   {
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+              USB_32BIT_LE(EHCI_EPCTRL_TX_DATA_TOGGLE_RST);
+
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &= 
+                ~(USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL));
+   }
+   else
+   {
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |= 
+              USB_32BIT_LE(EHCI_EPCTRL_RX_DATA_TOGGLE_RST);
+
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &= 
+                ~(USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL));
+   }     
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL, 
+                    "UNSTALL ep=%d %s: EPCTRLX=0x%x\n", 
+                    ep_num, direction ? "SEND" : "RECV",
+                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]));
+
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : _usb_dci_vusb20_is_endpoint_stalled
+* Returned Value : None
+* Comments       :
+*     Gets the endpoint status
+* 
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_is_endpoint_stalled
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle   handle,
+      
+      /* [IN] Endpoint number */
+      uint_8               ep,
+
+      /* [IN] Endpoint direction */
+      uint_8               dir
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   uint_32                      value;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "is_endpoint_stalled\n");
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+  
+   if(dir)
+   {
+        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] & 
+                                    (USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL));
+   }
+   else
+   {
+        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] & 
+                                    (USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL));
+   }
+   return (value) ? 1 : 0;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+* 
+* Function Name  : _usb_dci_vusb20_set_test_mode
+* Returned Value : None
+* Comments       :
+*     sets/resets the test mode
+* 
+*END*--------------------------------------------------------------------*/
+void _usb_dci_vusb20_set_test_mode
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle handle,
+      
+      /* [IN] Test mode */
+      uint_16 test_mode
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   uint_32                                      temp;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ANY, "set_test_mode\n");
+   
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]);
+   
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0] = 
+                                USB_32BIT_LE((temp | EHCI_EPCTRL_TX_DATA_TOGGLE_RST));
+
+   if (test_mode == ARC_USB_TEST_MODE_TEST_PACKET) 
+   {
+       USB_memcopy(test_packet, usb_dev_ptr->TEST_PKT_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH); 
+      _usb_device_send_data(handle, 0, usb_dev_ptr->TEST_PKT_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH);
+
+   } /* Endif */
+   
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
+   temp &= ~EHCI_PORTSCX_W1C_BITS;
+   
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] = 
+                                    USB_32BIT_LE(temp | ((uint_32)test_mode << 8));
+             
+} /* EndBody */
+
+
diff --git a/board/pxa/common/usbeth/mvUsbTypes.h b/board/pxa/common/usbeth/mvUsbTypes.h
new file mode 100644
index 0000000..d260b9f
--- /dev/null
+++ b/board/pxa/common/usbeth/mvUsbTypes.h
@@ -0,0 +1,240 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd. 
+or its affiliate(s) under the terms of the GNU General Public License Version 2, 
+June 1991 (the "License").  You may use, redistribute and/or modify this File 
+in accordance with the terms and conditions of the License, a copy of which 
+is available along with the File in the license.txt file or by writing to the 
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbTypes_h__
+#define __mvUsbTypes_h__
+
+#define _PTR_      *
+#define _CODE_PTR_ *
+
+typedef char _PTR_                    char_ptr;    /* signed character       */
+
+typedef signed   char  int_8, _PTR_   int_8_ptr;   /* 8-bit signed integer   */
+typedef unsigned char  uint_8, _PTR_   uint_8_ptr;  /* 8-bit signed integer   */
+
+typedef          short int_16, _PTR_   int_16_ptr;  /* 16-bit signed integer  */
+typedef unsigned short uint_16, _PTR_  uint_16_ptr; /* 16-bit unsigned integer*/
+
+typedef          int   int_32, _PTR_   int_32_ptr;  /* 32-bit signed integer  */
+typedef unsigned int   uint_32, _PTR_  uint_32_ptr; /* 32-bit unsigned integer*/
+
+typedef unsigned long  boolean;  /* Machine representation of a boolean */
+
+typedef void _PTR_     pointer;  /* Machine representation of a pointer */
+
+/*--------------------------------------------------------------------------*/
+/*
+**                          STANDARD CONSTANTS
+**
+**  Note that if standard 'C' library files are included after types.h,
+**  the defines of TRUE, FALSE and NULL may sometimes conflict, as most
+**  standard library files do not check for previous definitions.
+*/
+
+#ifndef  FALSE
+#   define FALSE ((boolean)0)   
+#endif
+
+#ifndef  TRUE
+#   define TRUE ((boolean)!FALSE) 
+#endif
+
+#ifndef  NULL
+#   ifdef __cplusplus
+#       define NULL (0)
+#   else
+#       define NULL ((pointer)0)
+#   endif
+#endif
+
+#ifndef _ASSERT_
+   #define ASSERT(X,Y)
+#else
+   #define ASSERT(X,Y) if(Y) { USB_printf(X); exit(1);}
+#endif
+
+#ifndef  MIN
+#   define MIN(a,b)   ((a) < (b) ? (a) : (b))      
+#endif
+
+#define USB_MEM_ALIGN(n, align)            ((n) + (-(n) & (align-1)))
+
+/* Macro for aligning the EP queue head to 32 byte boundary */
+#define USB_MEM32_ALIGN(n)                  USB_MEM_ALIGN(n, 32)
+
+/* Macro for aligning the EP queue head to 1024 byte boundary */
+#define USB_MEM1024_ALIGN(n)                USB_MEM_ALIGN(n, 1024)
+
+/* Macro for aligning the EP queue head to 1024 byte boundary */
+#define USB_MEM2048_ALIGN(n)                USB_MEM_ALIGN(n, 2048)
+
+#define PSP_CACHE_LINE_SIZE                 32
+
+#define USB_uint_16_low(x)                  ((x) & 0xFF)
+#define USB_uint_16_high(x)                 (((x) >> 8) & 0xFF)
+
+#define USB_CACHE_ALIGN(n)                  USB_MEM_ALIGN(n, PSP_CACHE_LINE_SIZE)       
+
+#ifndef INLINE
+#   if defined(MV_VXWORKS)
+#       define INLINE   __inline
+#   else
+#       define INLINE   inline
+#   endif /* MV_VXWORKS */
+#endif /* INLINE */
+
+/* 16bit byte swap. For example 0x1122 -> 0x2211                            */
+static INLINE uint_16 USB_BYTE_SWAP_16BIT(uint_16 value)
+{
+    return ( ((value & 0x00ff) << 8) | 
+             ((value & 0xff00) >> 8) );
+}
+
+/* 32bit byte swap. For example 0x11223344 -> 0x44332211                    */
+static INLINE uint_32 USB_BYTE_SWAP_32BIT(uint_32 value)
+{
+    return ( ((value & 0x000000ff) << 24) |                      
+             ((value & 0x0000ff00) << 8)  |                    
+             ((value & 0x00ff0000) >> 8)  |       
+             ((value & 0xff000000) >> 24));
+}
+
+#define MV_CPU_LE //xj
+    
+/* Endianess macros.                                                        */
+#if defined(MV_CPU_LE)
+#   define USB_16BIT_LE(X)  (X) 
+#   define USB_32BIT_LE(X)  (X)
+#   define USB_16BIT_BE(X)  USB_BYTE_SWAP_16BIT(X)
+#   define USB_32BIT_BE(X)  USB_BYTE_SWAP_32BIT(X)
+#elif defined(MV_CPU_BE)
+#   define USB_16BIT_LE(X)  USB_BYTE_SWAP_16BIT(X) 
+#   define USB_32BIT_LE(X)  USB_BYTE_SWAP_32BIT(X)
+#   define USB_16BIT_BE(X)  (X)
+#   define USB_32BIT_BE(X)  (X)
+#else
+    #error "CPU endianess isn't defined!\n"
+#endif 
+
+typedef struct
+{
+    void    (*bspPrintf)          (const char *  fmt, ...);
+    int     (*bspSprintf)         (char* buffer, const char *  fmt, ...);
+    void*   (*bspUncachedMalloc)  (void* pDev, uint_32 size, uint_32 align,
+                                   unsigned long* pPhyAddr);     
+    void    (*bspUncachedFree)    (void* pDev, uint_32 size, unsigned long phyAddr, 
+                                    void*  pVirtAddr);
+    void*   (*bspMalloc)          (unsigned int size);
+    void    (*bspFree)            (void* ptr);
+    void*   (*bspMemset)          (void* ptr, int val, unsigned int size);
+    void*   (*bspMemcpy)          (void* dst, const void* src, unsigned int size);
+    unsigned long (*bspCacheFlush)      (void* pDev, void* pVirtAddr, int size);
+    unsigned long (*bspCacheInv)        (void* pDev, void* pVirtAddr, int size);
+    unsigned long (*bspVirtToPhys)    (void* pDev, void* pVirtAddr);
+    int     (*bspLock)            (void);
+    void    (*bspUnlock)          (int lockKey);
+    uint_32 (*bspGetCapRegAddr)   (int devNo);
+    void    (*bspResetComplete)   (int devNo);
+
+} USB_IMPORT_FUNCS;
+
+extern USB_IMPORT_FUNCS*            global_import_funcs;
+
+#define USB_sprintf(frmt, x...)     if( (global_import_funcs != NULL) &&                \
+                                         global_import_funcs->bspSprintf != NULL)        \
+                                        global_import_funcs->bspSprintf(frmt, ##x)
+
+#define USB_printf(frmt, x...)      if( (global_import_funcs != NULL) &&                \
+                                        (global_import_funcs->bspPrintf != NULL) )        \
+                                        global_import_funcs->bspPrintf(frmt, ##x)
+
+
+#define USB_virt_to_phys(pVirt)     (global_import_funcs->bspVirtToPhys == NULL) ?      \
+                                        (uint_32)(pVirt) : global_import_funcs->bspVirtToPhys(NULL, pVirt)
+
+#define USB_get_cap_reg_addr(dev)   global_import_funcs->bspGetCapRegAddr(dev)
+
+static INLINE void* USB_uncached_memalloc(uint_32 size, uint_32 align, unsigned long* pPhyAddr) 
+{
+    /*USB_printf("**** USB_uncached_memalloc: size=%d\n", (size));       */
+    return global_import_funcs->bspUncachedMalloc(NULL, size, align, pPhyAddr); 
+}
+
+static INLINE void* USB_memalloc(uint_32 size)                                                                              
+{
+    /*USB_printf("**** USB_memalloc: size=%d\n", (size)); */
+    return global_import_funcs->bspMalloc(size);        
+}
+
+#define USB_uncached_memfree(pVirt, size, physAddr)                                 \
+                /*USB_printf("#### USB_uncached_memfree: pVirt=0x%x\n", (pVirt)); */\
+                global_import_funcs->bspUncachedFree(NULL, size, physAddr, pVirt);
+
+#define USB_memfree(ptr)                                                            \
+                /*USB_printf("#### USB_memfree: ptr=0x%x\n", (ptr));*/              \
+                global_import_funcs->bspFree(ptr);
+
+#define USB_memzero(ptr, n)         global_import_funcs->bspMemset(ptr, 0,  n)
+#define USB_memcopy(src, dst, n)    global_import_funcs->bspMemcpy(dst, src, n)
+
+#define USB_dcache_inv(ptr, size)   if(global_import_funcs->bspCacheInv != NULL)  \
+                                        global_import_funcs->bspCacheInv(NULL, ptr, size)     
+
+#define USB_dcache_flush(ptr, size) if(global_import_funcs->bspCacheFlush != NULL)  \
+                                        global_import_funcs->bspCacheFlush(NULL, ptr, size)     
+
+#define USB_lock()                  (global_import_funcs->bspLock == NULL) ?        \
+                                                    0 : global_import_funcs->bspLock()
+
+#define USB_unlock(key)             if(global_import_funcs->bspUnlock != NULL)  \
+                                        global_import_funcs->bspUnlock(key)     
+
+#define USB_reset_complete(dev)     if(global_import_funcs->bspResetComplete)       \
+                                        global_import_funcs->bspResetComplete(dev)
+
+
+#if defined(USB_UNDERRUN_WA)
+
+#define USB_SRAM_MAX_PARTS  16  
+
+typedef struct
+{
+    uint_32 (*bspGetSramAddr) (uint_32* pSize);
+    void    (*bspIdmaCopy) (void* dst, void* src, unsigned int size);
+
+} USB_WA_FUNCS;
+
+extern USB_WA_FUNCS*    global_wa_funcs;
+extern int              global_wa_sram_parts;
+extern int              global_wa_threshold; 
+
+#define USB_get_sram_addr(pSize)        global_wa_funcs->bspGetSramAddr(pSize)
+
+#define USB_idma_copy(dst, src, size)                                   \
+            if(global_wa_funcs->bspIdmaCopy != NULL)                    \
+                global_wa_funcs->bspIdmaCopy(dst, src, size)
+
+#endif /* USB_UNDERRUN_WA */
+
+#endif /* __mvUsbTypes_h__ */
+
+/* EOF */
+
+
diff --git a/board/pxa/common/usbeth/mv_u2o_api.c b/board/pxa/common/usbeth/mv_u2o_api.c
new file mode 100644
index 0000000..a95f00d
--- /dev/null
+++ b/board/pxa/common/usbeth/mv_u2o_api.c
@@ -0,0 +1,689 @@
+
+//#define DEBUG
+//#include <configs/zylonite2.h>
+#include <common.h>
+
+#include <linux/types.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <common.h>
+#include <config.h>
+#include <net.h>
+#include <command.h>
+#include <malloc.h>
+
+#include "pxa_usb.h"
+#include "mv_u2o_ctl.h"
+#include "mv_u2o_api.h"
+#include "mvUsbCh9.h"
+#include "mvUsbDevApi.h"
+
+
+/*****************************************************************************
+ * BSP related functions
+ *****************************************************************************/
+
+#define U2O_MEM_SIZE 0x20000 // 128KB memory
+static unsigned char mem_base[U2O_MEM_SIZE];
+static unsigned long mem_ptr = (unsigned long)&mem_base[0];
+static unsigned long mem_size = U2O_MEM_SIZE;
+
+static unsigned long dma_base = 0;
+static unsigned long dma_ptr = 0;
+static unsigned long dma_size = 0x10000;
+
+static struct usb_request setup_req;
+
+#undef U2O_MALLOC  /* cache flush/invalidate function fail, don't use malloc here */
+
+#define PRINTF_BUFFER_LENGTH 1024
+static char printf_buffer[PRINTF_BUFFER_LENGTH];
+
+
+#define __raw_readl(addr) 	(*(volatile u32 *) (addr))
+#define readl(addr) 		(*(volatile u32 *) (addr))
+#define writel(b, addr)		((*(volatile u32 *) (addr)) = (b))
+
+#if 0
+static void mvOsPrintf(const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = vsnprintf(printf_buffer, PRINTF_BUFFER_LENGTH, fmt, args);
+	va_end(args);
+
+	SerialOutputString(printf_buffer);
+}
+#endif
+
+static void *u2o_dma_malloc(void *dev, uint_32 size, uint_32 align,
+                                   unsigned long* paddr)
+{
+	void *ptr;
+
+#if 0
+	if (!dma_base) {
+		dma_base = dma_ptr = malloc(dma_size);
+	}
+	if (size & (align-1)) {
+		size |= (align-1);
+		size += 1;
+	}
+	ptr = (void *)dma_ptr;
+	dma_ptr += size;
+	if (dma_ptr > (dma_base + dma_size)) {
+		printf("lack of u2o dma mem, dma_base %x dma_ptr %x size %x\n",
+			(int)dma_base, (int)dma_ptr, (int)dma_size);
+		return NULL;
+	}
+	*paddr = ptr;
+	
+	USB_printf("%s ptr %p size %x\n", __func__, ptr, (int)size);
+#else
+	ptr = malloc(dma_size);
+	*paddr = ptr;
+#endif
+	return ptr;
+}
+
+static void u2o_dma_free(void * ptr)
+{
+#if 0
+	USB_printf("%s!!! ptr %p\n\n", __func__, ptr);
+	dma_ptr = dma_base;
+	memset((void*)dma_base, 0, sizeof(dma_base));
+#else
+	free(ptr);
+#endif
+}
+
+void *u2o_malloc(unsigned long size)
+{
+#ifdef U2O_MALLOC
+	void *ptr = (void *)mem_ptr;
+
+	if (size & 0x1f) {
+		size |= 0x1f;
+		size += 1;
+	}
+	mem_ptr += size;
+	if ((unsigned)mem_ptr > ((unsigned)(&mem_base[0]) + mem_size)) {
+		printf("lack of u2o mem\n");
+		return NULL;
+	}
+	printf("%s ptr %p size %x\n", __func__, ptr, (int)size);
+	return ptr;
+#else
+	int a;
+	return malloc(size);
+#endif
+}
+
+static void u2o_free(void * ptr)
+{
+#ifdef U2O_MALLOC
+	printf("%s not real, ptr %p\n\n", __func__, ptr);
+	mem_ptr = (unsigned long)&mem_base[0];
+	memset(mem_base, 0, sizeof(mem_base));
+#else
+//	u2o_dma_free(0);
+	free(ptr);
+#endif
+}
+
+static void dma_flush_range(unsigned start, unsigned end)
+{
+	/* still has problem here, may cause data crupt */
+	asm (
+	"bic     r0, r0, #31 \n\t"
+	"1: \n\t"
+        "mcr     p15, 0, r0, c7, c14, 1          @ clean/invalidate L1 D line \n\t"
+        "mcr     p15, 1, r0, c7, c11, 1          @ clean L2 line \n\t"
+        "mcr     p15, 1, r0, c7, c7, 1           @ invalidate L2 line \n\t"
+        "add     r0, r0, #32 \n\t"
+        "cmp     r0, r1 \n\t"
+        "blo     1b \n\t"
+        "mcr     p15, 0, r0, c7, c10, 4          @ data write barrier \n\t");
+}
+static void dma_inv_range(unsigned start, unsigned end)
+{
+	/* still has problem here, may cause hang */
+	asm (
+	"tst     r0, #31 \n\t"
+        "bic     r0, r0, #31 \n\t"
+        "mcrne   p15, 0, r0, c7, c10, 1          @ clean L1 D line \n\t"
+        "mcrne   p15, 1, r0, c7, c11, 1          @ clean L2 line \n\t"
+        "tst     r1, #31 \n\t"
+        "mcrne   p15, 0, r1, c7, c10, 1          @ clean L1 D line \n\t"
+        "mcrne   p15, 1, r1, c7, c11, 1          @ clean L2 line \n\t" 
+	"1: \n\t"
+	"mcr     p15, 0, r0, c7, c6, 1           @ invalidate L1 D line \n\t"
+        "mcr     p15, 1, r0, c7, c7, 1           @ invalidate L2 line \n\t" 
+        "add     r0, r0, #32 \n\t"
+        "cmp     r0, r1 \n\t"
+        "blo     1b \n\t" 
+        "mcr     p15, 0, r0, c7, c10, 4          @ data write barrier \n\t");
+}
+
+static void u2o_cache_flush(void* dev, void* vaddr, int size)
+{
+	unsigned start = (unsigned)vaddr, end = ((unsigned)vaddr + size);
+#ifdef U2O_MALLOC
+	USB_printf("%s start %p size %d end %p\n\n", __func__, start, size, end);
+	dma_flush_range(start, end);
+#endif
+}
+
+static void u2o_cache_invalidate(void* dev, void* vaddr, int size)
+{
+	unsigned start = (unsigned)vaddr, end = (unsigned)vaddr + size;
+	
+#ifdef U2O_MALLOC
+	USB_printf("%s start %p size %d end %p\n\n", __func__, start, size, end);
+	dma_inv_range(start, end);
+#endif
+}
+static unsigned long u2o_virt_to_phys(void* dev, void* vaddr)
+{
+	return ((unsigned long)vaddr);
+}
+
+static unsigned int *u2o_get_caps_addr(int dev_num)
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+	
+	return (unsigned int*)(mv_dev->regbase + (0x100 >> 2));
+}
+
+static void u2o_reset_complete(int dev_num)
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+	/* Set USB_MODE register */
+	u2o_write(mv_dev->regbase, U2xUSBMODE, U2xUSBMODE_CM_DEVICE | 
+		U2xUSBMODE_SLOM_OFF | U2xUSBMODE_SDIS_ACTIVE);
+	USB_printf("%s end USBMODE %x\n", __func__, u2o_get(mv_dev->regbase, U2xUSBMODE));
+}
+
+void mv_usb_ep_cancel_all_req(struct mv_usb_ep *mv_ep)
+{
+    struct mv_usb_dev*      mv_dev = &the_controller;
+    int                     req_cntr, tr_cntr;
+
+    req_cntr = tr_cntr = 0;
+
+    /* Cancel all transfers */
+    while(_usb_device_get_transfer_status(mv_dev->mv_usb_handle, mv_ep->num, 
+           mv_ep->is_in ? ARC_USB_SEND : ARC_USB_RECV) != ARC_USB_STATUS_IDLE)
+   {
+        tr_cntr++;
+       _usb_device_cancel_transfer(mv_dev->mv_usb_handle, mv_ep->num, 
+                           mv_ep->is_in ? ARC_USB_SEND : ARC_USB_RECV);
+    }
+
+    if(tr_cntr > 0)
+    {
+        mvOsPrintf("Cancel ALL transfers: ep=%d-%s, %d transfers\n", 
+                        mv_ep->num, mv_ep->is_in ? "in" : "out", tr_cntr);
+    }
+
+    if(req_cntr > 0)
+    {
+        mvOsPrintf("Cancel ALL Requests: ep=%d-%s, %d requests\n", 
+                        mv_ep->num, mv_ep->is_in ? "in" : "out", req_cntr);
+        _usb_stats(mv_dev->mv_usb_handle);
+    }
+
+}
+
+uint_8 mv_usb_start_ep0(struct mv_usb_dev *mv_dev)
+{
+    DBGMSG("%s: mv_dev=%p, mv_usb_handle=%p, mv_ep=%p\n", 
+           __FUNCTION__, mv_dev, mv_dev->mv_usb_handle, &mv_dev->ep[0]);
+
+    /* Init ep0 IN and OUT */
+    mv_dev->ep[0].is_enabled = 1;
+
+    mv_dev->ep[0].maxpacket = 64;
+    _usb_device_init_endpoint(mv_dev->mv_usb_handle, 0, mv_dev->ep[0].maxpacket, 
+                                ARC_USB_SEND,  ARC_USB_CONTROL_ENDPOINT, 0);
+
+    _usb_device_init_endpoint(mv_dev->mv_usb_handle, 0, mv_dev->ep[0].maxpacket, 
+                                ARC_USB_RECV, ARC_USB_CONTROL_ENDPOINT, 0);
+
+    return USB_OK;
+}
+
+uint_8 mv_usb_reinit (struct mv_usb_dev *usb_dev)
+{
+    int                 i, num;
+    int                 is_in;
+    struct mv_usb_ep    *ep;
+
+    DBGMSG("%s: mv_dev=%p, mv_usb_handle=%p\n", 
+           __FUNCTION__, usb_dev, usb_dev->mv_usb_handle);
+
+    num = 0;
+    for(i=0; i<2*U2O_USED_ENDPOINTS; i++)
+    {
+        is_in = i % 2;
+        ep = &usb_dev->ep[i];
+
+        ep->usb_dev = usb_dev;
+        ep->num = num;
+        ep->is_in = is_in;
+        ep->is_enabled = 0;
+
+        if(is_in)
+            num++;
+    }
+    return USB_OK;
+}
+
+void mv_usb_bus_reset_service(void*      handle, 
+                               uint_8     type, 
+                               boolean    setup,
+                               uint_8     direction, 
+                               uint_8_ptr buffer,
+                               uint_32    length, 
+                               uint_8     error)
+{
+    struct mv_usb_dev       *mv_dev = &the_controller;
+    int                     i, dev_no = _usb_device_get_dev_num(handle);
+    struct mv_usb_ep        *mv_ep;
+
+    if(setup == 0)
+    {
+        /* Stop Hardware and cancel all pending requests */
+        for (i=0; i<2*(U2O_USED_ENDPOINTS); i++)
+        {
+            mv_ep = &mv_dev->ep[i];
+
+            if(mv_ep->is_enabled == 0)
+                continue;
+
+            mv_usb_ep_cancel_all_req(mv_ep);
+        }
+
+       /* Reinit all endpoints */
+        mv_usb_reinit(mv_dev);
+    }
+    else
+    {
+        USB_printf("device start, ep0 start\n");    
+        _usb_device_start(mv_dev->mv_usb_handle);
+        /* Restart Control Endpoint #0 */
+        mv_usb_start_ep0(mv_dev);
+	
+        /* setup the ep0 receive buffer */
+        setup_req.buf = u2o_dma_malloc(mv_dev, sizeof(usb_dev_request_t), 0x20, &i);
+        setup_req.length = sizeof(usb_dev_request_t);
+        mv_usb_ep_queue(&mv_dev->ep[0], &setup_req);
+
+    }
+
+    usb_connected = 0;
+}
+
+
+void mv_usb_speed_service(void*      handle, 
+                           uint_8     type, 
+                           boolean    setup,
+                           uint_8     direction, 
+                           uint_8_ptr buffer,
+                           uint_32    length, 
+                           uint_8     error)
+{
+    int                     dev_no = _usb_device_get_dev_num(handle);
+    struct mv_usb_dev       *mv_dev = &the_controller;
+
+    DBGMSG("Speed = %s\n", (length == ARC_USB_SPEED_HIGH) ? "High" : "Full");
+
+    if(length == ARC_USB_SPEED_HIGH) 
+	usb_speed = USB_SPEED_HIGH;
+    else
+	usb_speed = USB_SPEED_FULL;
+
+    usb_driver_speed(usb_speed);
+
+    return;
+}
+
+void mv_usb_suspend_service(void*      handle, 
+                            uint_8     type, 
+                            boolean    setup,
+                            uint_8     direction, 
+                            uint_8_ptr buffer,
+                            uint_32    length, 
+                            uint_8     error)
+{
+    int                     dev_no = _usb_device_get_dev_num(handle);
+    struct mv_usb_dev       *mv_dev = &the_controller;
+
+}
+
+void mv_usb_resume_service(void*      handle, 
+                            uint_8     type, 
+                            boolean    setup,
+                            uint_8     direction, 
+                            uint_8_ptr buffer,
+                            uint_32    length, 
+                            uint_8     error)
+{
+    int                     dev_no = _usb_device_get_dev_num(handle);
+    struct mv_usb_dev       *mv_dev = &the_controller;
+
+    DBGMSG("%s\n", __FUNCTION__);
+
+    usbctl_next_state_on_event( kEvResume );
+    usb_connected = 0;
+}
+
+void mv_usb_tr_complete_service(void*      handle, 
+                                 uint_8     type, 
+                                 boolean    setup,
+                                 uint_8     direction, 
+                                 uint_8_ptr buffer,
+                                 uint_32    length, 
+                                 uint_8     error)
+{
+    int                     dev_no = _usb_device_get_dev_num(handle);
+    struct mv_usb_dev       *mv_dev = &the_controller;
+    struct mv_usb_ep        *mv_ep;
+    struct usb_request      usb_req;
+    int                     ep_num = (type*2) + direction;
+
+    DBGMSG("%s: ep_num=%d, setup=%s, direction=%s, pBuf=0x%x, length=%d, error=0x%x\n", 
+             __FUNCTION__, ep_num, setup ? "YES" : "NO", 
+             (direction == ARC_USB_RECV) ? "RECV" : "SEND", 
+             (unsigned)buffer, (int)length, error);
+
+    mv_ep = &mv_dev->ep[ep_num];
+
+    usb_req.buf = buffer;
+    usb_req.length = length;
+    
+    if (ep_num == 2)
+        ep2_int_hndlr(&usb_req);
+    else if (ep_num == 3)
+        ep1_int_hndlr(&usb_req);  
+    else
+    	printf("error ep_num %d\n", ep_num);
+}
+
+void mv_usb_ep0_complete_service(void*      handle, 
+                                 uint_8     type, 
+                                 boolean    setup,
+                                 uint_8     direction, 
+                                 uint_8_ptr buffer,
+                                 uint_32    length, 
+                                 uint_8     error)
+{ /* Body */
+    int                     dev_no = _usb_device_get_dev_num(handle);
+    struct mv_usb_dev       *mv_dev = &the_controller;
+    struct mv_usb_ep        *mv_ep;
+    struct usb_request      usb_req;
+    int                     rc;
+    boolean                 is_delegate = FALSE;
+    static SETUP_STRUCT     mv_ctrl_req;
+   
+    DBGMSG("%s: EP0(%d), setup=%s, direction=%s, pBuf=0x%x, length=%d, error=0x%x\n", 
+                __FUNCTION__, type, setup ? "YES" : "NO", 
+                (direction == ARC_USB_RECV) ? "RECV" : "SEND", 
+                (unsigned)buffer, (int)length, error);
+
+    mv_ep = &mv_dev->ep[type];
+
+    if (setup) 
+    {
+        _usb_device_read_setup_data(handle, type, (u8 *)&mv_ctrl_req);
+
+        while(_usb_device_get_transfer_status(handle, mv_ep->num, 
+                ARC_USB_SEND) != ARC_USB_STATUS_IDLE)
+        {
+            _usb_device_cancel_transfer(mv_dev->mv_usb_handle, mv_ep->num, 
+                           ARC_USB_SEND);
+        }
+        while(_usb_device_get_transfer_status(handle, mv_ep->num, 
+                ARC_USB_RECV) != ARC_USB_STATUS_IDLE)
+        {
+            _usb_device_cancel_transfer(mv_dev->mv_usb_handle, mv_ep->num, 
+                           ARC_USB_RECV);
+        }
+	usb_req.buf = &mv_ctrl_req;
+	usb_req.length = sizeof(mv_ctrl_req);
+    }
+    /* Setup request direction */
+    mv_ep->is_in = (mv_ctrl_req.REQUESTTYPE & REQ_DIR_IN) != 0;     
+
+    if(setup)
+        DBGMSG("*** Setup ***: dir=%s, reqType=0x%x, req=0x%x, value=0x%02x, index=0x%02x, length=0x%02x\n", 
+                (direction == ARC_USB_SEND) ? "In" : "Out",
+                mv_ctrl_req.REQUESTTYPE, mv_ctrl_req.REQUEST, mv_ctrl_req.VALUE,
+                mv_ctrl_req.INDEX, mv_ctrl_req.LENGTH); 
+
+    /* Handle most lowlevel requests;
+     * everything else goes uplevel to the gadget code.
+     */
+    if( (mv_ctrl_req.REQUESTTYPE & REQ_TYPE_MASK) == REQ_TYPE_STANDARD)
+    {
+        switch (mv_ctrl_req.REQUEST) 
+        {
+            case REQ_GET_STATUS: 
+                mvUsbCh9GetStatus(handle, setup, &mv_ctrl_req);
+                break;
+
+            case REQ_CLEAR_FEATURE:
+                mvUsbCh9ClearFeature(handle, setup, &mv_ctrl_req);
+                break;
+
+            case REQ_SET_FEATURE:
+                mvUsbCh9SetFeature(handle, setup, &mv_ctrl_req);
+                break;
+
+            case REQ_SET_ADDRESS:
+                mvUsbCh9SetAddress(handle, setup, &mv_ctrl_req);
+                break;
+
+            case REQ_SET_CONFIGURATION:
+		if (setup) {
+			extern void ep2_begin();
+			desc_t * pdesc = pxa_usb_get_descriptor_ptr();
+		        config_desc_t *cfg;
+		        intf_desc_t *intf;
+		        ep_desc_t *ep;
+		
+		        cfg = (config_desc_t*) (pdesc->cdb);
+		        intf = (config_desc_t *)(cfg + 1);
+		        ep = (ep_desc_t *) (intf + 1);
+
+			USB_printf("\t\tSET_CONFIGURATION\n");
+			mvUsbCh9SetConfig(handle, setup, &mv_ctrl_req);
+			usbctl_next_state_on_event(kEvReset);
+			usbctl_next_state_on_event(kEvConfig);
+			mv_usb_ep_enable(&mv_dev->ep[2], &ep[1]);
+			mv_usb_ep_enable(&mv_dev->ep[3], &ep[0]);
+			usb_connected = 1;
+			ep2_begin();
+		}
+		break;
+
+            case REQ_SET_INTERFACE:
+		if (setup) {
+			USB_printf("\t\tSET_INTERFACE\n");
+			/* ack */
+      			_usb_device_send_data(handle, 0, 0, 0);
+		}
+		break;
+
+            default:
+                /* All others delegate call up-layer gadget code */
+                is_delegate = TRUE;
+        }
+    }
+    else
+        is_delegate = TRUE;
+
+    /* delegate call up-layer gadget code */
+    if(is_delegate)
+    {
+        if(setup)
+        {
+	    mv_ep->ack_recv = 0;
+	    mv_ep->ack_sent = 0;
+    
+	    rc = ep0_int_hndlr(&usb_req);	
+            if(rc < 0)
+            {
+                mvOsPrintf("Setup is failed: rc=%d, req=0x%02x, reqType=0x%x, value=0x%04x, index=0x%04x\n", 
+                    rc, mv_ctrl_req.REQUEST, mv_ctrl_req.REQUESTTYPE, 
+                    mv_ctrl_req.VALUE, mv_ctrl_req.INDEX);
+                _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                return;
+            }
+            /* Acknowledge  */
+            if( mv_ep->is_in ) {
+		mv_ep->ack_recv = 1;
+                _usb_device_recv_data(handle, 0, NULL, 0);
+            } 
+            else if( mv_ctrl_req.LENGTH ) {
+		mv_ep->ack_sent = 1;
+                _usb_device_send_data(handle, 0, NULL, 0);
+            }
+        }
+    }
+
+    if(!setup)
+    {
+	int is_ack = 0;
+	if( mv_ep->ack_sent && (direction == ARC_USB_SEND) ) {
+		mv_ep->ack_sent = 0;
+		is_ack = 1;
+	}
+	if( mv_ep->ack_recv && (direction != ARC_USB_SEND) ) {
+		mv_ep->ack_recv = 0;
+		is_ack = 1;
+	}
+
+        //usb_req->complete (&mv_ep->ep, usb_req);
+        DBGMSG("Setup complete: dir=%s, is_in=%d, length=%d, is_ack=%d\n", 
+                (direction == ARC_USB_SEND) ? "In" : "Out",
+                mv_ep->is_in, length, is_ack);
+    }
+}
+
+int      mv_usb_ep_queue (struct mv_usb_ep *usb_ep, struct usb_request *_req) 
+{
+    struct mv_usb_dev* usb_dev =  &the_controller;
+    unsigned long       flags = 0;
+    uint_8              error;
+
+    DBGMSG("%s: num=%d-%s, _req=%p, buf=%p, length=%d is_enabled %d\n", 
+                __FUNCTION__, usb_ep->num, usb_ep->is_in ? "in" : "out", 
+                _req, _req->buf, _req->length, usb_ep->is_enabled);
+
+    /* Add request to list */
+    if( ((usb_ep->num == 0) && (_req->length == 0)) || (usb_ep->is_in) )
+    {
+        int     send_size, size;
+        uint_8  *send_ptr, *buf_ptr;
+
+        send_ptr = buf_ptr = _req->buf;
+        send_size = size = _req->length;
+
+        error = _usb_device_send_data(usb_dev->mv_usb_handle, usb_ep->num, send_ptr, send_size);
+        if(error != USB_OK)
+        {
+            printf("ep_queue: Can't SEND data (err=%d): ep_num=%d, pBuf=0x%x, send_size=%d\n",
+                    error, usb_ep->num, (unsigned)_req->buf, _req->length);
+        }
+
+        size -= send_size;
+        buf_ptr += send_size;
+    }
+    else
+    {
+        error = _usb_device_recv_data(usb_dev->mv_usb_handle, usb_ep->num, _req->buf, _req->length);
+        if(error != USB_OK)
+        {
+            printf("mv_usb_ep_queue: Can't RCV data (err=%d): ep_num=%d, pBuf=0x%x, size=%d\n",
+                        error, usb_ep->num, (unsigned)_req->buf, _req->length);
+        }
+    }
+
+    return (int)error;
+}
+
+int  mv_usb_ep_enable(struct mv_usb_ep *usb_ep, ep_desc_t *ep_desc)
+{
+    struct mv_usb_dev* usb_dev = &the_controller;
+    __u16             maxSize;
+    uint_8              epType; 
+    unsigned long       flags = 0;
+
+    if(usb_ep->is_enabled)
+    {
+        mvOsPrintf("mv_usb: %d%s Endpoint is already in use\n", 
+                    usb_ep->num, usb_ep->is_in ? "In" : "Out");
+        return -EINVAL;
+    }
+
+    if(usb_ep->num == 0)
+    {
+        mvOsPrintf("mv_usb: ep0 is reserved\n");
+        return -EINVAL;
+    }
+
+    /* Max packet size */
+    maxSize = ep_desc->wMaxPacketSize;
+
+    epType = (uint_8)ARC_USB_BULK_ENDPOINT;
+    usb_ep->is_enabled = 1;
+
+    mvOsPrintf("Enable EP: ep=%d-%s maxSize %d type %d\n", usb_ep->num, 
+	usb_ep->is_in ? "in" : "out", maxSize, epType);
+
+    _usb_device_init_endpoint(usb_dev->mv_usb_handle, usb_ep->num, maxSize, 
+            usb_ep->is_in ? ARC_USB_SEND : ARC_USB_RECV, epType,
+            (epType == ARC_USB_BULK_ENDPOINT) ? ARC_USB_DEVICE_DONT_ZERO_TERMINATE : 0);
+
+    return 0;
+}
+
+
+USB_IMPORT_FUNCS    usbImportFuncs =
+{
+#ifdef DEBUG
+//	.bspPrintf =            mvOsPrintf,
+#endif
+	.bspSprintf =           NULL, 
+	.bspUncachedMalloc = 	u2o_dma_malloc,
+	.bspUncachedFree = 	u2o_dma_free,
+	.bspMalloc =            u2o_malloc,
+	.bspFree =              u2o_free,
+	.bspMemset =            memset,
+	.bspMemcpy =            memcpy,
+	.bspCacheFlush = 	u2o_cache_flush,
+	.bspCacheInv =		u2o_cache_invalidate,
+	.bspVirtToPhys =	u2o_virt_to_phys,
+	.bspLock =              NULL,
+	.bspUnlock =            NULL,
+	.bspGetCapRegAddr =     u2o_get_caps_addr,
+	.bspResetComplete =     u2o_reset_complete
+};
+
+void mv_usb_dump(void)
+{
+    	struct mv_usb_dev* mv_dev =  &the_controller;
+	
+        _usb_regs(mv_dev->mv_usb_handle);
+        _usb_status(mv_dev->mv_usb_handle);
+        _usb_debug_print_trace_log();
+
+	_usb_ep_status(mv_dev->mv_usb_handle, 0, ARC_USB_RECV);
+	_usb_ep_status(mv_dev->mv_usb_handle, 0, ARC_USB_SEND);
+
+	_usb_ep_status(mv_dev->mv_usb_handle, 1, ARC_USB_RECV);
+	_usb_ep_status(mv_dev->mv_usb_handle, 1, ARC_USB_SEND);
+}
diff --git a/board/pxa/common/usbeth/mv_u2o_api.h b/board/pxa/common/usbeth/mv_u2o_api.h
new file mode 100644
index 0000000..c69d29e
--- /dev/null
+++ b/board/pxa/common/usbeth/mv_u2o_api.h
@@ -0,0 +1,49 @@
+
+#include "mv_u2o_ctl.h"
+#include "mvUsbCh9.h"
+#include "mvUsbDevApi.h"
+
+//#define DEBUG
+
+#ifdef DEBUG
+//#define mvOsPrintf(fmt,args...)	 printf( fmt, ## args)
+#define mvOsPrintf	printf
+#else
+#define mvOsPrintf
+#endif
+
+
+#if 0
+#define __raw_readl(addr) 	(*(volatile u32 *) (addr))
+#define readl(addr) 		(*(volatile u32 *) (addr))
+#define writel(b, addr)		((*(volatile u32 *) (addr)) = (b))
+#endif
+
+extern unsigned u2o_get(unsigned *base, unsigned offset);
+extern void u2o_set(unsigned *base, unsigned offset, unsigned value);
+extern void u2o_clear(unsigned *base, unsigned offset, unsigned value);
+extern void u2o_write(unsigned *base, unsigned offset, unsigned value);
+
+extern void mv_usb_dump(void);
+
+extern uint_8 mv_usb_start_ep0(struct mv_usb_dev *mv_dev);
+
+extern int mv_usb_ep_queue (struct mv_usb_ep *usb_ep, struct usb_request *_req); 
+
+extern void mv_usb_bus_reset_service(void *handle, uint_8 type, boolean setup,
+	uint_8 direction, uint_8_ptr buffer, uint_32 length, uint_8 error);
+
+extern void mv_usb_speed_service(void *handle, uint_8 type, boolean setup,
+	uint_8 direction, uint_8_ptr buffer, uint_32 length, uint_8 error);
+
+extern void mv_usb_suspend_service(void *handle, uint_8 type, boolean setup,
+	uint_8 direction, uint_8_ptr buffer, uint_32 length, uint_8 error);
+
+extern void mv_usb_resume_service(void *handle, uint_8 type, boolean setup,
+	uint_8 direction, uint_8_ptr buffer, uint_32 length, uint_8 error);
+
+extern void mv_usb_ep0_complete_service(void *handle, uint_8 type, boolean setup,
+	uint_8 direction, uint_8_ptr buffer, uint_32 length, uint_8 error);
+
+extern void mv_usb_tr_complete_service(void *handle, uint_8 type, boolean setup,
+	uint_8 direction, uint_8_ptr buffer, uint_32 length, uint_8 error);
diff --git a/board/pxa/common/usbeth/mv_u2o_ctl.c b/board/pxa/common/usbeth/mv_u2o_ctl.c
new file mode 100644
index 0000000..26063d6
--- /dev/null
+++ b/board/pxa/common/usbeth/mv_u2o_ctl.c
@@ -0,0 +1,746 @@
+/*
+ *  Copyright (C) Compaq Computer Corporation, 1998, 1999
+ *  Copyright (C) Extenex Corporation, 2001
+ *  Copyright (C) Intrinsyc, Inc., 2002
+ *
+ * (C) Copyright 2006 Marvell International Ltd.  
+ * All Rights Reserved 
+ *
+ *  PXA USB controller core driver.
+ *
+ *  This file provides interrupt routing and overall coordination
+ *  of the endpoints.
+ *
+ *  Please see:
+ *    linux/Documentation/arm/SA1100/SA1100_USB 
+ *  for more info.
+ *
+ *  02-May-2002
+ *   Frank Becker (Intrinsyc) - derived from sa1100 usb_ctl.c
+ *
+ */
+
+#include <common.h>
+
+#include <linux/types.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <common.h>
+#include <config.h>
+#include <net.h>
+#include <command.h>
+#include <malloc.h>
+
+#include "pxa_usb.h"
+#include "mv_u2o_api.h"
+#include "mv_u2o_ctl.h"
+#include "mvUsbCh9.h"
+#include "mvUsbDevApi.h"
+#include <asm/arch/common.h>
+
+#ifdef TAVOR_EVB2
+#include "arch/tavor_evb2.h"
+#endif
+
+#undef DEBUG 
+//#define DEBUG 3
+#if DEBUG
+static unsigned int usb_debug = DEBUG;
+#else
+#define usb_debug 0     /* gcc will remove all the debug code for us */
+#endif
+
+static int u2o_info();
+
+struct mv_usb_dev       the_controller;
+
+extern USB_IMPORT_FUNCS    usbImportFuncs;
+void usb_driver_reset(void);
+
+//////////////////////////////////////////////////////////////////////////////
+// Prototypes
+//////////////////////////////////////////////////////////////////////////////
+
+int usbctl_next_state_on_event( int event );
+void udc_int_hndlr(int, void *);
+static void initialize_descriptors( void );
+static void soft_connect_hook( int enable );
+static void u2o_phy_init(unsigned *base);
+static void u2o_disable(void);
+static int u2o_enable(void);
+
+int * ep0_send_buf;
+int * ep1_buf;
+int * ep2_buf;
+
+/////////////////////////////////////////////////////////////////////////////
+int usb_connected = 0;
+int usb_set_conf = 0;
+int usb_set_intf = 0;
+int usb_speed = USB_SPEED_FULL;
+
+
+//////////////////////////////////////////////////////////////////////////////
+// Globals
+//////////////////////////////////////////////////////////////////////////////
+static const char pszMe[] = "usbctl: ";
+struct usb_info_t usbd_info;  /* global to ep0, usb_recv, usb_send */
+
+/* device descriptors */
+static desc_t desc;
+
+#define MAX_STRING_DESC 16
+static string_desc_t * string_desc_array[ MAX_STRING_DESC ];
+static string_desc_t sd_zero;  /* special sd_zero holds language codes */
+
+// called when configured
+static usb_notify_t configured_callback = NULL;
+
+enum {
+    kStateZombie		= 0,
+    kStateZombieSuspend		= 1,
+    kStateDefault		= 2,
+    kStateDefaultSuspend	= 3,
+    kStateAddr			= 4,
+    kStateAddrSuspend		= 5,
+    kStateConfig		= 6,
+    kStateConfigSuspend		= 7
+};
+
+/*
+ * FIXME: The PXA UDC handles several host device requests without user 
+ * notification/intervention. The table could be collapsed quite a bit...
+ */
+static int device_state_machine[8][6] = {
+//              suspend               reset          resume         adddr       config        deconfig
+/* zombie */  { kStateZombieSuspend , kStateDefault, kStateZombie , kError    , kError      , kError },
+/* zom sus */ { kStateZombieSuspend , kStateDefault, kStateZombie , kError    , kError      , kError },
+/* default */ { kStateDefaultSuspend, kStateDefault, kStateDefault, kStateAddr, kStateConfig, kError },
+/* def sus */ { kStateDefaultSuspend, kStateDefault, kStateDefault, kError    , kError      , kError },
+/* addr */    { kStateAddrSuspend   , kStateDefault, kStateAddr   , kError    , kStateConfig, kError },
+/* addr sus */{ kStateAddrSuspend   , kStateDefault, kStateAddr   , kError    , kError      , kError },
+/* config */  { kStateConfigSuspend , kStateDefault, kStateConfig , kError    , kError      , kStateDefault },
+/* cfg sus */ { kStateConfigSuspend , kStateDefault, kStateConfig , kError    , kError      , kError }
+};
+
+/* "device state" is the usb device framework state, as opposed to the
+   "state machine state" which is whatever the driver needs and is much
+   more fine grained
+*/
+static int sm_state_to_device_state[8] = { 
+//  zombie            zom suspend       
+USB_STATE_POWERED, USB_STATE_SUSPENDED, 
+//  default           default sus
+USB_STATE_DEFAULT, USB_STATE_SUSPENDED,
+//  addr              addr sus         
+USB_STATE_ADDRESS, USB_STATE_SUSPENDED, 
+//  config            config sus
+USB_STATE_CONFIGURED, USB_STATE_SUSPENDED
+};
+
+static char * state_names[8] =
+{ "zombie", "zombie suspended", 
+  "default", "default suspended",
+  "address", "address suspended", 
+  "configured", "config suspended"
+};
+
+static char * event_names[6] =
+{ "suspend", "reset", "resume",
+  "address assigned", "configure", "de-configure"
+};
+
+static char * device_state_names[] =
+{ "not attached", "attached", "powered", "default",
+  "address", "configured", "suspended" };
+
+static int sm_state = kStateZombie;
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+// Async
+//////////////////////////////////////////////////////////////////////////////
+
+/* The UDCCR reg contains mask and interrupt status bits,
+ * so using '|=' isn't safe as it may ack an interrupt.
+ */
+
+void
+u2o_int_hndlr(int irq, void *dev_id)
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+
+	/*if (usb_debug) printf("%s U2xSTS=%08x\n",
+		pszMe, u2o_get(mv_dev->regbase, U2xUSBSTS));*/
+
+	/* handle ARC USB Device interrupts */
+    	_usb_dci_vusb20_isr(mv_dev->mv_usb_handle);
+
+}
+
+/*****************************************************************************
+ * The registers read/write routines
+ *****************************************************************************/
+unsigned u2o_get(unsigned *base, unsigned offset)
+{
+	return readl(base + (offset>>2));
+}
+
+void u2o_set(unsigned *base, unsigned offset, unsigned value)
+{
+	volatile unsigned int reg;
+
+	if (usb_debug)
+		printf("base %p off %x base+off %p read %x\n", base, offset,
+			(base + (offset>>2)), *(unsigned *)(base + (offset>>2)));
+	reg = readl(base + (offset>>2));
+	reg |= value;
+	writel(reg, base + (offset>>2));
+	readl(base + (offset>>2));
+}
+
+void u2o_clear(unsigned *base, unsigned offset, unsigned value)
+{
+	volatile unsigned int reg;
+
+	reg = readl(base + (offset>>2));
+	reg &= ~value;
+	writel(reg, base + (offset>>2));
+	readl(base + (offset>>2));
+}
+
+void u2o_write(unsigned *base, unsigned offset, unsigned value)
+{
+	writel(value, base + (offset>>2));
+	readl(base + (offset>>2));
+}
+
+static void u2o_phy_dump(unsigned *base)
+{
+#if 0
+	printf(" U2PPLL   0x%x\n", u2o_get(base,  U2PCTL )); 
+	printf(" U2PTX    0x%x\n", u2o_get(base,  U2PTX  ));
+	printf(" U2PRX    0x%x\n", u2o_get(base,  U2PRX  ));
+	printf(" U2IVREF  0x%x\n", u2o_get(base,  U2IVREF));  
+	printf(" U2PT0    0x%x\n", u2o_get(base,  U2PT0  ));
+	printf(" U2PT1    0x%x\n", u2o_get(base,  U2PT1  ));
+	printf(" U2PT2    0x%x\n", u2o_get(base,  U2PT2  ));  
+	printf(" U2PT3    0x%x\n", u2o_get(base,  U2PT3  ));	
+	printf(" U2PT4    0x%x\n", u2o_get(base,  U2PT4  ));  
+	printf(" U2PT5    0x%x\n", u2o_get(base,  U2PT5  ));	
+	printf(" U2PID    0x%x\n", u2o_get(base,  U2PID  ));	
+	printf(" U2PRS    0x%x\n", u2o_get(base,  U2PRS  ));	
+	printf(" U2PMN    0x%x\n", u2o_get(base,  U2PMN  ));	
+	printf(" U2OCG    0x%x\n", u2o_get(base,  U2OCG  ));	
+#endif
+}
+
+static void u2o_phy_init(unsigned *base)
+{
+	int count;
+
+	if (usb_debug)
+		printf("init phy\n\n");
+
+#if 0
+        /* Initialize the USB PHY */
+        u2o_set(base, U2PCTRL, 0x3); // enable PU_PLL & PU
+        u2o_clear(base, U2PT0, 0x8000); // disable FIFO_SQ_RST
+        u2o_write(base, U2PPLL, 0xabc26eeb); // setup parameters
+        u2o_set(base, U2PTX, 0x80000);
+        u2o_write(base, U2PRX, 0x631c82a3);
+        u2o_write(base, U2PIVREF, 0x0000043a);
+        printf("%s: ctrl %x t0 %x pll %x tx %x rx %x ivref %x\n", __func__,
+                u2o_get(base, U2PCTRL), u2o_get(base, U2PT0), u2o_get(base, U2PPLL),
+                u2o_get(base, U2PTX), u2o_get(base, U2PRX), u2o_get(base, U2PIVREF));
+#else
+	u2o_set(base, U2PCTRL, 1<<UTMI_CTRL_INPKT_DELAY_SOF_SHIFT);
+	u2o_set(base, U2PCTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);
+	udelay(1000);
+	u2o_set(base, U2PCTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);
+
+	/* aspen specific*/
+	if (cpu_is_pxa910_168())
+		u2o_write(base, 0x3C, 1);  /* Turn on UTMI PHY OTG extension */
+
+	u2o_clear(base, U2PPLL, UTMI_PLL_FBDIV_MASK | UTMI_PLL_REFDIV_MASK);
+	u2o_set(base, U2PPLL, 0xee<<UTMI_PLL_FBDIV_SHIFT | 0xb<<UTMI_PLL_REFDIV_SHIFT);
+	u2o_set(base, U2PTX, 0x80000);
+
+	/* calibrate */
+	while((u2o_get(base, U2PPLL) & PLL_READY) == 0);
+
+	/* toggle VCOCAL_START bit of U2PPLL */
+	udelay(200);
+	u2o_set(base, U2PPLL, VCOCAL_START);
+	udelay(40);
+	u2o_clear(base, U2PPLL, VCOCAL_START);
+
+	/* toggle REG_RCAL_START bit of U2PTX */
+	udelay(200);
+	u2o_set(base, U2PTX, REG_RCAL_START);
+	udelay(400);
+	u2o_clear(base, U2PTX, REG_RCAL_START);
+
+	/* make sure phy is ready */
+	while((u2o_get(base, U2PPLL) & PLL_READY) == 0);
+#endif
+
+	if (usb_debug) u2o_phy_dump(base);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+// Public Interface
+//////////////////////////////////////////////////////////////////////////////
+
+/* Open PXA usb core on behalf of a client, but don't start running */
+
+int
+pxa_usb_open( const char * client )
+{
+	if (usb_debug) printf( "pxa_usb_open\n");
+	usbd_info.client_name = (char*) client;
+	memset(&usbd_info.stats, 0, sizeof(struct usb_stats_t));
+	memset(string_desc_array, 0, sizeof(string_desc_array));
+
+	/* hack to start in zombie suspended state */
+	sm_state = kStateZombieSuspend;
+	usbd_info.state = USB_STATE_SUSPENDED;
+
+	/* create descriptors for enumeration */
+	initialize_descriptors();
+
+	ep1_init(0);
+	if (usb_debug) printf( "%s%s registered.\n", pszMe, client );
+	return 0;
+}
+
+/* Start running. Must have called usb_open (above) first */
+int
+pxa_usb_start( void )
+{
+	if (usb_debug) printf( "pxa_usb_start\n");
+
+	if ( usbd_info.client_name == NULL ) {
+		printf( "%s%s - no client registered\n",
+				pszMe, __FUNCTION__ );
+		return -EPERM;
+	}
+
+	if (usb_debug) u2o_info();
+
+	if (usb_debug) printf( "%sStarted %s\n", pszMe, usbd_info.client_name );
+	return 0;
+}
+
+/* Stop USB core from running */
+int
+pxa_usb_stop( void )
+{
+	if ( usbd_info.client_name == NULL ) {
+		printf( "%s%s - no client registered\n",
+				pszMe, __FUNCTION__ );
+		return -EPERM;
+	}
+
+	ep1_reset();
+	ep2_reset();
+
+	u2o_disable();
+	if( usb_debug) printf( "%sStopped %s\n", pszMe, usbd_info.client_name );
+	return 0;
+}
+
+/* Tell PXA core client is through using it */
+int
+pxa_usb_close( void )
+{
+	 if ( usbd_info.client_name == NULL ) {
+		   printf( "%s%s - no client registered\n",
+				  pszMe, __FUNCTION__ );
+		  return -EPERM;
+	 }
+	 printf( "%s%s closed.\n", pszMe, (char*)usbd_info.client_name );
+	 usbd_info.client_name = NULL;
+	 return 0;
+}
+
+/* set a proc to be called when device is configured */
+usb_notify_t pxa_set_configured_callback( usb_notify_t func )
+{
+	 usb_notify_t retval = configured_callback;
+	 configured_callback = func;
+	 return retval;
+}
+
+/*====================================================
+ * Descriptor Manipulation.
+ * Use these between open() and start() above to setup
+ * the descriptors for your device.
+ *
+ */
+
+/* get pointer to static default descriptor */
+desc_t *
+pxa_usb_get_descriptor_ptr( void ) { return &desc; }
+
+/* optional: set a string descriptor */
+int
+pxa_usb_set_string_descriptor( int i, string_desc_t * p )
+{
+	 int retval;
+	 if ( i < MAX_STRING_DESC ) {
+		  string_desc_array[i] = p;
+		  retval = 0;
+	 } else {
+		  retval = -EINVAL;
+	 }
+	 return retval;
+}
+
+/* optional: get a previously set string descriptor */
+string_desc_t *
+pxa_usb_get_string_descriptor( int i )
+{
+	 return ( i < MAX_STRING_DESC )
+		    ? string_desc_array[i]
+		    : NULL;
+}
+
+config_desc_t *
+pxa_usb_get_config(int cfgval) 
+{
+	int i;
+	desc_t * pdesc = pxa_usb_get_descriptor_ptr();
+	config_desc_t *cfg = (config_desc_t*) (pdesc->cdb);
+
+	for( i=0; i<pdesc->dev.bNumConfigurations; i++) {
+		if( cfg->bConfigurationValue == cfgval ) return cfg;
+		cfg = (config_desc_t*) ((unsigned char*)cfg + cfg->wTotalLength);
+	}
+
+	return NULL;
+}
+
+intf_desc_t *
+pxa_usb_get_interface( config_desc_t *cfg, int idx)
+{
+	int i;
+	intf_desc_t *intf = (intf_desc_t*) (cfg + 1);
+	
+	for( i=0; i < cfg->bNumInterfaces; i++) {
+		if( idx == intf->bInterfaceNumber) return intf;
+		intf++;
+	}
+
+	return NULL;
+}
+
+
+ep_desc_t *
+pxa_usb_get_endpoint( intf_desc_t *intf, int idx)
+{
+	int i;
+	ep_desc_t *ep = (ep_desc_t *) (intf+1);
+
+
+	for( i=0; i< intf->bNumEndpoints; i++) {
+		if( idx == (ep->bEndpointAddress & 0xF) ) return ep;
+		ep++;
+	}
+	return NULL;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+// Exports to rest of driver
+//////////////////////////////////////////////////////////////////////////////
+
+/* called by the int handler here and the two endpoint files when interesting
+   .."events" happen */
+
+int
+usbctl_next_state_on_event( int event )
+{
+	int next_state = device_state_machine[ sm_state ][ event ];
+	if ( next_state != kError )
+	{
+		int next_device_state = sm_state_to_device_state[ next_state ];
+		if (usb_debug) printf( "%s%s --> [%s] --> %s. Device in %s state.\n",
+				pszMe, state_names[ sm_state ], event_names[ event ],
+				state_names[ next_state ], device_state_names[ next_device_state ] );
+
+		sm_state = next_state;
+		if ( usbd_info.state != next_device_state )
+		{
+			if ( configured_callback != NULL
+				 &&
+				 next_device_state == USB_STATE_CONFIGURED
+				 &&
+				 usbd_info.state != USB_STATE_SUSPENDED
+			   ) {
+			  configured_callback();
+			}
+			usbd_info.state = next_device_state;
+
+			ep1_state_change_notify( next_device_state );
+			ep2_state_change_notify( next_device_state );
+		}
+	}
+	else
+		printf( "%s%s --> [%s] --> ??? is an error.\n",
+				pszMe, state_names[ sm_state ], event_names[ event ] );
+	return next_state;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+// Private Helpers
+//////////////////////////////////////////////////////////////////////////////
+
+/* setup default descriptors */
+
+static void
+initialize_descriptors(void)
+{
+
+	desc.dev.bLength               = sizeof( device_desc_t );
+	desc.dev.bDescriptorType       = USB_DESC_DEVICE;
+	desc.dev.bcdUSB                = 0x100; /* 1.0 */	// HS 0x200 ?????
+	desc.dev.bDeviceClass          = 0xFF;	/* vendor specific */
+	desc.dev.bDeviceSubClass       = 0;
+	desc.dev.bDeviceProtocol       = 0;
+	desc.dev.bMaxPacketSize0       = 64;	/* ep0 max fifo size, 16 orig ????? */
+	desc.dev.idVendor              = 0;	/* vendor ID undefined */
+	desc.dev.idProduct             = 0; 	/* product */
+	desc.dev.bcdDevice             = 0; 	/* vendor assigned device release num */
+	desc.dev.iManufacturer         = 0;	/* index of manufacturer string */
+	desc.dev.iProduct              = 0; 	/* index of product description string */
+	desc.dev.iSerialNumber         = 0;	/* index of string holding product s/n */
+	desc.dev.bNumConfigurations    = 1;	/* configurations we have */
+
+	desc.qua.bLength               = sizeof( qua_desc_t );
+	desc.qua.bDescriptorType       = USB_DESC_QUALIFIER;
+	desc.qua.bcdUSB                = 0x0200;
+	desc.qua.bDeviceClass          = 0xFF;	/* vendor specific */
+	desc.qua.bDeviceSubClass       = 0;
+	desc.qua.bDeviceProtocol       = 0;
+	desc.qua.bMaxPacketSize0       = 64;	/* ep0 max fifo size, 16 or 64 ????? */
+	desc.qua.bNumConfigurations    = 1;
+	desc.qua.bRESERVED             = 0;
+
+// FIXME: Add support for all endpoint...
+	usb_driver_reset();
+
+	/* set language */
+	/* See: http://www.usb.org/developers/data/USB_LANGIDs.pdf */
+	sd_zero.bDescriptorType = USB_DESC_STRING;
+	sd_zero.bLength         = sizeof( string_desc_t );
+	sd_zero.bString[0]      = make_word_c( 0x409 ); /* American English */
+	pxa_usb_set_string_descriptor( 0, &sd_zero );
+}
+
+/* soft_connect_hook()
+ * Some devices have platform-specific circuitry to make USB
+ * not seem to be plugged in, even when it is. This allows
+ * software to control when a device 'appears' on the USB bus
+ * (after Linux has booted and this driver has loaded, for
+ * example). If you have such a circuit, control it here.
+ */
+static void
+soft_connect_hook( int enable )
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+	if (enable) {
+		_usb_device_start(mv_dev->mv_usb_handle);
+	} else {
+		_usb_device_stop(mv_dev->mv_usb_handle);
+	}
+}
+
+/* disable the UDC at the source */
+static void
+u2o_disable(void)
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+	int i;
+	soft_connect_hook( 0 );
+
+	if (usb_debug)
+		printf("%s\n\n", __func__);
+	for (i=0; i<ARC_USB_MAX_ENDPOINTS; i++)
+        	_usb_device_unregister_service(mv_dev->mv_usb_handle, i);
+
+	/* Deregister all other services */
+	_usb_device_unregister_service(mv_dev->mv_usb_handle, ARC_USB_SERVICE_BUS_RESET);
+	_usb_device_unregister_service(mv_dev->mv_usb_handle, ARC_USB_SERVICE_SPEED_DETECTION);
+	
+	_usb_device_unregister_service(mv_dev->mv_usb_handle, ARC_USB_SERVICE_SUSPEND);
+
+	_usb_device_shutdown(mv_dev->mv_usb_handle);
+    	/* Disable clock for USB device */
+	writel(0x0, PMUA_USB_CLK_RES_CTRL);
+}
+
+/*-------------------------------------------------------------------------*/
+static void u2o_soft_dis(int enable)
+{
+	if (usb_debug)
+		printf("%s enable %d\n\n", __func__, enable);
+}
+
+/* CHIP ID: 
+ * 	Z0: 0x00a0c910
+ * 	Y0: 0x00f0c910
+ */
+#define CHIP_ID    0xd4282c00
+int pxa910_is_z0(void)
+{
+	if ((readl(CHIP_ID) & 0x00f00000) == 0x00a00000)
+		return 1;
+
+	return 0;
+}
+
+
+/*  enable the udc at the source */
+int u2o_enable(void)
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+	int error, retval, i;
+	u32 tmp;
+
+    	/* enable u2o clock */
+	writel(0x18, PMUA_USB_CLK_RES_CTRL);
+	writel(0x1b, PMUA_USB_CLK_RES_CTRL);
+
+	/* enable the pull up */
+	if (!cpu_is_pxa910_168()) {
+		if (pxa910_is_z0()) {
+	        	writel((1<<20), (0xc0000004));
+		} else {
+			tmp = readl(0xd4207004);
+			tmp |= (1<<20);
+	        	writel(tmp, (0xd4207004));
+		}
+	}
+
+	mv_dev->regbase = (unsigned *)U2O_REG_BASE; 
+	mv_dev->phybase = (unsigned *)U2O_PHY_BASE;
+	if (usb_debug)
+		printf("%s PMUA_USB_CLK_RES_CTRL 0x%x regbase %x phybase %x\n", __func__, 
+		  __raw_readl(PMUA_USB_CLK_RES_CTRL), mv_dev->regbase, mv_dev->phybase);
+	/* init the UTMI transceiver */
+	u2o_phy_init(mv_dev->phybase);
+
+	mv_dev->dev_no = 0;
+
+	/* register bsp functions */
+    	_usb_device_set_bsp_funcs(&usbImportFuncs);
+
+	/* Enable ARC USB device */
+	retval = (int)_usb_device_init(mv_dev->dev_no, &mv_dev->mv_usb_handle);
+	if (retval != USB_OK) 
+	{
+	    mvOsPrintf("\nUSB Initialization failed. Error: %x", retval);
+	    return -EINVAL;
+	} /* Endif */
+	
+	/* Self Power, Remote wakeup disable */
+	_usb_device_set_status(mv_dev->mv_usb_handle, ARC_USB_STATUS_DEVICE, (1 << DEVICE_SELF_POWERED));
+	
+	/* Register all ARC Services */  
+	error = _usb_device_register_service(mv_dev->mv_usb_handle, 
+	                            ARC_USB_SERVICE_BUS_RESET, mv_usb_bus_reset_service);
+	if (error != USB_OK) 
+	{
+	    mvOsPrintf("\nUSB BUS_RESET Service Registration failed. Error: 0x%x", error);
+	    return -EINVAL;
+	} /* Endif */
+	
+	error = _usb_device_register_service(mv_dev->mv_usb_handle, 
+	                    ARC_USB_SERVICE_SPEED_DETECTION, mv_usb_speed_service);
+	if (error != USB_OK) 
+	{
+	    mvOsPrintf("\nUSB SPEED_DETECTION Service Registration failed. Error: 0x%x", 
+	                    error);
+	    return -EINVAL;
+	} /* Endif */
+	     
+	error = _usb_device_register_service(mv_dev->mv_usb_handle, 
+	                            ARC_USB_SERVICE_SUSPEND, mv_usb_suspend_service);
+	if (error != USB_OK) 
+	{
+	    mvOsPrintf("\nUSB SUSPEND Service Registration failed. Error: 0x%x", error);
+	    return -EINVAL;
+	} /* Endif */
+	
+	error = _usb_device_register_service(mv_dev->mv_usb_handle, 
+	              ARC_USB_SERVICE_SLEEP, mv_usb_suspend_service);
+	if (error != USB_OK) 
+	{
+	    mvOsPrintf("\nUSB SUSPEND Service Registration failed. Error: 0x%x", error);
+	    return -EINVAL;
+	} /* Endif */    
+	
+	error = _usb_device_register_service(mv_dev->mv_usb_handle, 
+	              ARC_USB_SERVICE_RESUME, mv_usb_resume_service);
+	if (error != USB_OK) 
+	{
+	    mvOsPrintf("\nUSB RESUME Service Registration failed. Error: 0x%x", error);
+	    return -EINVAL;
+	} /* Endif */
+	
+	error = _usb_device_register_service(mv_dev->mv_usb_handle, 0, 
+	              mv_usb_ep0_complete_service);   
+	if (error != USB_OK) 
+	{
+	    mvOsPrintf("\nUSB ep0 TR_COMPLETE Service Registration failed. Error: 0x%x", error);
+	    return error;
+	} /* Endif */
+	
+	for (i=1; i<U2O_USED_ENDPOINTS; i++)
+	{
+	    error = _usb_device_register_service(mv_dev->mv_usb_handle, i, 
+	              mv_usb_tr_complete_service);   
+	    if (error != USB_OK) 
+	    {
+	        mvOsPrintf("\nUSB ep0 TR_COMPLETE Service Registration failed. Error: 0x%x", error);
+	        return error;
+	    } /* Endif */
+}
+
+	return 0;
+}
+
+void u2o_start(void)
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+	
+	ep0_send_buf = u2o_malloc(0x1000);
+	ep1_buf = u2o_malloc(0x1000);
+	ep2_buf = u2o_malloc(0x1000);
+
+	if (usb_debug)
+		printf("ep1_buf %p ep2_buf %p ep0_send_buf %p\n", 
+			ep1_buf, ep2_buf, ep0_send_buf);
+	u2o_enable();
+	_usb_device_start(mv_dev->mv_usb_handle);
+    	mv_usb_start_ep0(mv_dev);
+
+}
+
+static void u2o_dump_info(void)
+{
+	mv_usb_dump();
+}
+
+static int u2o_info(int argc, char *argv[])
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+
+	printf("PMUA_USB_CLK_RES_CTRL %x U2PPLL %x\n", 
+		PMUA_USB_CLK_RES_CTRL, u2o_get(mv_dev->phybase, U2PPLL));
+	u2o_dump_info();
+	return 0;
+}
+
diff --git a/board/pxa/common/usbeth/mv_u2o_ctl.h b/board/pxa/common/usbeth/mv_u2o_ctl.h
new file mode 100644
index 0000000..af884df
--- /dev/null
+++ b/board/pxa/common/usbeth/mv_u2o_ctl.h
@@ -0,0 +1,404 @@
+/*
+ *  Copyright (C) Compaq Computer Corporation, 1998, 1999
+ *  Copyright (C) Extenex Corporation 2001
+ *  Copyright (C) Intrinsyc, Inc., 2002
+ *
+ * (C) Copyright 2006 Marvell International Ltd.  
+ * All Rights Reserved 
+ *
+ *  usb_ctl.h
+ *
+ *  PRIVATE interface used to share info among components of the PXA USB
+ *  core: usb_ctl, usb_ep0, usb_recv and usb_send. Clients of the USB core
+ *  should use pxa_usb.h.
+ *
+ *  02-May-2002
+ *   Frank Becker (Intrinsyc) - derived from sa1100 usb_ctl.h
+ *
+ */
+
+#ifndef _USB_CTL_H
+#define _USB_CTL_H
+
+#define ICU_INT_STATUS_1	(0xD4282130)
+
+#define PMUA_USB_CLK_GATE_CTRL  (0xd4282834)
+#define PMUA_USB_CLK_RES_CTRL   (0xd428285c)
+
+#define U2O_USED_ENDPOINTS 3
+
+#define USB_SPEED_FULL	1
+#define USB_SPEED_HIGH	2
+
+#define USB_ENDPOINT_XFER_BULK		2
+
+#ifdef MMU_ENABLE
+
+#define DMA_AREA_START	DDR_UNCACHABLE_BASE
+#define DMA_BUF_SIZE	0x20000
+
+#define DMA_MALLOC_START	(DMA_AREA_START + DMA_BUF_SIZE)
+#endif
+
+#define ETH_BUF_SIZE	1536
+
+/* registers */
+#define U2O_REG_BASE				0xd4208000
+#define U2O_PHY_BASE				0xd4207000
+
+#define U2xUSBCMD				(0x140)       /* U2O Command */
+#define U2xUSBCMD_RST				(1<<1)      /* Reset */
+#define U2xUSBCMD_RS				(1<<0)      /* Run/Stop */
+
+#define U2xUSBSTS				(0x144)       /* U2O Status */
+#define U2xUSBINTR				(0x148)       /* U2O Interrupt Enable */
+
+#define U2xPORTSC				(0x184)       /* U2O Port Status */
+#define U2xPORTSC_PP                            (1<<12)   		  /* Port Power */
+#define U2xPORTSC_PTS_MASK                      (3<<30)   		  /* Parallel Transceiver Select */
+
+#define U2xUSBINTR				(0x148)       /* U2O Interrupt Enable */
+
+#define U2xUSBMODE				(0x1A8)       /* U2O Device Mode */
+#define U2xUSBMODE_CM_MASK                      (3<<0)   		  /* U2O Controller Mode */
+#define U2xUSBMODE_CM_HOST                      (3<<0)
+#define U2xUSBMODE_CM_DEVICE                    (2<<0)
+#define U2xUSBMODE_SLOM_OFF                     (1<<3)
+#define U2xUSBMODE_SDIS_ACTIVE                  (1<<4)
+#define U2xOTGSC				(0x1A4)       /* U2O On-The-Go Status and Control */
+
+/* OTG interrupt enable bit masks */
+#define  U2xOTGSC_DPIE                         (0x40000000)   /* Data-line pulsing IE */
+#define  U2xOTGSC_1MSIE                        (0x20000000)   /* 1 Millisecond timer IE */
+#define  U2xOTGSC_BSEIE                        (0x10000000)   /* B-session end IE */
+#define  U2xOTGSC_BSVIE                        (0x08000000)   /* B-session valid IE */
+#define  U2xOTGSC_ASVIE                        (0x04000000)   /* A-session valid IE */
+#define  U2xOTGSC_AVVIE                        (0x02000000)   /* A-V-bus valid IE */
+#define  U2xOTGSC_IDIE                         (0x01000000)   /* OTG ID IE */
+#define  U2xOTGSC_IE_MASK   		       (0x7F000000)
+
+/* OTG interrupt status bit masks */
+#define  U2xOTGSC_IS_MASK   (0x007F0000)
+#define  U2xOTGSC_DPIS                         (0x00400000)   /* Data-line pulsing IS */
+#define  U2xOTGSC_1MSIS                        (0x00200000)   /* 1 Millisecond timer IS */
+#define  U2xOTGSC_BSEIS                        (0x00100000)   /* B-session end IS */
+#define  U2xOTGSC_BSVIS                        (0x00080000)   /* B-session valid IS */
+#define  U2xOTGSC_ASVIS                        (0x00040000)   /* A-session valid IS */
+#define  U2xOTGSC_AVVIS                        (0x00020000)   /* A-Vbus valid IS */
+#define  U2xOTGSC_IDIS                         (0x00010000)   /* OTG ID IS */
+
+/* OTG status bit masks */
+#define  U2xOTGSC_DPS                          (0x00004000)   /* Data-line pulsing */
+#define  U2xOTGSC_1MST                         (0x00002000)   /* 1 Milliseconf timer toggle */
+#define  U2xOTGSC_BSE                          (0x00001000)   /* B-session end */
+#define  U2xOTGSC_BSV                          (0x00000800)   /* B-session valid */
+#define  U2xOTGSC_ASV                          (0x00000400)   /* A-session valid */
+#define  U2xOTGSC_AVV                          (0x00000200)   /* A-Vbus Valid */
+#define  U2xOTGSC_ID                           (0x00000100)   /* OTG ID */
+
+/* OTG control bit masks */
+#define  U2xOTGSC_CTL_BITS                     (0x2F)
+#define  U2xOTGSC_HABA                         (0x00000080)   /* hardware assisted B-Dis to A-Con */
+#define  U2xOTGSC_HADP                         (0x00000040)   /* hardware assisted data pulse bits*/
+#define  U2xOTGSC_IDPU                         (0x00000020)   /* ID pull-up enable */
+#define  U2xOTGSC_DP                           (0x00000010)   /* Data-pulsing */
+#define  U2xOTGSC_OT                           (0x00000008)   /* OTG termination */
+#define  U2xOTGSC_HAAR                         (0x00000004)   /* Auto reset bit */
+#define  U2xOTGSC_VC                           (0x00000002)   /* Vbus charge */
+#define  U2xOTGSC_VD                           (0x00000001)   /* Vbus discharge */
+
+/* PHY registers */
+#if 0
+#define U2PPLL		(0x000)       /* U2O PHY PLL Control */
+#define U2PTX		(0x004)       /* U2O PHY TX Control */
+#define U2PRX		(0x008)       /* U2O PHY RX Control */
+#define U2IVREF		(0x00C)       /* U2O PHY IVREF Control */
+#define U2PT0		(0x010)       /* U2O PHY Test 0 Control */
+#define U2PT1		(0x014)       /* U2O PHY Test 1 Control */
+#define U2PT2		(0x018)       /* U2O PHY Test 2 Control */
+#define U2PT3		(0x01C)       /* U2O PHY Test 3 Control */
+#define U2PT4		(0x020)       /* U2O PHY Test 4 Control */
+#define U2PT5		(0x024)       /* U2O PHY Test 5 Control */
+#define U2PID		(0x028)       /* U2O PHY ID Register */
+#define U2PRS		(0x02C)       /* U2O PHY Reserve Register */
+#define U2PMN		(0x030)       /* U2O PHY Monitor Register */
+#define U2OCG		(0x108)       /* U2O Clock Gate Register */
+#else
+#define U2PRSRVD        0x0
+#define U2PCTRL         0x4
+#define U2PPLL          0x8
+#define U2PTX           0xc
+#define U2PRX           0x10
+#define U2PIVREF        0x14
+#define U2PT0           0x18
+#define U2PT1           0x1c
+#define U2PT2           0x20
+#define U2PID           0x24
+#define U2PINT          0x28
+#define U2PDBGCTL       0x2c
+#define U2PCTL1         0x30
+#define U2PT3           0x34
+#define U2PT4           0x38
+#define U2PT5           0x3c
+
+// For UTMICTRL Register
+#define UTMI_CTRL_INPKT_DELAY_SHIFT             30
+#define UTMI_CTRL_INPKT_DELAY_SOF_SHIFT 	28
+#define UTMI_CTRL_ARC_PULLDN_SHIFT              12
+#define UTMI_CTRL_PLL_PWR_UP_SHIFT              1
+#define UTMI_CTRL_PWR_UP_SHIFT                  0
+// For UTMI_PLL Register
+#define UTMI_PLL_CLK_BLK_EN_SHIFT               24
+#define UTMI_PLL_FBDIV_SHIFT                    4
+#define UTMI_PLL_REFDIV_SHIFT                   0
+#define UTMI_PLL_FBDIV_MASK                     0x00000FF0
+#define UTMI_PLL_REFDIV_MASK                    0x0000000F
+// For UTMI_TX Register
+#define UTMI_TX_LOW_VDD_EN_SHIFT                11
+
+#define REG_RCAL_START                          0x00001000
+#define VCOCAL_START                            0x00200000
+#define KVCO_EXT                                0x00400000
+#define PLL_READY                               0x00800000
+#define CLK_BLK_EN                              0x01000000
+
+#endif
+
+#define U2P480		__REG(0x42404078)         /* U2O PHY 480Mhz Control */
+
+/* U2PPLL */
+#define U2PPLL_CTRL_REG		        (0x000)
+#define U2PPLL_TSTB			(1<<31)
+#define U2PPLL_PLLVDD18_SHIFT		(29)
+#define U2PPLL_PLLVDD18_MASK		(3<<29)
+#define U2PPLL_PLLVDD12_SHIFT		(27)
+#define U2PPLL_PLLVDD12_MASK		(3<<27)
+#define U2PPLL_PLLCALI12_SHIFT		(25)
+#define U2PPLL_PLLCALI12_MASK		(3<<25)
+#define U2PPLL_CLK_BLK_EN		(1<<24)
+#define U2PPLL_READY			(1<<23)
+#define U2PPLL_KVCO_EXT			(1<<22)
+#define U2PPLL_VCOCAL_START		(1<<21)
+#define U2PPLL_BGP_VSEL_SHIFT		(19)
+#define U2PPLL_BGP_VSEL_MASK		(3<<19)
+#define U2PPLL_LOCKDET_ISEL		(1<<18)
+#define U2PPLL_KVCO_SHIFT		(15)
+#define U2PPLL_KVCO_MASK		(7<<15)
+#define U2PPLL_ICP_SHIFT		(12)
+#define U2PPLL_ICP_MASK			(7<<12)
+#define U2PPLL_FBDIV_SHIFT		(4)
+#define U2PPLL_FBDIV_MASK		(0xff<<4)
+#define U2PPLL_REFDIV_SHIFT		(0)
+#define U2PPLL_REFDIV_MASK		(0xf<<4)
+
+/* U2PTX */
+#define U2PTX_CTRL_REG                  (0x004)
+#define U2PTX_RCAL_START		(1<<12)
+
+/* U2PRX */
+#define U2PRX_EARLY_VOS_ON_EN			(1<<31)
+#define U2PRX_RXDATA_BLOCK_EN			(1<<30)
+#define U2PRX_RXDATA_BLOCK_LENGTH_SHIFT		(28)
+#define U2PRX_RXDATA_BLOCK_LENGTH_MASK		(3<<28)
+#define U2PRX_EDGE_DET_SEL_SHIFT		(26)
+#define U2PRX_EDGE_DET_SEL_MASK			(3<<26)
+#define U2PRX_EDGE_DET_EN			(1<<25)
+#define U2PRX_S2TO3_DLY_SEL_SHIFT		(23)
+#define U2PRX_S2TO3_DLY_SEL_MASK		(3<<23)
+#define U2PRX_CDR_COEF_SEL			(1<<22)
+#define U2PRX_CDR_FASTLOCK_EN			(1<<21)
+#define U2PRX_PHASE_FREEZE_DLY			(1<<20)
+#define U2PRX_REG_USQ_LENGTH			(1<<19)
+#define U2PRX_REG_ACQ_LENGTH_SHIFT		(17)
+#define U2PRX_REG_ACQ_LENGTH_MASK		(3<<17)
+#define U2PRX_REG_SQ_LENGTH_SHIFT		(15)
+#define U2PRX_REG_SQ_LENGTH_MASK		(3<<15)
+#define U2PRX_DLL_SEL_SHIFT			(13)
+#define U2PRX_DLL_SEL_MASK			(3<<13)
+#define U2PRX_CAP_SEL_SHIFT			(10)
+#define U2PRX_CAP_SEL_MASK			(7<<10)
+#define U2PRX_DISCON_THRESH_SHIFT		(8)
+#define U2PRX_DISCON_THRESH_MASk		(3<<8)
+#define U2PRX_SQ_THRESH_SHIFT			(4)
+#define U2PRX_SQ_THRESH_MASK			(0xf<<4)
+#define U2PRX_LPF_COEF_SHIFT			(2)
+#define U2PRX_LPF_COEF_MASK			(3<<2)
+#define U2PRX_INTPI_SHIFT			(0)
+#define U2PRX_INTPI_MASK			(3<<0)
+
+/* U2IVREF */
+#define U2IVREF_SAMPLER_CTRL           		(1<<31)
+#define U2IVREF_RXVDD18_SHIFT          		(29)
+#define U2IVREF_RXVDD18_MASK           		(3<<29)
+#define U2IVREF_SQ_CM_SEL              		(1<<10)
+#define U2IVREF_BG_VSEL_SHIFT          		(8)
+#define U2IVREF_BG_VSEL_MASK           		(3<<8)
+#define U2IVREF_RXVDD12_SHIFT          		(6)
+#define U2IVREF_RXVDD12_MASK           		(3<<6)
+#define U2IVREF_FSDRV_EN_SHIFT         		(2)
+#define U2IVREF_FSDRV_EN_MASK          		(0xf<<2)
+#define U2IVREF_REG_IMP_CAL_DLY_SHIFT  		(0)
+#define U2IVREF_REG_IMP_CAL_DLY_MASK   		(3<<0)
+
+/* U2PT0 */
+#define U2PT0_REG_ARC_DPDM_MODE			(1<<28)
+
+#ifdef DEBUG
+#define DBGMSG printf
+#else
+#define DBGMSG
+#endif
+
+#define DELAY(ns) 	udelay(ns)
+/*do { \
+		__asm__ volatile (\
+		"mov ip, #1000\n"\
+		"1:	mov r0, r0\n"\
+		"sub ip, ip, #1\n"\
+		"cmp ip, #0\n"\
+		"bne	1b\n");\
+	}while(0);*/
+
+/*================================================
+ * USB Protocol Stuff
+ */
+
+/* Request Codes   */
+enum { 
+	GET_STATUS		=0,
+	CLEAR_FEATURE		=1,
+	/* reserved		=2 */
+	SET_FEATURE		=3,
+	/* reserved		=4 */
+	SET_ADDRESS		=5,        
+	GET_DESCRIPTOR		=6,
+	SET_DESCRIPTOR		=7,
+	GET_CONFIGURATION	=8,
+	SET_CONFIGURATION	=9,
+	GET_INTERFACE		=10,
+	SET_INTERFACE		=11,
+	SYNCH_FRAME		=12
+};
+
+typedef enum {
+	EP0_IDLE,
+	EP0_IN_DATA_PHASE,
+	EP0_END_XFER,
+	EP0_OUT_DATA_PHASE
+} EP0_state;
+
+/* USB Device Requests */
+typedef struct usb_dev_request {
+	__u8 bmRequestType;
+	__u8 bRequest;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+} __attribute__ ((packed)) usb_dev_request_t;
+
+/* Data extraction from usb_request_t fields */
+enum { 
+	kTargetDevice	=0,
+	kTargetInterface=1,
+	kTargetEndpoint	=2 
+};
+
+/*
+ * These states correspond to those in the USB specification v1.0
+ * in chapter 8, Device Framework.
+ */
+enum { 
+	USB_STATE_NOTATTACHED	=0,
+	USB_STATE_ATTACHED	=1,
+	USB_STATE_POWERED	=2,
+	USB_STATE_DEFAULT	=3,
+	USB_STATE_ADDRESS	=4,
+	USB_STATE_CONFIGURED	=5,
+	USB_STATE_SUSPENDED	=6
+};
+
+struct usb_stats_t {
+	 unsigned long ep0_fifo_write_failures;
+	 unsigned long ep0_bytes_written;
+	 unsigned long ep0_fifo_read_failures;
+	 unsigned long ep0_bytes_read;
+};
+
+struct usb_info_t
+{
+	 char * client_name;
+	 int state;
+	 unsigned char address;
+	 struct usb_stats_t stats;
+};
+
+/* in usb_ctl.c */
+extern struct usb_info_t usbd_info;
+extern int usb_connected;
+
+/*
+ * Function Prototypes
+ */
+enum { 
+	kError		=-1,
+	kEvSuspend	=0,
+	kEvReset	=1,
+	kEvResume	=2,
+	kEvAddress	=3,
+	kEvConfig	=4,
+	kEvDeConfig	=5 
+};
+int usbctl_next_state_on_event( int event );
+
+struct mv_usb_ep 
+{
+    struct mv_usb_dev*  usb_dev;
+    int			maxpacket;
+    unsigned            num : 8,
+    			ack_sent : 1,
+			ack_recv : 1,
+                        is_enabled : 1,
+                        is_in : 1;
+};
+
+struct usb_request {
+        void               *buf;
+        int                length;
+};
+
+struct mv_usb_dev {
+	void			*mv_usb_handle;
+	struct mv_usb_ep	ep[2*U2O_USED_ENDPOINTS];
+    	int                     dev_no;
+	unsigned 		*regbase;
+	unsigned 		*phybase;
+};
+
+/* in mv_u2o_ctl.c */
+extern int usb_speed;
+extern struct mv_usb_dev       the_controller;
+
+/* endpoint zero */
+void ep0_reset(void);
+int ep0_int_hndlr(struct usb_request*);
+
+/* receiver */
+void ep2_state_change_notify( int new_state );
+int  ep2_recv(char *buf, int len, usb_callback_t callback);
+int  ep2_init(int chn);
+void ep2_int_hndlr(struct usb_request*);
+void ep2_reset(void);
+void ep2_stall(void);
+
+/* xmitter */
+void ep1_state_change_notify( int new_state );
+int  ep1_send(char *buf, int len, usb_callback_t callback);
+void ep1_reset(void);
+int  ep1_init(int chn);
+void ep1_int_hndlr(struct usb_request*);
+void ep1_stall(void);
+
+
+
+
+#endif /* _USB_CTL_H */
diff --git a/board/pxa/common/usbeth/mv_u2o_ep0.c b/board/pxa/common/usbeth/mv_u2o_ep0.c
new file mode 100644
index 0000000..50bdd2b
--- /dev/null
+++ b/board/pxa/common/usbeth/mv_u2o_ep0.c
@@ -0,0 +1,418 @@
+/*
+ *  Copyright (C) Extenex Corporation 2001
+ *  Copyright (C) Compaq Computer Corporation, 1998, 1999
+ *  Copyright (C) Intrinsyc, Inc., 2002
+ *
+ * (C) Copyright 2006 Marvell International Ltd.  
+ * All Rights Reserved 
+ *
+ *  PXA USB controller driver - Endpoint zero management
+ *
+ *  Please see:
+ *    linux/Documentation/arm/SA1100/SA1100_USB 
+ *  for more info.
+ *
+ *  02-May-2002
+ *   Frank Becker (Intrinsyc) - derived from sa1100 usb_ctl.c
+ * 
+ */
+
+#include <common.h>
+
+#include <linux/types.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <common.h>
+#include <config.h>
+#include <net.h>
+#include <command.h>
+#include <malloc.h>
+
+#include "pxa_usb.h"
+#include "mv_u2o_ctl.h"
+
+#undef	DEBUG 
+//#define DEBUG 3
+#if DEBUG
+static unsigned int usb_debug = DEBUG;
+#else
+#define usb_debug 0     /* gcc will remove all the debug code for us */
+#endif
+
+enum { true = 1, false = 0 };
+typedef int bool;
+#ifndef MIN
+#define MIN( a, b ) ((a)<(b)?(a):(b))
+#endif
+
+extern int usb_speed;
+
+/***************************************************************************
+  Prototypes
+ ***************************************************************************/
+/* "setup handlers" -- the main functions dispatched to by the
+   .. isr. These represent the major "modes" of endpoint 0 operation */
+static int sh_setup_begin(struct usb_request*);				/* setup begin (idle) */
+static void sh_write( void );      				/* writing data */
+static void write_fifo( void );
+static void get_descriptor( usb_dev_request_t * pReq );
+static void queue_and_start_write( void * p, int req, int act );
+
+/***************************************************************************
+  Inline Helpers
+ ***************************************************************************/
+
+inline int type_code_from_request( __u8 by ) { return (( by >> 4 ) & 3); }
+
+/* print string descriptor */
+static inline void psdesc( string_desc_t * p )
+{
+	int i;
+	int nchars = ( p->bLength - 2 ) / sizeof( __u16 );
+	printf( "'" );
+	for( i = 0 ; i < nchars ; i++ ) {
+		printf( "%c", (char) p->bString[i] );
+	}
+	printf( "'\n" );
+}
+
+#if VERBOSITY
+static inline void preq( usb_dev_request_t * pReq )
+{
+	static char * tnames[] = { "dev", "intf", "ep", "oth" };
+	static char * rnames[] = { "std", "class", "vendor", "???" };
+	char * psz;
+	switch( pReq->bRequest ) {
+		case GET_STATUS:        psz = "get stat"; break;
+		case CLEAR_FEATURE:     psz = "clr feat"; break;
+		case SET_FEATURE:       psz = "set feat"; break;
+		case SET_ADDRESS:       psz = "set addr"; break;
+		case GET_DESCRIPTOR:    psz = "get desc"; break;
+		case SET_DESCRIPTOR:    psz = "set desc"; break;
+		case GET_CONFIGURATION: psz = "get cfg"; break;
+		case SET_CONFIGURATION: psz = "set cfg"; break;
+		case GET_INTERFACE:     psz = "get intf"; break;
+		case SET_INTERFACE:     psz = "set intf"; break;
+		case SYNCH_FRAME:       psz = "synch frame"; break;
+		default:                psz = "unknown"; break;
+	}
+	printf( "- [%s: %s req to %s. dir=%s]\n", psz,
+			rnames[ (pReq->bmRequestType >> 5) & 3 ],
+			tnames[ pReq->bmRequestType & 3 ],
+			( pReq->bmRequestType & 0x80 ) ? "in" : "out" );
+}
+
+#else
+static inline void preq( usb_dev_request_t *x){}
+#endif
+
+/***************************************************************************
+  Globals
+ ***************************************************************************/
+static const char pszMe[] = "usbep0: ";
+
+/* global write struct to keep write
+   ..state around across interrupts */
+static struct {
+	unsigned char *p;
+	int bytes_left;
+} wr;
+
+/***************************************************************************
+  Public Interface
+ ***************************************************************************/
+
+/* reset received from HUB (or controller just went nuts and reset by itself!)
+   so udc core has been reset, track this state here  */
+void ep0_reset(void)
+{
+	if (usb_debug) printf( "%sep0_reset\n", pszMe);
+	/* reset state machine */
+	wr.p = 0;
+	wr.bytes_left = 0;
+	usbd_info.address=0;
+}
+
+/* handle interrupt for endpoint zero */
+int ep0_int_hndlr(struct usb_request *usb_req)
+{
+	int ret;
+	if (usb_debug) printf( "%sep0_int_hndlr\n", pszMe);
+	ret = sh_setup_begin(usb_req);
+	return ret;
+}
+
+/***************************************************************************
+  Setup Handlers
+ ***************************************************************************/
+/*
+ * sh_setup_begin()
+ *
+ */
+static int sh_setup_begin(struct usb_request *usb_req)
+{
+	usb_dev_request_t req;
+	int request_type, ret = 0;
+	unsigned n;
+
+	if (usb_debug) printf( "%s sh_setup_begin\n", pszMe);
+
+	if (usb_req->length != sizeof(usb_dev_request_t)) {
+		char *ptr = (char *)usb_req->buf;
+		printf("%s error size usb_req.length: %d\n", 	
+			__func__, usb_req->length);
+		for (n=0; n<usb_req->length;n++) {
+			printf(" %x", *ptr++);
+		}
+		printf("\n");
+	}
+	/* read the setup request */
+	n = memcpy((void*)&req, usb_req->buf, sizeof(usb_dev_request_t));
+
+	/* Is it a standard request? (not vendor or class request) */
+	request_type = type_code_from_request( req.bmRequestType );
+	if ( request_type != 0 ) {
+		printf( "%ssetup begin: unsupported bmRequestType: %d ignored\n",
+				pszMe, request_type );
+		goto sh_sb_end;
+	}
+
+
+#ifdef DEBUG 
+	{
+		unsigned char * pdb = (unsigned char *) &req;
+		if (usb_debug) printf( "%2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X ",
+				pdb[0], pdb[1], pdb[2], pdb[3], pdb[4], pdb[5], pdb[6], pdb[7]
+		       );
+		preq( &req );
+	}
+#endif
+
+	/* Handle it */
+	switch( req.bRequest ) {
+		case GET_DESCRIPTOR:
+			if (usb_debug) printf( "%sGET_DESCRIPTOR\n", pszMe );
+			get_descriptor( &req );
+			break;
+
+		case SET_INTERFACE:
+			if (usb_debug) printf( "%sSET_INTERFACE TODO...\n", pszMe);
+			break;
+
+		case SET_DESCRIPTOR:
+			if (usb_debug) printf( "%sSET_DESCRIPTOR TODO...\n", pszMe );
+			break;
+
+		case SET_CONFIGURATION:
+			if (usb_debug) printf( "%sSET_CONFIGURATION %d\n", pszMe, req.wValue);
+			break;
+		default :
+			printf("%sunknown request 0x%x\n", pszMe, req.bRequest);
+			ret = -1;
+			break;
+	} /* switch( bRequest ) */
+
+sh_sb_end:
+	return ret;
+}
+
+/*
+ * sh_write()
+ * 
+ * Due to UDC bugs we push everything into the fifo in one go.
+ * Using interrupts just didn't work right...
+ * This should be ok, since control request are small.
+ */
+static void sh_write()
+{
+	if (usb_debug) printf( "sh_write\n" );
+	write_fifo();
+}
+
+/***************************************************************************
+  Other Private Subroutines
+ ***************************************************************************/
+/*
+ * queue_and_start_write()
+ * data == data to send
+ * req == bytes host requested
+ * act == bytes we actually have
+ *
+ * Sets up the global "wr"-ite structure and load the outbound FIFO 
+ * with data.
+ *
+ */
+static void queue_and_start_write( void * data, int req, int act )
+{
+	if (usb_debug) printf( "write start: bytes requested=%d actual=%d\n", req, act);
+
+	wr.p = (unsigned char*) data;
+	wr.bytes_left = MIN( act, req );
+
+	sh_write();
+
+	return;
+}
+/*
+ * write_fifo()
+ * Stick bytes in the endpoint zero FIFO.
+ *
+ */
+#define MAX_SETUP_PACKET_SIZE 256
+
+static void write_fifo( void )
+{
+	struct mv_usb_dev *mv_usb = &the_controller;
+	extern int * ep0_send_buf;
+	__u8  *data=(__u8 *)ep0_send_buf;
+	struct usb_request usb_req;
+	
+	memcpy(data, wr.p, wr.bytes_left);
+	usb_req.buf = data;
+	usb_req.length = wr.bytes_left;
+
+	if (usb_debug) printf("%s  data=0x%p len %d\n", 
+		__FUNCTION__, data, usb_req.length);
+	if (usb_debug) {
+		char *ptr = data;
+		int i;
+		for (i=0;i<usb_req.length;i++) {
+			printf(" %x", *ptr++);
+		}
+		printf("\n");
+	}
+
+	mv_usb_ep_queue(&mv_usb->ep[0], &usb_req);
+
+	wr.p += usb_req.length;
+	wr.bytes_left -= usb_req.length;
+
+	usbd_info.stats.ep0_bytes_written += usb_req.length;
+
+	if (usb_debug) 
+		printf( "write fifo: bytes sent=%d\n", usb_req.length);
+}
+
+/*
+ * get_descriptor()
+ * Called from sh_setup_begin to handle data return
+ * for a GET_DESCRIPTOR setup request.
+ *
+ * +-----+------------------------------------------------+-----------------+
+ * | dev | cfg1 | intf 1 | ep 1..N | intf 2 | ep 1..N |...| cfg2 .......... |
+ * +-----+------------------------------------------------+-----------------+
+ */
+static void get_descriptor( usb_dev_request_t * pReq )
+{
+	string_desc_t * pString;
+	ep_desc_t * pEndpoint = 0;
+	config_desc_t *pcfg = 0;
+
+	desc_t * pDesc = pxa_usb_get_descriptor_ptr();
+	int type = pReq->wValue >> 8;
+	int idx  = pReq->wValue & 0xFF;
+
+	if (usb_debug) printf( "%sget_descriptor for %d\n", pszMe, type );
+	switch( type ) {
+		case USB_DESC_DEVICE:
+			/* return device descritpor */
+			queue_and_start_write( &pDesc->dev,
+					pReq->wLength,
+					pDesc->dev.bLength );
+			break;
+
+			// return device qualifier descriptor
+		case USB_DESC_QUALIFIER:
+			queue_and_start_write( &pDesc->qua,
+					pReq->wLength,
+					pDesc->qua.bLength );
+			break;
+
+			// return config descriptor buffer, cfg, intf 1..N,  ep 1..N
+		case USB_DESC_CONFIG:
+			{
+				int i,len;
+				config_desc_t *cfg =(config_desc_t*) (pDesc->cdb);
+
+				len=0;
+				for( i=0; i<pDesc->dev.bNumConfigurations; i++) {
+					len += __le16_to_cpu(cfg->wTotalLength);
+					cfg = (config_desc_t*) ( (unsigned char*) cfg 
+							+ __le16_to_cpu(cfg->wTotalLength)) ;
+				}
+					
+				queue_and_start_write( pDesc->cdb,
+						pReq->wLength,
+						len);
+			}
+			break;
+			
+			// return other speed config descriptor buffer
+		case USB_DESC_OTHER_SPEED_CONFIG:
+			{
+				int i,len;
+				config_desc_t *cfg =(config_desc_t*) (pDesc->cdb);
+
+				if(usb_speed == USB_SPEED_HIGH) usb_driver_speed(USB_SPEED_FULL);
+				else usb_driver_speed(USB_SPEED_HIGH);
+				len=0;
+				for( i=0; i<pDesc->dev.bNumConfigurations; i++) {
+					len += __le16_to_cpu(cfg->wTotalLength);
+					cfg = (config_desc_t*) ( (unsigned char*) cfg 
+							+ __le16_to_cpu(cfg->wTotalLength)) ;
+				}
+					
+				queue_and_start_write( pDesc->cdb,
+						pReq->wLength,
+						len);
+				usb_driver_speed(usb_speed);
+			}
+			break;
+			
+			// not quite right, since doesn't do language code checking
+		case USB_DESC_STRING:
+			pString = pxa_usb_get_string_descriptor( idx );
+			if ( pString ) {
+				if ( idx != 0 ) {  // if not language index
+					printf( "%sReturn string %d: ", pszMe, idx );
+					psdesc( pString );
+				}
+				queue_and_start_write( pString,
+						pReq->wLength,
+						pString->bLength );
+			}
+			else {
+				printf("%sunkown string index %d Stall.\n", pszMe, idx );
+			}
+			break;
+
+			/*
+		case USB_DESC_INTERFACE:
+			for( i = 0; i < pDesc->intf_num; i++) {
+				if ( idx == pDesc->intf[i].bInterfaceNumber ) {
+					queue_and_start_write( &pDesc->intf[i],
+							pReq->wLength,
+							pDesc->intf[i].bLength );
+				}
+			}
+			break;
+
+		case USB_DESC_ENDPOINT: 
+			for( i = 0; i < pDesc->ep_num; i++) {
+				if ( idx == (0x0F & pDesc->ep[i].bEndpointAddress)) {
+					queue_and_start_write( &pDesc->ep[i],
+							pReq->wLength,
+							pDesc->ep[i].bLength );
+				}
+			}
+			break;
+			*/
+
+		default :
+			printf("%sunknown descriptor type %d. Stall.\n", pszMe, type );
+			break;
+
+	}
+}
+
+/* end usb_ep0.c - who needs this comment? */
diff --git a/board/pxa/common/usbeth/mv_u2o_ep1.c b/board/pxa/common/usbeth/mv_u2o_ep1.c
new file mode 100644
index 0000000..ca7113f
--- /dev/null
+++ b/board/pxa/common/usbeth/mv_u2o_ep1.c
@@ -0,0 +1,206 @@
+/*
+ * Generic xmit layer for the PXA USB client function
+ *
+ * This code was loosely inspired by the original version which was
+ * Copyright (c) Compaq Computer Corporation, 1998-1999
+ * Copyright (c) 2001 by Nicolas Pitre
+ *
+ * (C) Copyright 2006 Marvell International Ltd.  
+ * All Rights Reserved 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 02-May-2002
+ *   Frank Becker (Intrinsyc) - derived from sa1100 usb_send.c
+ *
+ */
+#include <common.h>
+
+#include <linux/types.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <common.h>
+#include <config.h>
+#include <net.h>
+#include <command.h>
+#include <malloc.h>
+
+#include "pxa_usb.h"
+#include "mv_u2o_ctl.h"
+#include "mv_u2o_api.h"
+
+#undef DEBUG
+//#define DEBUG 3
+#if DEBUG
+static unsigned int usb_debug = DEBUG;
+#else
+#define usb_debug 0     /* gcc will remove all the debug code for us */
+#endif
+
+#ifndef MMU_ENABLE
+static char  ep1_buf[1024];
+#else
+extern int *ep1_buf;
+#endif
+static int   ep1_len;
+static int   ep1_remain;
+static int   ep1_retries = 0;
+static usb_callback_t ep1_callback;
+static int tx_pktsize;
+
+static void ep1_done(int flag);
+static int u2d_info();
+
+void dump_buffer(char *buf, unsigned length)
+{
+        char *c = buf;
+        unsigned i;
+		
+	if (!usb_debug)
+		return;
+       	printf("%s, buffer:%p, total length:%d\n", __func__, buf, length);
+        for (i = 0; i < length; i++) {
+                if (0 == i % 10)
+                        printf("\n");
+                printf (" %2x", c[i]);
+        }
+        printf("\n");
+}
+
+extern int req_pending;
+/* device state is changing, async */
+void
+ep1_state_change_notify( int new_state )
+{
+}
+
+/* set feature stall executing, async */
+void
+ep1_stall( void )
+{
+}
+
+static void ep1_send_packet(void)
+{
+	struct mv_usb_dev *mv_dev = &the_controller;
+	int i, count=100, complete = 0;
+	struct usb_request ep1_req;
+	
+	/* init the params for transfer */
+	ep1_req.buf = ep1_buf;
+	ep1_req.length = ep1_len;
+	
+	mv_usb_ep_queue(&mv_dev->ep[3], &ep1_req);
+	
+	if ((usb_speed == USB_SPEED_FULL) && !(ep1_len%64)) {
+		struct usb_request ep1_req_zero;
+		ep1_req_zero.buf = ep1_buf;
+		ep1_req_zero.length = 0;
+		mv_usb_ep_queue(&mv_dev->ep[3], &ep1_req_zero);	
+	}
+
+	if (usb_debug) {
+		printf("%s: exit, buf %x len %d\n", 
+			__FUNCTION__, ep1_buf, ep1_len);
+	}
+}
+
+static void
+ep1_start(void)
+{
+	if (!ep1_len)
+		return;
+
+	ep1_send_packet();
+}
+
+static void
+ep1_done(int flag)
+{
+	int size = ep1_len - ep1_remain;
+	if (ep1_len) {
+		ep1_len = 0;
+		if (ep1_callback) {
+			ep1_callback(flag, size);
+		}
+	}
+}
+
+int
+ep1_init(int chn)
+{
+	if (usb_debug)
+		printf("%s\n", __func__);
+	return 0;
+}
+
+void
+ep1_reset(void)
+{
+	ep1_done(-EINTR);
+}
+
+void ep1_int_hndlr(struct usb_request *usb_req)
+{
+	ep1_remain = ep1_len - usb_req->length;
+
+	if (usb_debug)
+		printf("%s send finisned buf %x len %d remain %d\n", 
+			__func__, usb_req->buf, usb_req->length, ep1_remain);
+
+	if (ep1_remain != 0) {
+		/* more data to go */
+		ep1_start();
+	} else {
+		ep1_done(0);
+	}
+
+}
+
+int
+ep1_send(char *buf, int len, usb_callback_t callback)
+{
+	int i=0;
+	int flags;
+
+	if (usb_debug) printf( "\npxa_usb_send: "
+		"data len=%d state=%d blen=%d\n", 
+		len, usbd_info.state, ep1_len);
+	
+	if (usbd_info.state != USB_STATE_CONFIGURED) {
+		printf("state %d -ENODEV\n", usbd_info.state);
+		return -ENODEV;
+	}
+
+	if (ep1_len) {
+		ep1_retries++;
+		if (ep1_retries >3) {
+			printf("ep1_len %d -EBUSY\n", ep1_len);
+			ep1_retries = 0;
+			return -EBUSY;
+		}
+	}
+
+	ep1_retries = 0;
+	memcpy(ep1_buf, buf, len);
+	ep1_len = len;
+	ep1_callback = callback;
+	ep1_remain = len;
+	ep1_start();
+
+	return 0;
+}
+
+int 
+ep1_xmitter_avail( void )
+{
+	if (usbd_info.state != USB_STATE_CONFIGURED)
+		return -ENODEV;
+	if (ep1_len)
+		return -EBUSY;
+	return 0;
+}
+
+
diff --git a/board/pxa/common/usbeth/mv_u2o_ep2.c b/board/pxa/common/usbeth/mv_u2o_ep2.c
new file mode 100644
index 0000000..5409877
--- /dev/null
+++ b/board/pxa/common/usbeth/mv_u2o_ep2.c
@@ -0,0 +1,147 @@
+/*
+ * Generic receive layer for the PXA USB client function
+ *
+ * This code was loosely inspired by the original version which was
+ * Copyright (c) Compaq Computer Corporation, 1998-1999
+ * Copyright (c) 2001 by Nicolas Pitre
+ *
+ * (C) Copyright 2006 Marvell International Ltd.  
+ * All Rights Reserved 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 02-May-2002
+ *   Frank Becker (Intrinsyc) - derived from sa1100 usb_recv.c
+ * 
+ * TODO: Add support for DMA.
+ *
+ */
+
+#include <common.h>
+
+#include <linux/types.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <common.h>
+#include <config.h>
+#include <net.h>
+#include <command.h>
+#include <malloc.h>
+
+#include "pxa_usb.h"
+#include "mv_u2o_ctl.h"
+
+#undef DEBUG
+//#define DEBUG 3
+#if DEBUG
+static unsigned int usb_debug = DEBUG;
+#else
+#define usb_debug 0     /* gcc will remove all the debug code for us */
+#endif
+
+#ifndef MMU_ENABLE
+static char *ep2_buf;
+#else
+static char *callback_buf;
+extern char *ep2_buf;
+#endif
+static int   ep2_len;
+static int   ep2_remain;
+static struct usb_request ep2_req;
+static usb_callback_t ep2_callback;
+
+static void ep2_start(void)
+{
+	struct mv_usb_dev *mv_usb = &the_controller;
+	struct usb_request ep2_req;
+
+	ep2_req.buf = ep2_buf;
+	ep2_req.length = ep2_len;
+
+	if (usb_debug)
+		printf("%s queue ep2 buf %p len %x\n", 
+			__func__, ep2_buf, ep2_len);
+	mv_usb_ep_queue(&mv_usb->ep[2], &ep2_req);
+}
+
+void
+ep2_done(int flag)
+{
+	int size = ep2_len - ep2_remain;
+
+	if (usb_debug)
+		printf("%s ep2_len %d remain %d size %d\n", 
+			__func__, ep2_len, ep2_remain, size);
+
+	if (!ep2_len)
+		return;
+
+	ep2_len = 0;
+	if (ep2_callback) {
+#ifdef MMU_ENABLE
+		if (usb_debug)
+			printf("ep2_buf %p callback_buf %p size %d\n", 
+				ep2_buf, callback_buf, size);
+		memcpy(callback_buf, ep2_buf, size);
+#endif
+		ep2_callback(flag, size);
+	}
+}
+
+void
+ep2_state_change_notify( int new_state )
+{
+}
+
+void
+ep2_stall( void )
+{
+}
+
+void
+ep2_reset(void)
+{
+	ep2_done(-EINTR);
+}
+
+extern int usb_connected;
+
+void ep2_int_hndlr(struct usb_request *usb_req)
+{
+	unsigned int desc_num, length, i, count;
+
+	ep2_remain = ep2_len - usb_req->length;
+
+	ep2_done(0);
+	if( usb_debug) 
+		printf("ep2_int_hndlr end: ep2_remain %d buf %d, len %d\n",
+			ep2_remain, usb_req->buf, usb_req->length);
+
+	return;
+}
+
+int ep2_recv(char *buf, int len, usb_callback_t callback)
+{
+	int flags;
+
+	if (ep2_len){
+		printf("%s, busy, ep2_len %d\n", __FUNCTION__, ep2_len);
+		return -EBUSY;
+	}
+
+#ifndef MMU_ENABLE
+	ep2_buf = buf;
+#else
+	callback_buf = buf;
+#endif
+
+	ep2_len = len;
+	ep2_callback = callback;
+	ep2_remain = len;
+	ep2_start();
+	
+	return 0;
+}
+
diff --git a/board/pxa/common/usbeth/pxa_usb.h b/board/pxa/common/usbeth/pxa_usb.h
new file mode 100644
index 0000000..b1ded0f
--- /dev/null
+++ b/board/pxa/common/usbeth/pxa_usb.h
@@ -0,0 +1,266 @@
+/*
+ * pxa_usb.h
+ *
+ * Public interface to the pxa USB core. For use by client modules
+ * like usb-eth and usb-char.
+ *
+ * 02-May-2002
+ *   Frank Becker (Intrinsyc) - derived from sa1100_usb.h
+ *
+ */
+
+#ifndef _PXA_USB_H
+#define _PXA_USB_H
+#include <asm/byteorder.h>
+
+#define MAX_CONFIGS	3
+#define MAX_INTERFACES	2
+#define MAX_ENDPOINTS	4
+
+typedef void (*usb_callback_t)(int flag, int size);
+
+/* in usb_ctl.c (see also descriptor methods at bottom of file) */
+
+// Open the USB client for client and initialize data structures
+// to default values, but _do not_ start UDC.
+int pxa_usb_open( const char * client_name );
+
+// Start UDC running
+int pxa_usb_start( void );
+
+// Immediately stop udc, fire off completion routines w/-EINTR
+int pxa_usb_stop( void ) ;
+
+// Disconnect client from usb core
+int pxa_usb_close( void ) ;
+
+// set notify callback for when core reaches configured state
+// return previous pointer (if any)
+typedef void (*usb_notify_t)(void);
+usb_notify_t pxa_set_configured_callback( usb_notify_t callback );
+
+/* in usb_send.c */
+int pxa_usb_xmitter_avail( void );
+int pxa_usb_send(char *buf, int len, usb_callback_t callback);
+void sa110a_usb_send_reset(void);
+
+/* in usb_recev.c */
+int pxa_usb_recv(char *buf, int len, usb_callback_t callback);
+void pxa_usb_recv_reset(void);
+
+//////////////////////////////////////////////////////////////////////////////
+// Descriptor Management
+//////////////////////////////////////////////////////////////////////////////
+
+#define DescriptorHeader \
+	__u8 bLength;        \
+	__u8 bDescriptorType
+
+
+// --- Device Descriptor -------------------
+
+typedef struct {
+	 DescriptorHeader;
+	 __u16 bcdUSB;		   	/* USB specification revision number in BCD */
+	 __u8  bDeviceClass;	/* USB class for entire device */
+	 __u8  bDeviceSubClass; /* USB subclass information for entire device */
+	 __u8  bDeviceProtocol; /* USB protocol information for entire device */
+	 __u8  bMaxPacketSize0; /* Max packet size for endpoint zero */
+	 __u16 idVendor;        /* USB vendor ID */
+	 __u16 idProduct;       /* USB product ID */
+	 __u16 bcdDevice;       /* vendor assigned device release number */
+	 __u8  iManufacturer;	/* index of manufacturer string */
+	 __u8  iProduct;        /* index of string that describes product */
+	 __u8  iSerialNumber;	/* index of string containing device serial number */
+	 __u8  bNumConfigurations; /* number fo configurations */
+} __attribute__ ((__packed__)) device_desc_t;
+
+// --- Configuration Descriptor ------------
+
+typedef struct {
+	 DescriptorHeader;
+	 __u16 wTotalLength;	    /* total # of bytes returned in the cfg buf 4 this cfg */
+	 __u8  bNumInterfaces;      /* number of interfaces in this cfg */
+	 __u8  bConfigurationValue; /* used to uniquely ID this cfg */
+	 __u8  iConfiguration;      /* index of string describing configuration */
+	 __u8  bmAttributes;        /* bitmap of attributes for ths cfg */
+	 __u8  MaxPower;		    /* power draw in 2ma units */
+} __attribute__ ((__packed__)) config_desc_t;
+
+// bmAttributes:
+enum { 
+	USB_CONFIG_REMOTEWAKE=0xA0, 
+	USB_CONFIG_SELFPOWERED=0xC0,
+	USB_CONFIG_BUSPOWERED=0x80 
+};
+
+// MaxPower:
+#define USB_POWER( x)  ((x)>>1) /* convert mA to descriptor units of A for MaxPower */
+
+// --- Interface Descriptor ---------------
+
+typedef struct {
+	 DescriptorHeader;
+	 __u8  bInterfaceNumber;   /* Index uniquely identfying this interface */
+	 __u8  bAlternateSetting;  /* ids an alternate setting for this interface */
+	 __u8  bNumEndpoints;      /* number of endpoints in this interface */
+	 __u8  bInterfaceClass;    /* USB class info applying to this interface */
+	 __u8  bInterfaceSubClass; /* USB subclass info applying to this interface */
+	 __u8  bInterfaceProtocol; /* USB protocol info applying to this interface */
+	 __u8  iInterface;         /* index of string describing interface */
+} __attribute__ ((__packed__)) intf_desc_t;
+
+// --- Endpoint  Descriptor ---------------
+
+typedef struct {
+	 DescriptorHeader;
+	 __u8  bEndpointAddress;  /* 0..3 ep num, bit 7: 0 = 0ut 1= in */
+	 __u8  bmAttributes;      /* 0..1 = 0: ctrl, 1: isoc, 2: bulk 3: intr */
+	 __u16 wMaxPacketSize;    /* data payload size for this ep in this cfg */
+	 __u8  bInterval;         /* polling interval for this ep in this cfg */
+} __attribute__ ((__packed__)) ep_desc_t;
+
+// bEndpointAddress:
+enum { 
+	USB_OUT	=0, 
+	USB_IN	=1 
+};
+
+#define USB_EP_ADDRESS(a,d) (((a)&0xf) | ((d) << 7))
+// bmAttributes:
+enum { 
+	USB_EP_CNTRL	=0, 
+	USB_EP_BULK	=2, 
+	USB_EP_INT	=3, 
+	USB_EP_ISO	=4 
+};
+
+// --- String Descriptor -------------------
+
+typedef struct {
+	 DescriptorHeader;
+	 __u16 bString[1];		  /* unicode string .. actaully 'n' __u16s */
+} __attribute__ ((__packed__)) string_desc_t;
+
+// --- Device Qualifier Descriptor ---------------
+
+typedef struct  {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u16 bcdUSB;
+	__u8  bDeviceClass;
+	__u8  bDeviceSubClass;
+	__u8  bDeviceProtocol;
+	__u8  bMaxPacketSize0;
+	__u8  bNumConfigurations;
+	__u8  bRESERVED;
+} __attribute__ ((__packed__)) qua_desc_t;
+
+
+
+/*=======================================================
+ * Handy helpers when working with above
+ *
+ */
+// these are x86-style 16 bit "words" ...
+#define make_word_c( w ) __constant_cpu_to_le16(w)
+#define make_word( w )   __cpu_to_le16(w)
+
+// descriptor types
+enum { 
+    USB_DESC_DEVICE	= 1,
+    USB_DESC_CONFIG	= 2,
+    USB_DESC_STRING	= 3,
+    USB_DESC_INTERFACE	= 4,
+    USB_DESC_ENDPOINT	= 5,
+    USB_DESC_QUALIFIER	= 6,
+    USB_DESC_OTHER_SPEED_CONFIG = 7
+};
+
+
+/*=======================================================
+ * Default descriptor layout for SA-1100 and SA-1110 UDC
+ */
+
+enum {
+  UNUSED = 0,
+
+  BULK_IN1  =  1,
+  BULK_OUT1 =  2,
+  ISO_IN1   =  3,
+  ISO_OUT1  =  4,
+  INT_IN1   =  5,
+
+  BULK_IN2  =  6,
+  BULK_OUT2 =  7,
+  ISO_IN2   =  8,
+  ISO_OUT2  =  9,
+  INT_IN2   = 10,
+
+  BULK_IN3  = 11,
+  BULK_OUT3 = 12,
+  ISO_IN3   = 13,
+  ISO_OUT3  = 14,
+  INT_IN3   = 15
+} /*endpoint_type*/;
+
+/* "config descriptor buffer" - that is, one config,
+   ..one interface and 2 endpoints */
+//struct cdb {
+//	 config_desc_t cfg;
+//	 intf_desc_t   intf;
+//	 ep_desc_t     ep1;
+//	 ep_desc_t     ep2;
+//} __attribute__ ((packed));
+
+/* all SA device descriptors */
+//typedef struct {
+//	 device_desc_t dev;   /* device descriptor */
+//	 struct cdb b;        /* bundle of descriptors for this cfg */
+//} __attribute__ ((packed)) desc_t;
+
+
+typedef struct {
+	device_desc_t 	dev;	/* device descriptor */	
+	char		cdb[1024]; /* FIXME */
+	qua_desc_t	qua;
+	
+} desc_t;
+
+/*=======================================================
+ * Descriptor API
+ */
+
+/* Get the address of the statically allocated desc_t structure
+   in the usb core driver. Clients can modify this between
+   the time they call pxa_usb_open() and pxa_usb_start()
+*/
+desc_t *
+pxa_usb_get_descriptor_ptr( void );
+
+/* Set a pointer to the string descriptor at "index". The driver
+ ..has room for 8 string indicies internally. Index zero holds
+ ..a LANGID code and is set to US English by default. Inidices
+ ..1-7 are available for use in the config descriptors as client's
+ ..see fit. This pointer is assumed to be good as long as the
+ ..SA usb core is open (so statically allocate them). Returnes -EINVAL
+ ..if index out of range */
+int pxa_usb_set_string_descriptor( int index, string_desc_t * p );
+
+/* reverse of above */
+string_desc_t *
+pxa_usb_get_string_descriptor( int index );
+
+config_desc_t * 
+pxa_usb_get_config(int cfgval);
+
+intf_desc_t *
+pxa_usb_get_intf(config_desc_t *cfg, int idx);
+
+ep_desc_t * 
+pxa_usb_get_endpoint(intf_desc_t *intf, int idx);
+
+
+
+#endif /* _PXA_USB_H */
diff --git a/include/configs/tavorevb.h b/include/configs/tavorevb.h
index 576a18c..1e927e4 100644
--- a/include/configs/tavorevb.h
+++ b/include/configs/tavorevb.h
@@ -192,6 +192,7 @@
 #undef TURN_ON_ETHERNET
 #define TURN_ON_ETHERNET
 #ifdef TURN_ON_ETHERNET
+#define CONFIG_USB_ETH
 #define CONFIG_DRIVER_SMC91111 		1
 #define CONFIG_SMC91111_BASE   		0x90000300 /* ttc */
 #define CONFIG_SMC_USE_16_BIT
diff --git a/net/eth.c b/net/eth.c
index 9be93c9..09df28e 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -155,6 +155,9 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_DRIVER_SMC91111) && defined(CONFIG_CMD_NET)
 	smc_eth_initialize();
 #endif
+#if defined(CONFIG_USB_ETH)
+	u2o_eth_initialize(bis);
+#endif
 	if (!eth_devices) {
 		puts ("No ethernet found.\n");
 		show_boot_progress (-64);
@@ -473,6 +476,7 @@ extern int emac4xx_miiphy_initialize(bd_t *bis);
 extern int mcf52x2_miiphy_initialize(bd_t *bis);
 extern int ns7520_miiphy_initialize(bd_t *bis);
 extern int davinci_eth_miiphy_initialize(bd_t *bis);
+extern int u2o_eth_initialize(bd_t *);
 
 
 int eth_initialize(bd_t *bis)
@@ -496,6 +500,10 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_DRIVER_TI_EMAC)
 	davinci_eth_miiphy_initialize(bis);
 #endif
+#if defined(CONFIG_USB_ETH)
+	u2o_eth_initialize(bis);
+#endif
+
 	return 0;
 }
 #endif
-- 
1.6.0.4

